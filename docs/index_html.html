<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Anthony" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="Personal notes on Mathematics and Computer Science" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Notes on Everything</title>
<link rel="stylesheet" type="text/css" href="lwarp.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
  subequations: "0",
  section: "",
  loader: {
    load: ['[tex]/tagformat', '[tex]/textmacros'],
  },
  startup: {
    ready() {
      // These would be replaced by import commands if you wanted to make
      // a proper extension.
      const Configuration = MathJax._.input.tex.Configuration.Configuration;
      const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
      const Macro = MathJax._.input.tex.Symbol.Macro;
      const TexError = MathJax._.input.tex.TexError.default;
      const ParseUtil = MathJax._.input.tex.ParseUtil.default;
      const expandable = MathJax._.util.Options.expandable;

       // Insert the replacement string into the TeX string, and check
       // that there haven't been too many maxro substitutions (prevents
       // infinite loops).
       const useArgument = (parser, text) => {
         parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
         parser.i = 0;
         if (++parser.macroCount > parser.configuration.options.maxMacros) {
           throw new TexError('MaxMacroSub1',
           'MathJax maximum macro substitution count exceeded; ' +
           'is there a recursive macro call?');
         }
       }

       // Create the command map for:
       //     \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
       new CommandMap('Lwarp-macros', {
         ifstar: 'IfstarFunction',
         ifnextchar: 'IfnextcharFunction',
         ifblank: 'IfblankFunction',
         ifstrequal: 'IfstrequalFunction',
         gsubstitute: 'GsubstituteFunction',
         seteqnumber: 'SeteqnumberFunction'
       }, {
         // This function implements an ifstar macro.
         IfstarFunction(parser, name) {
            const resultstar = parser.GetArgument(name);
            const resultnostar = parser.GetArgument(name);
            const star = parser.GetStar();                 // true if there is a *
            useArgument(parser, star ? resultstar : resultnostar);
         },

         // This function implements an ifnextchar macro.
         IfnextcharFunction(parser, name) {
           let whichchar = parser.GetArgument(name);
           if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
             // $ syntax highlighting
             whichchar = String.fromCodePoint(parseInt(whichchar));
           }
           const resultnextchar = parser.GetArgument(name);
           const resultnotnextchar = parser.GetArgument(name);
           const gotchar = (parser.GetNext() === whichchar);
           useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
         },

         // This function implements an ifblank macro.
         IfblankFunction(parser, name) {
           const blankarg = parser.GetArgument(name);
           const resultblank = parser.GetArgument(name);
           const resultnotblank = parser.GetArgument(name);
           const isblank = (blankarg.trim() == "");
           useArgument(parser, isblank ? resultblank : resultnotblank);
         },

         // This function implements an ifstrequal macro.
         IfstrequalFunction(parser, name) {
           const strequalfirst = parser.GetArgument(name);
           const strequalsecond = parser.GetArgument(name);
           const resultequal = parser.GetArgument(name);
           const resultnotequal = parser.GetArgument(name);
           const isequal = (strequalfirst == strequalsecond);
           useArgument(parser, isequal ? resultequal : resultnotequal);
         },

         // This function implements a gsub macro.
         GsubstituteFunction(parser, name) {
           const gsubfirst = parser.GetArgument(name);
           const gsubsecond = parser.GetArgument(name);
           const gsubthird = parser.GetArgument(name);
           let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
           useArgument(parser, gsubresult);
         },

         // This function modifies the equation numbers.
         SeteqnumberFunction(parser, name) {
             // Get the macro parameters
             const star = parser.GetStar();                  // true if there is a *
             const optBrackets = parser.GetBrackets(name);   // contents of optional brackets
             const newsubequations = parser.GetArgument(name); // the subequations argument
             const neweqsection = parser.GetArgument(name); // the eq section argument
             const neweqnumber = parser.GetArgument(name);   // the eq number argument
             MathJax.config.subequations=newsubequations ;   // a string with boolean meaning
             MathJax.config.section=neweqsection ;           // a string with numeric meaning
             parser.tags.counter = parser.tags.allCounter = neweqnumber ;
         }

       });

       // Create the Lwarp-macros package
       Configuration.create('Lwarp-macros', {
         handler: {macro: ['Lwarp-macros']}
       });

       MathJax.startup.defaultReady();

       // For forward references:
       MathJax.startup.input[0].preFilters.add(({math}) => {
         if (math.inputData.recompile){
             MathJax.config.subequations = math.inputData.recompile.subequations;
             MathJax.config.section = math.inputData.recompile.section;
         }
       });
       MathJax.startup.input[0].postFilters.add(({math}) => {
         if (math.inputData.recompile){
             math.inputData.recompile.subequations = MathJax.config.subequations;
             math.inputData.recompile.section = MathJax.config.section;
         }
       });

         // For \left, \right with unicode-math:
         const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
         const {Symbol} = MathJax._.input.tex.Symbol;
         const {MapHandler} = MathJax._.input.tex.MapHandler;
         const delimiter = MapHandler.getMap('delimiter');
         delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
         delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
         delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
         delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
         delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
         delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
         delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
         delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
         delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
         delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
         delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
         delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
         delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
         delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
         delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
         delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
         delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
         delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
         delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
         delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
         delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
         delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
         delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
         delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
         delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
         delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
         delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
         delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
         delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
         delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
         delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
         delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
         delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
         delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
         delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
         delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
         delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
         delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
         delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
   }     // ready
 },      // startup

 tex: {
   packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
   tags: "ams",
        tagformat: {
            number: function (n) {
                if(MathJax.config.subequations==0)
                    return(MathJax.config.section + n);
                else
                    return(MathJax.config.section + String.fromCharCode(96+n));
            },
        },
 }
}
</script>

<script
    id="MathJax-script"
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>
<!--|Using lwarp|index-0.html|-->


<div class="bodywithoutsidetoc">


<main class="bodycontainer">


<section class="textbody">

<a id="index-autofile-0"></a>

<!--MathJax customizations:-->
<div data-nosnippet
    style="display:none"
>

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

</div>

<a id="index-autopage-1"></a>
<div class="titlepage">

<h1>Notes on Everything</h1>


<div class="author">


<div class="oneauthor">

<p>
Anthony
</p>
</div>

</div>


<div class="titledate">

<p>
April 14, 2024
</p>
</div>

</div>

<p>
Notes on Mathematics and Computer Science.
</p>
<!--
...... chapter Subjects ......
-->
<h3 id="autosec-3">Subjects</h3>
<a id="index-autopage-3"></a>



<nav class="toc">

<p>
<a href="Sums.html#autosec-6" class="tocchapter" >
Sums</a>
</p>


<p>
<a href="Sums.html#autosec-7" class="tocsection" >
Manipulating Sums</a>
</p>


<p>
<a href="Finite-Calculus.html#autosec-24" class="tocsection" >
Finite Calculus</a>
</p>


<p>
<a href="Algorithms.html#autosec-30" class="tocchapter" >
Algorithms</a>
</p>


<p>
<a href="Algorithms.html#autosec-31" class="tocsection" >
Graphs</a>
</p>


<p>
<a href="Greedy.html#autosec-49" class="tocsection" >
Greedy</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-84" class="tocsection" >
Divide and Conquer</a>
</p>


<p>
<a href="Combinatorics.html#autosec-94" class="tocchapter" >
Combinatorics</a>
</p>


<p>
<a href="Combinatorics.html#autosec-95" class="tocsection" >
Basics of Counting</a>
</p>


<p>
<a href="Probability.html#autosec-109" class="tocchapter" >
Probability</a>
</p>


<p>
<a href="Probability.html#autosec-110" class="tocsection" >
Basics</a>
</p>


<p>
<a href="Foundations.html#autosec-120" class="tocchapter" >
Foundations</a>
</p>


<p>
<a href="Foundations.html#autosec-121" class="tocsection" >
Set Theory</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-152" class="tocsection" >
Factoring Tricks</a>
</p>


<p>
<a href="Quadratics.html#autosec-162" class="tocsection" >
Quadratics</a>
</p>
</nav>
<!--
...... chapter List of Figures ......
-->
<h3 id="autosec-4">List of Figures</h3>
<a id="index-autopage-4"></a>



<nav class="lof">

<p>
<a href="Greedy.html#autoid-5" class="tocfigure" >
<span class="sectionnumber">1</span>&#x2003;Weighted, directed graph</a>
</p>


<p>
<a href="Greedy.html#autoid-7" class="tocfigure" >
<span class="sectionnumber">2</span>&#x2003;Arbitrary shortest path</a>
</p>


<p>
<a href="Greedy.html#autoid-9" class="tocfigure" >
<span class="sectionnumber">3</span>&#x2003;Minimum spanning tree</a>
</p>


<p>
<a href="Greedy.html#autoid-12" class="tocfigure" >
<span class="sectionnumber">4</span>&#x2003;The output of Huffman’s greedy algorithm</a>
</p>
</nav>

</section>

</main>

</div>

</body>
</html>
<!--|Start file|Sums.html|-->

<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Anthony" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="Personal notes on Mathematics and Computer Science" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Notes on Everything — Sums</title>
<link rel="stylesheet" type="text/css" href="lwarp.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
  subequations: "0",
  section: "",
  loader: {
    load: ['[tex]/tagformat', '[tex]/textmacros'],
  },
  startup: {
    ready() {
      // These would be replaced by import commands if you wanted to make
      // a proper extension.
      const Configuration = MathJax._.input.tex.Configuration.Configuration;
      const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
      const Macro = MathJax._.input.tex.Symbol.Macro;
      const TexError = MathJax._.input.tex.TexError.default;
      const ParseUtil = MathJax._.input.tex.ParseUtil.default;
      const expandable = MathJax._.util.Options.expandable;

       // Insert the replacement string into the TeX string, and check
       // that there haven't been too many maxro substitutions (prevents
       // infinite loops).
       const useArgument = (parser, text) => {
         parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
         parser.i = 0;
         if (++parser.macroCount > parser.configuration.options.maxMacros) {
           throw new TexError('MaxMacroSub1',
           'MathJax maximum macro substitution count exceeded; ' +
           'is there a recursive macro call?');
         }
       }

       // Create the command map for:
       //     \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
       new CommandMap('Lwarp-macros', {
         ifstar: 'IfstarFunction',
         ifnextchar: 'IfnextcharFunction',
         ifblank: 'IfblankFunction',
         ifstrequal: 'IfstrequalFunction',
         gsubstitute: 'GsubstituteFunction',
         seteqnumber: 'SeteqnumberFunction'
       }, {
         // This function implements an ifstar macro.
         IfstarFunction(parser, name) {
            const resultstar = parser.GetArgument(name);
            const resultnostar = parser.GetArgument(name);
            const star = parser.GetStar();                 // true if there is a *
            useArgument(parser, star ? resultstar : resultnostar);
         },

          // This function implements an ifnextchar macro.
          IfnextcharFunction(parser, name) {
            let whichchar = parser.GetArgument(name);
            if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
              // $ syntax highlighting
              whichchar = String.fromCodePoint(parseInt(whichchar));
            }
            const resultnextchar = parser.GetArgument(name);
            const resultnotnextchar = parser.GetArgument(name);
            const gotchar = (parser.GetNext() === whichchar);
            useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
          },

          // This function implements an ifblank macro.
          IfblankFunction(parser, name) {
            const blankarg = parser.GetArgument(name);
            const resultblank = parser.GetArgument(name);
            const resultnotblank = parser.GetArgument(name);
            const isblank = (blankarg.trim() == "");
            useArgument(parser, isblank ? resultblank : resultnotblank);
          },

          // This function implements an ifstrequal macro.
          IfstrequalFunction(parser, name) {
            const strequalfirst = parser.GetArgument(name);
            const strequalsecond = parser.GetArgument(name);
            const resultequal = parser.GetArgument(name);
            const resultnotequal = parser.GetArgument(name);
            const isequal = (strequalfirst == strequalsecond);
            useArgument(parser, isequal ? resultequal : resultnotequal);
          },

          // This function implements a gsub macro.
          GsubstituteFunction(parser, name) {
            const gsubfirst = parser.GetArgument(name);
            const gsubsecond = parser.GetArgument(name);
            const gsubthird = parser.GetArgument(name);
            let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
            useArgument(parser, gsubresult);
          },

          // This function modifies the equation numbers.
          SeteqnumberFunction(parser, name) {
              // Get the macro parameters
              const star = parser.GetStar();                  // true if there is a *
              const optBrackets = parser.GetBrackets(name);   // contents of optional brackets
              const newsubequations = parser.GetArgument(name); // the subequations argument
              const neweqsection = parser.GetArgument(name); // the eq section argument
              const neweqnumber = parser.GetArgument(name);   // the eq number argument
              MathJax.config.subequations=newsubequations ;   // a string with boolean meaning
              MathJax.config.section=neweqsection ;           // a string with numeric meaning
              parser.tags.counter = parser.tags.allCounter = neweqnumber ;
          }

       });

       // Create the Lwarp-macros package
       Configuration.create('Lwarp-macros', {
         handler: {macro: ['Lwarp-macros']}
       });

       MathJax.startup.defaultReady();

       // For forward references:
       MathJax.startup.input[0].preFilters.add(({math}) => {
         if (math.inputData.recompile){
             MathJax.config.subequations = math.inputData.recompile.subequations;
             MathJax.config.section = math.inputData.recompile.section;
         }
       });
       MathJax.startup.input[0].postFilters.add(({math}) => {
         if (math.inputData.recompile){
             math.inputData.recompile.subequations = MathJax.config.subequations;
             math.inputData.recompile.section = MathJax.config.section;
         }
       });

         // For \left, \right with unicode-math:
         const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
         const {Symbol} = MathJax._.input.tex.Symbol;
         const {MapHandler} = MathJax._.input.tex.MapHandler;
         const delimiter = MapHandler.getMap('delimiter');
         delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
         delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
         delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
         delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
         delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
         delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
         delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
         delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
         delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
         delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
         delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
         delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
         delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
         delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
         delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
         delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
         delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
         delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
         delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
         delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
         delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
         delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
         delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
         delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
         delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
         delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
         delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
         delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
         delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
         delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
         delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
         delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
         delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
         delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
         delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
         delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
         delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
         delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
         delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
   }     // ready
 },      // startup

 tex: {
   packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
   tags: "ams",
        tagformat: {
            number: function (n) {
                if(MathJax.config.subequations==0)
                    return(MathJax.config.section + n);
                else
                    return(MathJax.config.section + String.fromCharCode(96+n));
            },
        },
 }
}
</script>

<script
    id="MathJax-script"
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="index-autopage-5"></a>
<nav class="topnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Notes on Everything</span>
</p>

<p>
Subjects
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="Sums.html#autosec-6" class="tocchapter" >
Sums</a>
</p>


<p>
<a href="Sums.html#autosec-7" class="tocsection" >
Manipulating Sums</a>
</p>


<p>
<a href="Sums.html#autosec-8" class="tocsubsection" >
Basic Rules</a>
</p>


<p>
<a href="Sums.html#autosec-10" class="tocsubsection" >
Iverson Notation</a>
</p>


<p>
<a href="Sums.html#autosec-13" class="tocsubsection" >
Perturbing the Sum</a>
</p>


<p>
<a href="Sums.html#autosec-16" class="tocsubsection" >
Multiple Sums</a>
</p>


<p>
<a href="Finite-Calculus.html#autosec-24" class="tocsection" >
Finite Calculus</a>
</p>


<p>
<a href="Finite-Calculus.html#autosec-25" class="tocsubsection" >
The Difference Operator</a>
</p>


<p>
<a href="Finite-Calculus.html#autosec-26" class="tocsubsection" >
Rising and Falling Factorials</a>
</p>


<p>
<a href="Algorithms.html#autosec-30" class="tocchapter" >
Algorithms</a>
</p>


<p>
<a href="Algorithms.html#autosec-31" class="tocsection" >
Graphs</a>
</p>


<p>
<a href="Algorithms.html#autosec-32" class="tocsubsection" >
Cuts</a>
</p>


<p>
<a href="Algorithms.html#autosec-42" class="tocsubsection" >
Depth-First Search</a>
</p>


<p>
<a href="Algorithms.html#autosec-44" class="tocsubsection" >
Breadth-First Search</a>
</p>


<p>
<a href="Algorithms.html#autosec-46" class="tocsubsection" >
Topological Ordering</a>
</p>


<p>
<a href="Algorithms.html#autosec-47" class="tocsubsection" >
Strongly Connected Components</a>
</p>


<p>
<a href="Greedy.html#autosec-49" class="tocsection" >
Greedy</a>
</p>


<p>
<a href="Greedy.html#autosec-50" class="tocsubsection" >
Dijkstra’s Shortest Path Algorithm</a>
</p>


<p>
<a href="Greedy.html#autosec-61" class="tocsubsection" >
Prim’s MST Algorithm</a>
</p>


<p>
<a href="Greedy.html#autosec-70" class="tocsubsection" >
Kruskal’s MST Algorithm</a>
</p>


<p>
<a href="Greedy.html#autosec-77" class="tocsubsection" >
Huffman Codes</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-84" class="tocsection" >
Divide and Conquer</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-85" class="tocsubsection" >
Master Theorem</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-87" class="tocsubsection" >
MergeSort</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-89" class="tocsubsection" >
Counting Array Inversions</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-92" class="tocsubsection" >
Karatsuba Multiplication</a>
</p>


<p>
<a href="Combinatorics.html#autosec-94" class="tocchapter" >
Combinatorics</a>
</p>


<p>
<a href="Combinatorics.html#autosec-95" class="tocsection" >
Basics of Counting</a>
</p>


<p>
<a href="Combinatorics.html#autosec-96" class="tocsubsection" >
Product Rule</a>
</p>


<p>
<a href="Combinatorics.html#autosec-99" class="tocsubsection" >
Complement Rule</a>
</p>


<p>
<a href="Combinatorics.html#autosec-103" class="tocsubsection" >
Inclusion/Exclusion</a>
</p>


<p>
<a href="Combinatorics.html#autosec-106" class="tocsubsection" >
Permutations</a>
</p>


<p>
<a href="Probability.html#autosec-109" class="tocchapter" >
Probability</a>
</p>


<p>
<a href="Probability.html#autosec-110" class="tocsection" >
Basics</a>
</p>


<p>
<a href="Probability.html#autosec-111" class="tocsubsection" >
Terminology</a>
</p>


<p>
<a href="Probability.html#autosec-113" class="tocsubsection" >
Naive Definition of Probability</a>
</p>


<p>
<a href="Probability.html#autosec-115" class="tocsubsection" >
Non-Naive Definition of Probability</a>
</p>


<p>
<a href="Foundations.html#autosec-120" class="tocchapter" >
Foundations</a>
</p>


<p>
<a href="Foundations.html#autosec-121" class="tocsection" >
Set Theory</a>
</p>


<p>
<a href="Foundations.html#autosec-125" class="tocsubsection" >
Basic Definitions</a>
</p>


<p>
<a href="Foundations.html#autosec-126" class="tocsubsection" >
Laws</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-152" class="tocsection" >
Factoring Tricks</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-153" class="tocsubsection" >
Basic Identities</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-154" class="tocsubsection" >
Splitting Apart a Monomial</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-155" class="tocsubsection" >
Adding Zero</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-156" class="tocsubsection" >
\((a^n - b^n) \)</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-158" class="tocsubsection" >
\((a^n + b^n) \)</a>
</p>


<p>
<a href="Quadratics.html#autosec-162" class="tocsection" >
Quadratics</a>
</p>


<p>
<a href="Quadratics.html#autosec-163" class="tocsubsection" >
Finding Roots of a Quadratic Function</a>
</p>


<p>
<a href="Quadratics.html#autosec-169" class="tocsubsection" >
Vieta’s Theorem</a>
</p>


<p>
<a href="Quadratics.html#autosec-172" class="tocsubsection" >
The Quadratic Formula</a>
</p>


</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<h1>Notes on Everything</h1>

<!--MathJax customizations:-->
<div data-nosnippet
    style="display:none"
>

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

</div>

<!--
...... chapter Sums ......
-->
<h3 id="autosec-6">Sums</h3>
<a id="index-autopage-6"></a>
<a id="index-autofile-1"></a>
<!--
...... section Manipulating Sums ......
-->
<h4 id="autosec-7">Manipulating Sums</h4>
<a id="index-autopage-7"></a>


<p>
Techniques for manipulating summations can often lead to a closed form solution or simpler summation. This is especially helpful when dealing with multiple summations and loops in which the inner index depends on the outer.
</p>
<!--
...... subsection Basic Rules ......
-->
<h5 id="autosec-8">Basic Rules</h5>
<a id="index-autopage-8"></a>


<p>
Often times a complex summation can be simplified using a few simple rules:
</p>

<span class="hidden"> \(\seteqnumber{0}{}{0}\)</span>


<!--


                                                                                                                                                                               Distribution
                                                                         X              X
                                                                              cak = c         ak
                                                                        k∈K             k∈K

                                                                                                                                                                               Association
                                                                         X                    X           X
                                                                              (ak + bk ) =         ak +         bk
                                                                        k∈K                  k∈K          k∈K

                                                                                                                                                                            Commutativity
                                                                         X                     X
                                                                              (ak + bk ) =              ap(k)
                                                                        k∈K                  p(k)∈K 0



-->


<p>

\begin{align*}
&amp;\sum _{k \in K} c a_k = c \sum _{k \in K} a_k &amp;\text {Distribution} \\ &amp;\sum _{k \in K} (a_k + b_k) = \sum _{k \in K} a_k + \sum _{k \in K} b_k &amp;\text {Association} \\ &amp;\sum _{k \in K} (a_k + b_k) = \sum _{p(k) \in
K&apos;} a_{p(k)} &amp;\text {Commutativity}
\end{align*}

</p>

<p>
where \(p(k)\) is a <em>permutation</em> of the elements of \(k\) to some set with image \(p(k)\)
</p>

<p>
For example, suppose \(K = \{-1, 0, 1\}\) and \(p(k) = -k\), then \(p : K \mapsto K&apos;\) where \(K&apos; = \{1, 0, -1\}\). The end result is the terms of \(K\) are rearranged, and by <b>commutativity</b>, the summation is equal to the original ordering.
</p>
<!--
...... subsubsection Example ......
-->
<h6 id="autosec-9">Example</h6>
<a id="index-autopage-9"></a>


<p>
Using the rules above, we can simplify the following summation:
</p>

<span class="hidden"> \(\seteqnumber{0}{}{0}\)</span>


<!--


                                                                                  X
                                                                            S=           (a + bk)
                                                                                 0⩽k⩽n

                                                                                                                                                              \(a\) is constant
                                                                                               X
                                                                               = a(n + 1) +            bk
                                                                                              0⩽k⩽n

                                                                                                                                                                \(k \to n-k\)
                                                                                                   X
                                                                               = a(n + 1) +                 bn − bk
                                                                                              0⩽n−k⩽n

                                                                                                                                                                \(n-k \to k\)
                                                                                               X
                                                                               = a(n + 1) +            bn − bk
                                                                                              0⩽k⩽n




-->


<p>

\begin{align*}
\label {eq:sum_manip_example} S &amp;= \sum _{0 \leqslant k \leqslant n} (a + bk) \\ &amp;= a(n+1) + \sum _{0 \leqslant k \leqslant n} bk &amp;\text {$a$ is constant} \\ &amp;= a(n+1) + \sum _{0 \leqslant n-k \leqslant n} bn - bk
&amp;\text {$k \to n-k$} \\ &amp;= a(n+1) + \sum _{0 \leqslant k \leqslant n} bn - bk &amp;\text {$n-k \to k$} \\
\end{align*}

</p>

<p>
We employ another technique of adding \(S\) to itself and solving a simplified expression
</p>

<span class="hidden"> \(\seteqnumber{0}{}{0}\)</span>


<!--


                                                                     X                                 X
                                                             2S =         (a + bk) + a(n + 1) +               bn − bk
                                                                    0⩽k⩽n                           0⩽k⩽n

                                                                                                                                                     combining summations and simplifying
                                                                                X
                                                                  = a(n + 1)           (an + bn)
                                                                               0⩽k⩽n

                                                                  = (n + 1)(2a + bn)                                                                                \(an\), \(bn\) constant


-->


<p>

\begin{align*}
2S &amp;= \sum _{0 \leqslant k \leqslant n} (a + bk) + a(n+1) + \sum _{0 \leqslant k \leqslant n} bn - bk \\ &amp;= a(n+1) \sum _{0 \leqslant k \leqslant n} (an + bn) &amp;\text {combining summations and simplifying} \\ &amp;= (n+1)(2a +
bn) &amp;\text {$an$, $bn$ constant}
\end{align*}

</p>

<p>
Finally, dividing by 2 we get \(S = (a + \frac 1 2 bn)(n+1)\)
</p>
<!--
...... subsection Iverson Notation ......
-->
<h5 id="autosec-10">Iverson Notation</h5>
<a id="index-autopage-10"></a>


<p>
In order to make manipulation of indexes easier, we can use notation invented by Kenneth E. Iverson as an indicator function:
</p>

<span class="hidden"> \(\seteqnumber{0}{}{0}\)</span>

<!--


                                                                        1 if \(P\) is true
                                                                    (
                                                           [P ] =                                                               --><a id="eqn:iverson"></a><!--
                                                                        0 otherwise

-->

<p>

\begin{equation*}
\label {eqn:iverson} [P] = \begin{cases} 1 &amp; \text {if $P$ is true} \\ 0 &amp; \text {otherwise} \end {cases}
\end{equation*}

</p>
<!--
...... subsubsection Properties ......
-->
<h6 id="autosec-11">Properties</h6>
<a id="index-autopage-11"></a>


<p>
Iverson brackets can be manipulated in the same way as set operations:
</p>

<span class="hidden"> \(\seteqnumber{0}{}{0}\)</span>


<!--


                                                                                                                 [P ∧ Q] = [P ][Q]


                                                                                                           [P ∨ Q] = [P ] + [Q] − [P ][Q]


                                                                                                                  [¬P ] = 1 − [P ]


                                                                                                   [k ∈ A] + [k ∈ B] = [k ∈ A ∪ B] + [k ∈ A ∩ B]


                                                                                                           [k ∈ A ∩ B] = [k ∈ A][k ∈ B]


-->


<p>

\begin{gather*}
[P \land Q] = [P][Q] \\\\ [P \lor Q] = [P] + [Q] - [P][Q] \\\\ [\lnot P] = 1 - [P] \\\\ [k \in A] + [k \in B] = [k \in A \cup B] + [k \in A \cap B] \\\\ [k \in A \cap B] = [k \in A][k \in B]
\end{gather*}

</p>
<!--
...... subsubsection Example ......
-->
<h6 id="autosec-12">Example</h6>
<a id="index-autopage-12"></a>


<p>
Using Iverson brackets, the ”double-counting” summation identity can be derived directly from the above properties.
</p>

<span class="hidden"> \(\seteqnumber{0}{}{0}\)</span>

<!--


                                                                                                             [k ∈ K] + [k ∈ K 0 ] = [k ∈ K ∩ K 0 ] + [k ∈ K ∪ K 0 ]

-->

<p>

\begin{equation*}
[k \in K] + [k \in K&apos;] = [k \in K \cap K&apos;] + [k \in K \cup K&apos;]
\end{equation*}

</p>

<p>
which translates to summations with indices:
</p>

<span class="hidden"> \(\seteqnumber{0}{}{0}\)</span>

<!--

                                                                                                                X            X               X                X
                                                                                                                      ak +           ak =             ak +             ak
                                                                                                                k∈K          k∈K 0          k∈k∩K 0          k∈k∪K 0

-->

<p>

\begin{equation*}
\sum _{k \in K} a_k + \sum _{k \in K&apos;} a_k = \sum _{k \in k \cap K&apos;} a_k + \sum _{k \in k \cup K&apos;} a_k
\end{equation*}

</p>
<!--
...... subsection Perturbing the Sum ......
-->
<h5 id="autosec-13">Perturbing the Sum</h5>
<a id="index-autopage-13"></a>


<p>
Another technique is to manipulate the first and last terms. This reveal a way to solve the summation via the above manipulations.
</p>
<!--
...... subsubsection Example ......
-->
<h6 id="autosec-14">Example</h6>
<a id="index-autopage-14"></a>


<p>
For example, take the following summation representing a geometric series. A good approach is to write \(S_{n+1}\) in terms of \(S_n\) and simplify the right side of the equation.
</p>

<p>
Consider the following summation:
</p>

<p>
\[ S_n = \sum _{0 \leqslant k \leqslant n} ax^k \]
</p>

<p>
Adding the \(n+1\)st term and solving for \(S_n\):
</p>

<span class="hidden"> \(\seteqnumber{0}{}{0}\)</span>


<!--


                                                                                                                                X
                                                                                                           Sn + axn+1 = a +             axk
                                                                                                                              1⩽k⩽n+1
                                                                                                                                                    X
                                                                                                                        ⇐⇒ Sn + axn+1 = a +                 axk+1
                                                                                                                                                1⩽k+1⩽n+1
                                                                                                                                                  X
                                                                                                                        ⇐⇒ Sn + axn+1 = a +             axk+1
                                                                                                                                                0⩽k⩽n

                                                                                                                        ⇐⇒ Sn + axn+1 = a + xSn
                                                                                                                                   a − axn+1
                                                                                                                        ⇐⇒ Sn =
                                                                                                                                     1−x


-->


<p>

\begin{align*}
S_n + ax^{n+1} &amp;= a + \sum _{1 \leqslant k \leqslant n+1} ax^k \\ &amp;\iff S_n + ax^{n+1} = a + \sum _{1 \leqslant k+1 \leqslant n+1} ax^{k+1} \\ &amp;\iff S_n + ax^{n+1} = a + \sum _{0 \leqslant k \leqslant n} ax^{k+1} \\ &amp;\iff
S_n + ax^{n+1} = a + xS_n \\ &amp;\iff S_n = \frac {a - ax^{n+1}} {1 - x}
\end{align*}

</p>
<!--
...... subsubsection Example ......
-->
<h6 id="autosec-15">Example</h6>
<a id="index-autopage-15"></a>


<p>
Taking another example and using the results from the previous derivation, the following sum is solved almost in the exact same way:
</p>

<p>
\[ S_n = \sum _{0 \leqslant k \leqslant n} k2^k \]
</p>

<p>
Once again perturbing the sum:
</p>

<span class="hidden"> \(\seteqnumber{0}{}{0}\)</span>


<!--


                                                                                                                                       X
                                                                                                         Sn + (n + 1)2n+1 = 0 +                k2k+1
                                                                                                                                  1⩽k⩽n+1


                                                                                                                                  X                       X
                                                                                                                           =                k2k+1 +                2k+1
                                                                                                                               1⩽k+1⩽n+1               1⩽k+1⩽n+1


                                                                                                                                        X
                                                                                                                           = 2Sn +             2k+1
                                                                                                                                       0⩽k⩽n



-->


<p>

\begin{align*}
S_n + (n+1)2^{n+1} &amp;= 0 + \sum _{1 \leqslant k \leqslant n+1} k2^{k+1} \\\\ &amp;= \sum _{1 \leqslant k+1 \leqslant n+1} k2^{k+1} + \sum _{1 \leqslant k+1 \leqslant n+1} 2^{k+1} \\\\ &amp;= 2S_n + \sum _{0 \leqslant k \leqslant n}
2^{k+1}
\end{align*}

</p>

<p>
The second sum is a geometric series, and so after evaluating and simplifying:
</p>

<p>
\[ S_n = \frac {2 - 2^{n+2}} {1 - 2} - (n+1)2^{n+1} = (n-1)2^{n+1} + 2 \]
</p>
<!--
...... subsection Multiple Sums ......
-->
<h5 id="autosec-16">Multiple Sums</h5>
<a id="index-autopage-16"></a>


<p>
When a summation is indexed by two or more indices, it can be written with more than one sigma:
</p>

<p>
\[ \sum _{1 \leqslant j, k \leqslant n} a_j b_k = \sum _{1 \leqslant j \leqslant n} \sum _{1 \leqslant k \leqslant n} b_k \]
</p>

<p>
Summations of this form are evaulated ”right-to-left” or by taking the ”inner” summtation first. In the above example, the summation over \(k\) happens first.
</p>
<!--
...... subsubsection Interchanging Indices ......
-->
<h6 id="autosec-17">Interchanging Indices</h6>
<a id="index-autopage-17"></a>


<p>
When indices are independent, this is simply a matter of rearranging the sums. Complications arise when the inner index depends on the outer. The abstract way of denoting an exchange of indicies:
</p>

<p>
\[ \sum _j \sum _k a_{j,k} [P(j, k)] = \sum _{P(j,k)} a_{j,k} [P(j,k)] = \sum _k \sum _j a_{j,k} [P(j,k)] \]
</p>

<p>
is a generalization of the associativity rule.
</p>
<!--
...... subsubsection Example ......
-->
<h6 id="autosec-18">Example</h6>
<a id="index-autopage-18"></a>


<p>
This example shows how multiple summations can be split apart by applying the associative rule and using Iverson notation.
</p>

<p>
Since the indices are independent, the summations can occur in either order.
</p>

<span class="hidden"> \(\seteqnumber{0}{}{0}\)</span>


<!--


                                                                                                              X                 X
                                                                                                                      aj bk =         aj bk [1 ⩽ j ⩽ 3][1 ⩽ k ⩽ 3]
                                                                                                            1⩽j,k⩽3             j,k
                                                                                                                                X                      X
                                                                                                                           =          aj [1 ⩽ j ⩽ 3]       bk [1 ⩽ k ⩽ 3]
                                                                                                                                 j                     k
                                                                                                                                3
                                                                                                                                X          3
                                                                                                                                           X
                                                                                                                           =          aj         bk
                                                                                                                                j=1        k=1



-->


<p>

\begin{align*}
\sum _{1 \leqslant j,k \leqslant 3} a_j b_k &amp;= \sum _{j,k} a_j b_k [1 \leqslant j \leqslant 3][1 \leqslant k \leqslant 3] \\ &amp;= \sum _j a_j [1 \leqslant j \leqslant 3] \sum _k b_k [1 \leqslant k \leqslant 3] \\ &amp;= \sum
_{j=1}^3 a_j \sum _{k=1}^3 b_k
\end{align*}

</p>
<!--
...... subsubsection Harder Example ......
-->
<h6 id="autosec-19">Harder Example</h6>
<a id="index-autopage-19"></a>


<p>
In this example, \(j\) is related to the value of \(k\). Again, the problem can be reduced into manipulating the inequalities using Iverson notation. Using the following identity written in Iverson brackets:
</p>

<p>
\[ [1 \leqslant j \leqslant n][j \leqslant k \leqslant n] = [1 \leqslant j,k \leqslant n] = [1 \leqslant k \leqslant n][1 \leqslant j \leqslant k] \]
</p>
<div class="center">

<p>
<span
    id="lateximage-index-1"
    class="lateximagesource"
><!--
1   j   k   n
--><img
    src="index-images/image-1.svg"
    alt="(-tikz-&nbsp;diagram)"
    style=""
    class="lateximage"
></span>
</p>
</div>

<p>
This holds by combining the first two brackets by writing their intersection as one inequality and by splitting it apart again.
</p>

<p>
An equivalent double summation can be manipulated using the above identity:
</p>

<span class="hidden"> \(\seteqnumber{0}{}{0}\)</span>


<!--


                                                                                                                         X        X              X
                                                                                                                                      aj,k =             aj,k
                                                                                                                        1⩽j⩽n j⩽k⩽n            1⩽j,k⩽n


                                                                                                                                                X        X
                                                                                                                                          =                     aj,k
                                                                                                                                               1⩽k⩽n 1⩽j⩽k



                                                                                                                                               n X
                                                                                                                                               X k
                                                                                                                                          =              aj,k
                                                                                                                                               k=1 j=1



-->


<p>

\begin{align*}
\sum _{1 \leqslant j \leqslant n} \sum _{j \leqslant k \leqslant n} a_{j,k} &amp;= \sum _{1 \leqslant j,k \leqslant n} a_{j,k} \\\\ &amp;= \sum _{1 \leqslant k \leqslant n} \sum _{1 \leqslant j \leqslant k} a_{j,k} \\\\ &amp;= \sum
_{k=1}^n \sum _{j=1}^k a_{j,k}
\end{align*}

</p>

<p>
Hopefully, the second summation turns out to be easier to evaluate.
</p>

</section>

</main>

</div>

<footer>

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

</footer>


<nav class="botnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|Finite-Calculus.html|-->

<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Anthony" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="Personal notes on Mathematics and Computer Science" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Notes on Everything — Finite Calculus</title>
<link rel="stylesheet" type="text/css" href="lwarp.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
  subequations: "0",
  section: "",
  loader: {
    load: ['[tex]/tagformat', '[tex]/textmacros'],
  },
  startup: {
    ready() {
      // These would be replaced by import commands if you wanted to make
      // a proper extension.
      const Configuration = MathJax._.input.tex.Configuration.Configuration;
      const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
      const Macro = MathJax._.input.tex.Symbol.Macro;
      const TexError = MathJax._.input.tex.TexError.default;
      const ParseUtil = MathJax._.input.tex.ParseUtil.default;
      const expandable = MathJax._.util.Options.expandable;

       // Insert the replacement string into the TeX string, and check
       // that there haven't been too many maxro substitutions (prevents
       // infinite loops).
       const useArgument = (parser, text) => {
         parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
         parser.i = 0;
         if (++parser.macroCount > parser.configuration.options.maxMacros) {
           throw new TexError('MaxMacroSub1',
           'MathJax maximum macro substitution count exceeded; ' +
           'is there a recursive macro call?');
         }
       }

       // Create the command map for:
       //     \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
       new CommandMap('Lwarp-macros', {
         ifstar: 'IfstarFunction',
         ifnextchar: 'IfnextcharFunction',
         ifblank: 'IfblankFunction',
         ifstrequal: 'IfstrequalFunction',
         gsubstitute: 'GsubstituteFunction',
         seteqnumber: 'SeteqnumberFunction'
       }, {
         // This function implements an ifstar macro.
         IfstarFunction(parser, name) {
            const resultstar = parser.GetArgument(name);
            const resultnostar = parser.GetArgument(name);
            const star = parser.GetStar();                 // true if there is a *
            useArgument(parser, star ? resultstar : resultnostar);
         },

          // This function implements an ifnextchar macro.
          IfnextcharFunction(parser, name) {
            let whichchar = parser.GetArgument(name);
            if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
              // $ syntax highlighting
              whichchar = String.fromCodePoint(parseInt(whichchar));
            }
            const resultnextchar = parser.GetArgument(name);
            const resultnotnextchar = parser.GetArgument(name);
            const gotchar = (parser.GetNext() === whichchar);
            useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
          },

          // This function implements an ifblank macro.
          IfblankFunction(parser, name) {
            const blankarg = parser.GetArgument(name);
            const resultblank = parser.GetArgument(name);
            const resultnotblank = parser.GetArgument(name);
            const isblank = (blankarg.trim() == "");
            useArgument(parser, isblank ? resultblank : resultnotblank);
          },

          // This function implements an ifstrequal macro.
          IfstrequalFunction(parser, name) {
            const strequalfirst = parser.GetArgument(name);
            const strequalsecond = parser.GetArgument(name);
            const resultequal = parser.GetArgument(name);
            const resultnotequal = parser.GetArgument(name);
            const isequal = (strequalfirst == strequalsecond);
            useArgument(parser, isequal ? resultequal : resultnotequal);
          },

          // This function implements a gsub macro.
          GsubstituteFunction(parser, name) {
            const gsubfirst = parser.GetArgument(name);
            const gsubsecond = parser.GetArgument(name);
            const gsubthird = parser.GetArgument(name);
            let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
            useArgument(parser, gsubresult);
          },

          // This function modifies the equation numbers.
          SeteqnumberFunction(parser, name) {
              // Get the macro parameters
              const star = parser.GetStar();                  // true if there is a *
              const optBrackets = parser.GetBrackets(name);   // contents of optional brackets
              const newsubequations = parser.GetArgument(name); // the subequations argument
              const neweqsection = parser.GetArgument(name); // the eq section argument
              const neweqnumber = parser.GetArgument(name);   // the eq number argument
              MathJax.config.subequations=newsubequations ;   // a string with boolean meaning
              MathJax.config.section=neweqsection ;           // a string with numeric meaning
              parser.tags.counter = parser.tags.allCounter = neweqnumber ;
          }

       });

       // Create the Lwarp-macros package
       Configuration.create('Lwarp-macros', {
         handler: {macro: ['Lwarp-macros']}
       });

       MathJax.startup.defaultReady();

       // For forward references:
       MathJax.startup.input[0].preFilters.add(({math}) => {
         if (math.inputData.recompile){
             MathJax.config.subequations = math.inputData.recompile.subequations;
             MathJax.config.section = math.inputData.recompile.section;
         }
       });
       MathJax.startup.input[0].postFilters.add(({math}) => {
         if (math.inputData.recompile){
             math.inputData.recompile.subequations = MathJax.config.subequations;
             math.inputData.recompile.section = MathJax.config.section;
         }
       });

         // For \left, \right with unicode-math:
         const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
         const {Symbol} = MathJax._.input.tex.Symbol;
         const {MapHandler} = MathJax._.input.tex.MapHandler;
         const delimiter = MapHandler.getMap('delimiter');
         delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
         delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
         delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
         delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
         delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
         delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
         delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
         delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
         delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
         delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
         delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
         delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
         delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
         delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
         delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
         delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
         delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
         delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
         delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
         delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
         delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
         delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
         delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
         delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
         delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
         delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
         delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
         delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
         delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
         delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
         delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
         delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
         delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
         delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
         delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
         delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
         delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
         delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
         delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
   }     // ready
 },      // startup

 tex: {
   packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
   tags: "ams",
        tagformat: {
            number: function (n) {
                if(MathJax.config.subequations==0)
                    return(MathJax.config.section + n);
                else
                    return(MathJax.config.section + String.fromCharCode(96+n));
            },
        },
 }
}
</script>

<script
    id="MathJax-script"
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="index-autopage-23"></a>
<nav class="topnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Notes on Everything</span>
</p>

<p>
Subjects
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="Sums.html#autosec-6" class="tocchapter" >
Sums</a>
</p>


<p>
<a href="Sums.html#autosec-7" class="tocsection" >
Manipulating Sums</a>
</p>


<p>
<a href="Sums.html#autosec-8" class="tocsubsection" >
Basic Rules</a>
</p>


<p>
<a href="Sums.html#autosec-10" class="tocsubsection" >
Iverson Notation</a>
</p>


<p>
<a href="Sums.html#autosec-13" class="tocsubsection" >
Perturbing the Sum</a>
</p>


<p>
<a href="Sums.html#autosec-16" class="tocsubsection" >
Multiple Sums</a>
</p>


<p>
<a href="Finite-Calculus.html#autosec-24" class="tocsection" >
Finite Calculus</a>
</p>


<p>
<a href="Finite-Calculus.html#autosec-25" class="tocsubsection" >
The Difference Operator</a>
</p>


<p>
<a href="Finite-Calculus.html#autosec-26" class="tocsubsection" >
Rising and Falling Factorials</a>
</p>


<p>
<a href="Algorithms.html#autosec-30" class="tocchapter" >
Algorithms</a>
</p>


<p>
<a href="Algorithms.html#autosec-31" class="tocsection" >
Graphs</a>
</p>


<p>
<a href="Algorithms.html#autosec-32" class="tocsubsection" >
Cuts</a>
</p>


<p>
<a href="Algorithms.html#autosec-42" class="tocsubsection" >
Depth-First Search</a>
</p>


<p>
<a href="Algorithms.html#autosec-44" class="tocsubsection" >
Breadth-First Search</a>
</p>


<p>
<a href="Algorithms.html#autosec-46" class="tocsubsection" >
Topological Ordering</a>
</p>


<p>
<a href="Algorithms.html#autosec-47" class="tocsubsection" >
Strongly Connected Components</a>
</p>


<p>
<a href="Greedy.html#autosec-49" class="tocsection" >
Greedy</a>
</p>


<p>
<a href="Greedy.html#autosec-50" class="tocsubsection" >
Dijkstra’s Shortest Path Algorithm</a>
</p>


<p>
<a href="Greedy.html#autosec-61" class="tocsubsection" >
Prim’s MST Algorithm</a>
</p>


<p>
<a href="Greedy.html#autosec-70" class="tocsubsection" >
Kruskal’s MST Algorithm</a>
</p>


<p>
<a href="Greedy.html#autosec-77" class="tocsubsection" >
Huffman Codes</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-84" class="tocsection" >
Divide and Conquer</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-85" class="tocsubsection" >
Master Theorem</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-87" class="tocsubsection" >
MergeSort</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-89" class="tocsubsection" >
Counting Array Inversions</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-92" class="tocsubsection" >
Karatsuba Multiplication</a>
</p>


<p>
<a href="Combinatorics.html#autosec-94" class="tocchapter" >
Combinatorics</a>
</p>


<p>
<a href="Combinatorics.html#autosec-95" class="tocsection" >
Basics of Counting</a>
</p>


<p>
<a href="Combinatorics.html#autosec-96" class="tocsubsection" >
Product Rule</a>
</p>


<p>
<a href="Combinatorics.html#autosec-99" class="tocsubsection" >
Complement Rule</a>
</p>


<p>
<a href="Combinatorics.html#autosec-103" class="tocsubsection" >
Inclusion/Exclusion</a>
</p>


<p>
<a href="Combinatorics.html#autosec-106" class="tocsubsection" >
Permutations</a>
</p>


<p>
<a href="Probability.html#autosec-109" class="tocchapter" >
Probability</a>
</p>


<p>
<a href="Probability.html#autosec-110" class="tocsection" >
Basics</a>
</p>


<p>
<a href="Probability.html#autosec-111" class="tocsubsection" >
Terminology</a>
</p>


<p>
<a href="Probability.html#autosec-113" class="tocsubsection" >
Naive Definition of Probability</a>
</p>


<p>
<a href="Probability.html#autosec-115" class="tocsubsection" >
Non-Naive Definition of Probability</a>
</p>


<p>
<a href="Foundations.html#autosec-120" class="tocchapter" >
Foundations</a>
</p>


<p>
<a href="Foundations.html#autosec-121" class="tocsection" >
Set Theory</a>
</p>


<p>
<a href="Foundations.html#autosec-125" class="tocsubsection" >
Basic Definitions</a>
</p>


<p>
<a href="Foundations.html#autosec-126" class="tocsubsection" >
Laws</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-152" class="tocsection" >
Factoring Tricks</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-153" class="tocsubsection" >
Basic Identities</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-154" class="tocsubsection" >
Splitting Apart a Monomial</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-155" class="tocsubsection" >
Adding Zero</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-156" class="tocsubsection" >
\((a^n - b^n) \)</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-158" class="tocsubsection" >
\((a^n + b^n) \)</a>
</p>


<p>
<a href="Quadratics.html#autosec-162" class="tocsection" >
Quadratics</a>
</p>


<p>
<a href="Quadratics.html#autosec-163" class="tocsubsection" >
Finding Roots of a Quadratic Function</a>
</p>


<p>
<a href="Quadratics.html#autosec-169" class="tocsubsection" >
Vieta’s Theorem</a>
</p>


<p>
<a href="Quadratics.html#autosec-172" class="tocsubsection" >
The Quadratic Formula</a>
</p>


</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<h1>Notes on Everything</h1>

<!--MathJax customizations:-->
<div data-nosnippet
    style="display:none"
>

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

</div>

<!--
...... section Finite Calculus ......
-->
<h4 id="autosec-24">Finite Calculus</h4>
<a id="index-autopage-24"></a>
<a id="index-autofile-2"></a>

<p>
Finite Calculus establishes analogs between the techniques of infinite Calculus (Analysis etc.) in order to develop sophisticated ways of dealing with sums. Specifically, we’re after methods that remind us of dealing with integrals and derivatives since there are nice formulas
and tricks for handling those most of the time.
</p>

<p>
Another important theme of Finite Calculus is discovering functions that act as discrete versions of their continuous counterparts. If we can find a finite analog of a function, we’ll have an easier time reasoning about a closed form solution.
</p>
<!--
...... subsection The Difference Operator ......
-->
<h5 id="autosec-25">The Difference Operator</h5>
<a id="index-autopage-25"></a>


<p>
One of the first facts established in Calculus is the limit definition of the derivative of a function:
</p>

<p>
\[ \frac d {dx} f(x) = \lim _{h \to 0} \frac {f(x + h) - f(x)} h \]
</p>

<p>
The righthand side is the limit of the <b>difference quotient</b> of \(f(x)\) as \(h\) approaches 0. In the finite world, there is a similar operation:
</p>

<span class="hidden"> \(\seteqnumber{0}{}{0}\)</span>

<!--


                                                                                                                            ∆f (x) = f (x + 1) − f (x)

-->

<p>

\begin{equation*}
\Delta f(x) = f(x + 1) - f(x)
\end{equation*}

</p>

<p>
This is known as the <b>difference operator</b>. Since we’re dealing with a discrete function and not a continous one, we have to restrict \(h\) to being an integer. The closest integer \(h\) can be without being 0 is 1. This gives a nice tie-in to the limit definition.
</p>

<p>
Crucially, \(\Delta f(x)\) is called an <em>operator</em>, because it operates on \(f(x)\) and produces another function, similar to differentiation. Introducing this operator allows for the development of more sophisticated tools a little later.
</p>
<!--
...... subsection Rising and Falling Factorials ......
-->
<h5 id="autosec-26">Rising and Falling Factorials</h5>
<a id="index-autopage-26"></a>


<p>
Unfortunately, the convenient power rule of differential Calculus:
</p>

<p>
\[ \frac d {dx} x^m = mx^{m-1} \]
</p>

<p>
fails miserably in the finite world:
</p>

<p>
\[ \Delta (x^3) = (x + 1)^3 - x^3 = 3x^2 + 3x + 1 \neq 3x^2 \]
</p>

<p>
At least for polynomials. There are, however, interesting functions for which the difference operator is a near-perfect match-up to differentiation, although this fact is not obvious right away. Some definitions first:
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><a id="index-autopage-27"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">1</span></span>. </span> Falling Factorial
</p>

<p>
Let \(m\) be an integer and \(x\) be any real number. Define the falling factorial of \(x\) as:
</p>

<p>
\[ x^{\underline {m}} = x(x-1)(x-2)\dots (x-m+1) \]
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><a id="index-autopage-28"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">2</span></span>. </span> Rising Factorial
</p>

<p>
Let \(m\) be an integer and \(x\) be any real number. Define the rising factorial of \(x\) as:
</p>

<p>
\[ x^{\overline {m}} = x(x+1)(x+2)\dots (x+m-1) \]
</p>

<p>


</p>

</li>

</ul>

</div>

<p>
\(m\) denotes the number of terms in the factorial product, and the line above or below \(m\) determines whether the terms are increasing or decreasing. There’s a hint here that the difference operator might be important. Taking a peek at the first two consecutive terms
in the product, they have the form:
</p>

<p>
\[ (x)(x+1) \; \text {or} \; x(x-1) \]
</p>

<p>
It’s still too early to tell what’s going on, but this deserves some suspicion.
</p>

<p>
This strange notation takes some getting used to, but is ultimately a very neat way of compressing a lot of information into notation that can be manipulated.
</p>

<p>
Here’s an explanation for why there are \(m\) terms:
</p>

<span class="hidden"> \(\seteqnumber{0}{}{0}\)</span>


<!--


                                                                                                                     xm = x(x − 1)(x − 2) . . . (x − m + 1)
                                                                                                                          |             {z                }
                                                                                                                                x−(x−m+1)+1=m terms



-->


<p>

\begin{align*}
x^{\underline {m}} = \underbrace {x(x-1)(x-2)\dots (x-m+1)}_{x - (x - m + 1) + 1 = m \; \text {terms}}
\end{align*}

</p>

<span class="hidden"> \(\seteqnumber{0}{}{0}\)</span>


<!--


                                                                                                                     xm = x(x + 1)(x + 2) . . . (x + m − 1)
                                                                                                                          |             {z                }
                                                                                                                                (x+m−1)−x+1=m terms



-->


<p>

\begin{align*}
x^{\overline {m}} = \underbrace {x(x+1)(x+2)\dots (x+m-1)}_{(x + m - 1) - x + 1 = m \; \text {terms}}
\end{align*}

</p>

<p>
This comes from counting how many integers there are in a given range. As an example, there are \((5 - 2) + 1 = 4\) integers between 2 and 5.
</p>

<p>
Here’s a visual aid as a quick refresher:
</p>

<p>
But what does this have to do with the difference operator? The answer may lie in blindly applying the operator and seeing what happens. Nothing ventured!
</p>

<span class="hidden"> \(\seteqnumber{0}{}{0}\)</span>


<!--


                                                                                            ∆(xm ) = (x + 1)m − xm


                                                                                                   = (x + 1)(x)(x − 1) . . . (x − m + 2) − x(x − 1)(x − 2) . . . (x − m + 2)(x − m + 1)


                                                                                                   = x(x − 1)(x − 2) . . . (x − m + 2)(x + 1 − (x − m + 1))


                                                                                                   = m[x(x − 1)(x − 2) . . . (x − m + 2)]


-->


<p>

\begin{align*}
\Delta (x^{\underline {m}}) &amp;= (x + 1)^{\underline {m}} - x^{\underline {m}} \\ \\ &amp;= (x+1)(x)(x-1)\dots (x-m+2) - x(x-1)(x-2)\dots (x-m+2)(x-m+1) \\ \\ &amp;= x(x-1)(x-2)\dots (x-m+2)(x + 1 - (x - m + 1)) \\ \\ &amp;=
m[x(x-1)(x-2)\dots (x-m+2)]
\end{align*}

</p>

<p>
Some clever factoring got us an \(m\) times something vaguely familiar. Let’s try counting how many terms there are:
</p>

<p>
\[ x - (x - m + 2) + 1 = m - 1 \; \text {terms} \]
</p>

<p>
This rings a bell! We have a product of \(m - 1\) decreasing terms. Don’t we have a way of cramming that into a compact expression? Putting it all together:
</p>

<p>
\[ \Delta (x^{\underline {m}}) = mx^{\underline {m-1}} \]
</p>

<p>
which bears a striking similarity to the power rule.
</p>

</section>

</main>

</div>

<footer>

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

</footer>


<nav class="botnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|Algorithms.html|-->

<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Anthony" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="Personal notes on Mathematics and Computer Science" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Notes on Everything — Algorithms</title>
<link rel="stylesheet" type="text/css" href="lwarp.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
  subequations: "0",
  section: "",
  loader: {
    load: ['[tex]/tagformat', '[tex]/textmacros'],
  },
  startup: {
    ready() {
      // These would be replaced by import commands if you wanted to make
      // a proper extension.
      const Configuration = MathJax._.input.tex.Configuration.Configuration;
      const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
      const Macro = MathJax._.input.tex.Symbol.Macro;
      const TexError = MathJax._.input.tex.TexError.default;
      const ParseUtil = MathJax._.input.tex.ParseUtil.default;
      const expandable = MathJax._.util.Options.expandable;

       // Insert the replacement string into the TeX string, and check
       // that there haven't been too many maxro substitutions (prevents
       // infinite loops).
       const useArgument = (parser, text) => {
         parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
         parser.i = 0;
         if (++parser.macroCount > parser.configuration.options.maxMacros) {
           throw new TexError('MaxMacroSub1',
           'MathJax maximum macro substitution count exceeded; ' +
           'is there a recursive macro call?');
         }
       }

       // Create the command map for:
       //     \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
       new CommandMap('Lwarp-macros', {
         ifstar: 'IfstarFunction',
         ifnextchar: 'IfnextcharFunction',
         ifblank: 'IfblankFunction',
         ifstrequal: 'IfstrequalFunction',
         gsubstitute: 'GsubstituteFunction',
         seteqnumber: 'SeteqnumberFunction'
       }, {
         // This function implements an ifstar macro.
         IfstarFunction(parser, name) {
            const resultstar = parser.GetArgument(name);
            const resultnostar = parser.GetArgument(name);
            const star = parser.GetStar();                 // true if there is a *
            useArgument(parser, star ? resultstar : resultnostar);
         },

          // This function implements an ifnextchar macro.
          IfnextcharFunction(parser, name) {
            let whichchar = parser.GetArgument(name);
            if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
              // $ syntax highlighting
              whichchar = String.fromCodePoint(parseInt(whichchar));
            }
            const resultnextchar = parser.GetArgument(name);
            const resultnotnextchar = parser.GetArgument(name);
            const gotchar = (parser.GetNext() === whichchar);
            useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
          },

          // This function implements an ifblank macro.
          IfblankFunction(parser, name) {
            const blankarg = parser.GetArgument(name);
            const resultblank = parser.GetArgument(name);
            const resultnotblank = parser.GetArgument(name);
            const isblank = (blankarg.trim() == "");
            useArgument(parser, isblank ? resultblank : resultnotblank);
          },

          // This function implements an ifstrequal macro.
          IfstrequalFunction(parser, name) {
            const strequalfirst = parser.GetArgument(name);
            const strequalsecond = parser.GetArgument(name);
            const resultequal = parser.GetArgument(name);
            const resultnotequal = parser.GetArgument(name);
            const isequal = (strequalfirst == strequalsecond);
            useArgument(parser, isequal ? resultequal : resultnotequal);
          },

          // This function implements a gsub macro.
          GsubstituteFunction(parser, name) {
            const gsubfirst = parser.GetArgument(name);
            const gsubsecond = parser.GetArgument(name);
            const gsubthird = parser.GetArgument(name);
            let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
            useArgument(parser, gsubresult);
          },

          // This function modifies the equation numbers.
          SeteqnumberFunction(parser, name) {
              // Get the macro parameters
              const star = parser.GetStar();                  // true if there is a *
              const optBrackets = parser.GetBrackets(name);   // contents of optional brackets
              const newsubequations = parser.GetArgument(name); // the subequations argument
              const neweqsection = parser.GetArgument(name); // the eq section argument
              const neweqnumber = parser.GetArgument(name);   // the eq number argument
              MathJax.config.subequations=newsubequations ;   // a string with boolean meaning
              MathJax.config.section=neweqsection ;           // a string with numeric meaning
              parser.tags.counter = parser.tags.allCounter = neweqnumber ;
          }

       });

       // Create the Lwarp-macros package
       Configuration.create('Lwarp-macros', {
         handler: {macro: ['Lwarp-macros']}
       });

       MathJax.startup.defaultReady();

       // For forward references:
       MathJax.startup.input[0].preFilters.add(({math}) => {
         if (math.inputData.recompile){
             MathJax.config.subequations = math.inputData.recompile.subequations;
             MathJax.config.section = math.inputData.recompile.section;
         }
       });
       MathJax.startup.input[0].postFilters.add(({math}) => {
         if (math.inputData.recompile){
             math.inputData.recompile.subequations = MathJax.config.subequations;
             math.inputData.recompile.section = MathJax.config.section;
         }
       });

         // For \left, \right with unicode-math:
         const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
         const {Symbol} = MathJax._.input.tex.Symbol;
         const {MapHandler} = MathJax._.input.tex.MapHandler;
         const delimiter = MapHandler.getMap('delimiter');
         delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
         delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
         delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
         delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
         delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
         delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
         delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
         delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
         delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
         delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
         delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
         delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
         delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
         delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
         delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
         delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
         delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
         delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
         delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
         delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
         delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
         delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
         delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
         delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
         delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
         delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
         delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
         delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
         delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
         delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
         delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
         delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
         delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
         delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
         delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
         delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
         delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
         delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
         delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
   }     // ready
 },      // startup

 tex: {
   packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
   tags: "ams",
        tagformat: {
            number: function (n) {
                if(MathJax.config.subequations==0)
                    return(MathJax.config.section + n);
                else
                    return(MathJax.config.section + String.fromCharCode(96+n));
            },
        },
 }
}
</script>

<script
    id="MathJax-script"
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="index-autopage-29"></a>
<nav class="topnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Notes on Everything</span>
</p>

<p>
Subjects
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="Sums.html#autosec-6" class="tocchapter" >
Sums</a>
</p>


<p>
<a href="Sums.html#autosec-7" class="tocsection" >
Manipulating Sums</a>
</p>


<p>
<a href="Sums.html#autosec-8" class="tocsubsection" >
Basic Rules</a>
</p>


<p>
<a href="Sums.html#autosec-10" class="tocsubsection" >
Iverson Notation</a>
</p>


<p>
<a href="Sums.html#autosec-13" class="tocsubsection" >
Perturbing the Sum</a>
</p>


<p>
<a href="Sums.html#autosec-16" class="tocsubsection" >
Multiple Sums</a>
</p>


<p>
<a href="Finite-Calculus.html#autosec-24" class="tocsection" >
Finite Calculus</a>
</p>


<p>
<a href="Finite-Calculus.html#autosec-25" class="tocsubsection" >
The Difference Operator</a>
</p>


<p>
<a href="Finite-Calculus.html#autosec-26" class="tocsubsection" >
Rising and Falling Factorials</a>
</p>


<p>
<a href="Algorithms.html#autosec-30" class="tocchapter" >
Algorithms</a>
</p>


<p>
<a href="Algorithms.html#autosec-31" class="tocsection" >
Graphs</a>
</p>


<p>
<a href="Algorithms.html#autosec-32" class="tocsubsection" >
Cuts</a>
</p>


<p>
<a href="Algorithms.html#autosec-42" class="tocsubsection" >
Depth-First Search</a>
</p>


<p>
<a href="Algorithms.html#autosec-44" class="tocsubsection" >
Breadth-First Search</a>
</p>


<p>
<a href="Algorithms.html#autosec-46" class="tocsubsection" >
Topological Ordering</a>
</p>


<p>
<a href="Algorithms.html#autosec-47" class="tocsubsection" >
Strongly Connected Components</a>
</p>


<p>
<a href="Greedy.html#autosec-49" class="tocsection" >
Greedy</a>
</p>


<p>
<a href="Greedy.html#autosec-50" class="tocsubsection" >
Dijkstra’s Shortest Path Algorithm</a>
</p>


<p>
<a href="Greedy.html#autosec-61" class="tocsubsection" >
Prim’s MST Algorithm</a>
</p>


<p>
<a href="Greedy.html#autosec-70" class="tocsubsection" >
Kruskal’s MST Algorithm</a>
</p>


<p>
<a href="Greedy.html#autosec-77" class="tocsubsection" >
Huffman Codes</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-84" class="tocsection" >
Divide and Conquer</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-85" class="tocsubsection" >
Master Theorem</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-87" class="tocsubsection" >
MergeSort</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-89" class="tocsubsection" >
Counting Array Inversions</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-92" class="tocsubsection" >
Karatsuba Multiplication</a>
</p>


<p>
<a href="Combinatorics.html#autosec-94" class="tocchapter" >
Combinatorics</a>
</p>


<p>
<a href="Combinatorics.html#autosec-95" class="tocsection" >
Basics of Counting</a>
</p>


<p>
<a href="Combinatorics.html#autosec-96" class="tocsubsection" >
Product Rule</a>
</p>


<p>
<a href="Combinatorics.html#autosec-99" class="tocsubsection" >
Complement Rule</a>
</p>


<p>
<a href="Combinatorics.html#autosec-103" class="tocsubsection" >
Inclusion/Exclusion</a>
</p>


<p>
<a href="Combinatorics.html#autosec-106" class="tocsubsection" >
Permutations</a>
</p>


<p>
<a href="Probability.html#autosec-109" class="tocchapter" >
Probability</a>
</p>


<p>
<a href="Probability.html#autosec-110" class="tocsection" >
Basics</a>
</p>


<p>
<a href="Probability.html#autosec-111" class="tocsubsection" >
Terminology</a>
</p>


<p>
<a href="Probability.html#autosec-113" class="tocsubsection" >
Naive Definition of Probability</a>
</p>


<p>
<a href="Probability.html#autosec-115" class="tocsubsection" >
Non-Naive Definition of Probability</a>
</p>


<p>
<a href="Foundations.html#autosec-120" class="tocchapter" >
Foundations</a>
</p>


<p>
<a href="Foundations.html#autosec-121" class="tocsection" >
Set Theory</a>
</p>


<p>
<a href="Foundations.html#autosec-125" class="tocsubsection" >
Basic Definitions</a>
</p>


<p>
<a href="Foundations.html#autosec-126" class="tocsubsection" >
Laws</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-152" class="tocsection" >
Factoring Tricks</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-153" class="tocsubsection" >
Basic Identities</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-154" class="tocsubsection" >
Splitting Apart a Monomial</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-155" class="tocsubsection" >
Adding Zero</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-156" class="tocsubsection" >
\((a^n - b^n) \)</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-158" class="tocsubsection" >
\((a^n + b^n) \)</a>
</p>


<p>
<a href="Quadratics.html#autosec-162" class="tocsection" >
Quadratics</a>
</p>


<p>
<a href="Quadratics.html#autosec-163" class="tocsubsection" >
Finding Roots of a Quadratic Function</a>
</p>


<p>
<a href="Quadratics.html#autosec-169" class="tocsubsection" >
Vieta’s Theorem</a>
</p>


<p>
<a href="Quadratics.html#autosec-172" class="tocsubsection" >
The Quadratic Formula</a>
</p>


</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<h1>Notes on Everything</h1>

<!--MathJax customizations:-->
<div data-nosnippet
    style="display:none"
>

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

</div>

<!--
...... chapter Algorithms ......
-->
<h3 id="autosec-30">Algorithms</h3>
<a id="index-autopage-30"></a>
<a id="index-autofile-3"></a>
<!--
...... section Graphs ......
-->
<h4 id="autosec-31">Graphs</h4>
<a id="index-autopage-31"></a>


<a id="sec:graphs"></a>

<p>
An extraordinary number of problems can be modeled by graphs. Despite being relatively simple, graph algorithms form the basis for more advanced solutions to problems concering connectivity, precedence, optimality, and much more. The solution to a graph problem is
usually built on top of the methodology used to explore the nodes in a graph, or <b><em>graph traversal</em></b> algorithm.
</p>
<!--
...... subsection Cuts ......
-->
<h5 id="autosec-32">Cuts</h5>
<a id="index-autopage-32"></a>


<a id="sec:graphs:cuts"></a>

<p>
A graph cut is a way of partitioning the nodes of a graph into two non-empty sets. Cuts and their properties are very useful to model various kinds of graph problems, and algorithms frequently exploit properties of a cut to obtain some desired solution. For example,
certain computer vision problems can be solved using graph-cut optimization algorithms.
</p>

<p>
Considering the edges ”crossing” the cut also reveals information about a graph itself, and is the basis for a large number of graph algorithms.
</p>

<p>
Fun fact:
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><a id="index-autopage-33"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">1</span></span>. </span> A graph \(G = (V,E)\) with \(n \geqslant 2\) vertices has exactly \(2^n - 2\) graph cuts.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="index-autopage-34"></a>

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> This proof is rather short, but hints at a strong connection between graphs and combinatorics. The main idea behind the proof is to recognize that there are two choices for a given node
to be placed into a set. Call the two sets a node can be placed into \(A\) and \(B\). We’ll start by counting the total ways to assign nodes to either set. Invoking the product rule \(n\) times, with two choices per invocation:
</p>

<p>
\[ \underbrace {2 \cdot 2 \cdot \dots \cdot 2}_\text {$n$ choices} = 2^n \]
</p>

<p>
However, the definition of a cut forbids either set from being empty. To make up for this, we need to subtract the invalid cases from the total. Since this problem only makes senses for graphs with at least two nodes, the only way a set can be empty is if we shove all the
nodes into one or the other. This can only be done two ways; either they all go into \(A\), leaving \(B\) empty, or the reverse. Therefore, the grand total comes out to:
</p>

<p>
\[ 2^n - 2 \]
</p>

<p>
<span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<!--
...... subsubsection Properties of a Graph Cut ......
-->
<h6 id="autosec-35">Properties of a Graph Cut</h6>
<a id="index-autopage-35"></a>


<p>
Some basic properties of a graph cut serve an important role in proving graph algorithms to be correct. A notable example is Prim’s algorithm, which relies on the <b>Cut Property</b> for its proof. Here’s three important properties and their proofs
</p>
<!--
...... paragraph Empty Cut ......
-->


<p>
<span class="paragraph" id="autosec-36">Empty Cut</span>
<a id="index-autopage-36"></a>

</p>

<p>
This lemma is an interesting way to rephrase what it means for a graph to be connected. Actually, the empty cut lemma is usually given as the contrapositive statement, that a graph is not connected if there is even a single cut where no edges are crossing. In other words,
if there is some partitioning of nodes such that the sets can’t reach other (since there are no crossing edges), then this means we’ve found (at least) two subgraphs that have no connection between them which is the definition of a disconnected graph. A picture greatly
clarifies the situation:
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><a id="index-autopage-37"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">1</span></span>. </span> <a id="lem:emptycut"></a> Empty Cut
</p>

<p>
A graph \(G = (V, E)\) is disconnected if and only if there is some cut \(C\) in which there are no crossing edges.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="index-autopage-38"></a>

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> Starting with the righthand side, if there are no edges crossing the cut, all we have to do is select a vertex from either of the sets and see that there’s no path from one to the other. But
if there are <em>any</em> two vertices that can’t reach one another in a graph, it’s disconnected by definition.
</p>

<p>
If \(G\) is disconnected, then there must be at least two groups of nodes that <em>are</em> connected. This holds even in the extreme case of a graph with no edges. Finding a cut with no crossing edges is a matter of identifying two of these disconnected groups and
placing them in opposite sets in the cut. Seen another way, since \(G\) is disconnected, it must have at least two connected components. We can compute those and create the necessary partition. Now for the formalities:
</p>

<p>
Suppose \(G\) is disconnected. Then there exist vertices \(u, v \in V\) such that there is no path from \(u\) to \(v\). Construct a graph cut as follows, in one of the sets in the partition, place all of those nodes reachable from \(u\). Let this set be called \(A\) and its
construction be given by
</p>

<p>
\[ A = \{u&apos; \in V \mid \exists \; \text {a path from $u$ to $u&apos;$ in $G$} \} \]
</p>

<p>
Similarly, construct the other set in the partition, \(B\) as those nodes that can be reached by \(v\)
</p>

<p>
\[ B = \{v&apos; \in V \mid \exists \; \text {a path from $v$ to $v&apos;$ in $G$} \} \]
</p>

<p>
These sets are disjoint, and there cannot be any edge from a vertex in \(A\) to one in \(B\). Therefore, we have exhibited a cut with no crossing edges and the forward direction is shown.
</p>

<p>
To see the reverse implication, assume that there exists a cut with no edges between the elements of either set forming the partition of nodes. Select an arbitrary node from either, say \(u, v\) and notice by construction there is no path from \(u\) to \(v\). But then by
definition there exist vertices in \(G\) such that no path exists between them, and so \(G\) cannot be connected. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<!--
...... paragraph Double-Crossing Lemma ......
-->


<p>
<span class="paragraph" id="autosec-39">Double-Crossing Lemma</span>
<a id="index-autopage-39"></a>

</p>

<p>
This lemma claims that if some edge in a cycle crosses a graph cut, then there must be at least two edges of that cycle crossing it. If this isn’t intuitive, another way to think about it is to imagine that some nodes involved in a cycle are in one set of the partition and the
rest are in the other. Since we have a cycle, we know we can start at one vertex and travel the edges until returning to the start. This means that each set has one ”way out” and one ”way in”. If this were not the case, then we wouldn’t be able to get back to the beginning
of the cycle, which would mean we didn’t actually have one to begin with!
</p>

<p>
This seemingly random bit of knowledge presents itself in a very elegant way in trying to prove the output of certain algorithms is a bona fide tree. A cycle is not allowed in a tree, and so if we can be certain that only one edge among all of the ones crossing the cut is ever
chosen, we eliminate any possibility of ever forming a cycle. This is similar to some arguments which systematically remove the edges of a cycle in a connected graph until none exists, just from the opposite perspective.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><a id="index-autopage-40"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">2</span></span>. </span> <a id="lem:doublecross"></a> Suppose a cycle \(C \in E\) has an edge crossing the cut \((A, B)\). Then there must be at least
two edges of \(C\) crossing the cut.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="index-autopage-41"></a>

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> To prove the Double-Crossing Lemma, all we have to show is that it is not possible for a cycle which has an edge crossing a cut to have fewer than 2 such edges. To see this imagine if
there were only one edge, and attempt to navigate the cycle back to the starting point. Clearly it’s impossible, since there’s no way back to the beginning.
</p>

<p>
This reasoning is straightforward, and a more formal proof barely serves any purpose in providing additional clarity. Nevertheless:
</p>

<p>
Suppose \(C \in E\) has an edge crossing the cut labeled \((A, B)\) and further suppose by way of contradiction that \(C\) has fewer than 2 edges crossing the cut. By assumption, \(C\) has at least one edge, so it will suffice to consider the case in which \(C\) has
exactly one crossing edge.
</p>

<p>
Choose an arbitrary vertex, say \(u\), involved in \(C\). By definition, there is a path:
</p>

<p>
\[ u-e_1-v_1-e_2-\dots -v_{n-1}-e_{n-1}-u \]
</p>

<p>
such that \(e_1 \neq e_{n-1}\). Consider the edge \(e_j\) in \(C\) crossing the cut which has endpoints \(v_i, v_j \; i \neq j\). Then \(v_j\) is in the opposite set of \(u\). By definition of a cycle, there must be some path from \(v_j\) to \(u\). This is impossible,
since such an edge would need contain vertices \(v_k, v_l\) with \(v_k\) in the same set as \(v_j\) and \(v_l\) in the same set as \(u\), meaning it would have to cross the cut. This contradicts the claim that \(C\) had only single edge crossing the cut, and thus the
proof is complete. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<!--
...... subsection Depth-First Search ......
-->
<h5 id="autosec-42">Depth-First Search</h5>
<a id="index-autopage-42"></a>


<p>
Depth-first search is arguably the simpler of the two main traversal algorithms. The key idea is to explore a graph as ”deeply” as possible, following the trail of nodes as far as possible before backtracking out to the starting point. DFS ignores neighbors until after there
are no additional nodes to explore or after reaching an already visited node.
</p>

<figure id="autoid-1" class="algorithm ruled">

<div class="figurecaption">
<p>
Algorithm&nbsp;1:&nbsp;Depth-First Search
</p>
</div>
<ul class="list" style="list-style-type:none">

<li>
<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span>visited = \(\emptyset \)
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>procedure</b> <span class="textsc">DFS</span>(\(v\))
</p>

</li>
<li>

<p>
<span class="listmarker"></span>         <span style="width:12pt; display:inline-block;"></span>add \(v\) to visited
</p>

</li>
<li>

<p>
<span class="listmarker"></span>         <span style="width:12pt; display:inline-block;"></span><b>for</b> \(u \in V\) such that \((v, u) \in E\) <b>do</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>            <span style="width:24pt; display:inline-block;"></span><b>if</b> \(u \not \in \) visited <b>then</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>               <span style="width:36pt; display:inline-block;"></span>DFS(\(u\))
</p>

</li>
<li>

<p>
<span class="listmarker"></span>            <span style="width:24pt; display:inline-block;"></span><b>end</b> <b>if</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>         <span style="width:12pt; display:inline-block;"></span><b>end</b> <b>for</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>end</b> <b>procedure</b>
</p>
</li>
</ul>

</figure>
<!--
...... subsubsection Analysis ......
-->
<h6 id="autosec-43">Analysis</h6>
<a id="index-autopage-43"></a>


<p>
Depth-first search explores each reachable node from starting vertex \(v\) and traverses edge incident on \(v\). Additionally, the check for whether a node has been visited before (using a hash) runs in expected \(O(1)\) time.
</p>

<p>
Due to visiting every node, the runtime of DFS is \(O(|V| + |E|)\).
</p>
<!--
...... subsection Breadth-First Search ......
-->
<h5 id="autosec-44">Breadth-First Search</h5>
<a id="index-autopage-44"></a>


<p>
Breadth-first search (BFS) proceeds to process the ”levels” of a graph, proceeding only when every neighbor of the current node has been explored. Typical implementations enqueue the neighbors of a vertex in order to enforce a BFS discipline.
</p>

<figure id="autoid-2" class="algorithm ruled">

<div class="figurecaption">
<p>
Algorithm&nbsp;2:&nbsp;Breadth-First Search
</p>
</div>
<ul class="list" style="list-style-type:none">

<li>
<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span>\(Q = \{v\}\)
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span>visited = \(\emptyset \)
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>while</b> \(Q\) is not empty <b>do</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>        <span style="width:12pt; display:inline-block;"></span>\(u =\) dequeue(\(Q\))
</p>

</li>
<li>

<p>
<span class="listmarker"></span>        <span style="width:12pt; display:inline-block;"></span><b>for</b> \(w \in V\) such that \((u, w) \in E\) <b>do</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>           <span style="width:24pt; display:inline-block;"></span><b>if</b> \(w \not \in \) visited <b>then</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>              <span style="width:36pt; display:inline-block;"></span>add \(w\) to visited
</p>

</li>
<li>

<p>
<span class="listmarker"></span>              <span style="width:36pt; display:inline-block;"></span>enqueue(\(Q, w\))
</p>

</li>
<li>

<p>
<span class="listmarker"></span>           <span style="width:24pt; display:inline-block;"></span><b>end</b> <b>if</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>        <span style="width:12pt; display:inline-block;"></span><b>end</b> <b>for</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>end</b> <b>while</b>
</p>
</li>
</ul>

</figure>
<!--
...... subsubsection Analysis ......
-->
<h6 id="autosec-45">Analysis</h6>
<a id="index-autopage-45"></a>


<p>
Similar to DFS, the runtime of BFS is \(O(|V| + |E|)\) assuming an implementation of a queue which allows constant time add and remove operations.
</p>
<!--
...... subsection Topological Ordering ......
-->
<h5 id="autosec-46">Topological Ordering</h5>
<a id="index-autopage-46"></a>


<p>
A Topological ordering in a directed graph is the order in which DFS explores vertices (formally called reverse post-order). The topological sort algorithm computes a valid topological ordering of a directed graph \(G\), if one exists.
</p>

<p>
Such orderings are typically used to determine whether a precedence graph is logically consistent, and if so, compute a correct sequence of operations.
</p>

<figure id="autoid-3" class="algorithm ruled">

<div class="figurecaption">
<p>
Algorithm&nbsp;3:&nbsp;TopoSort
</p>
</div>
<ul class="list" style="list-style-type:none">

<li>
<p>
<span class="listmarker"><b>Require:</b></span> \(G\) is a directed acyclic graph
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span>visited = \(\emptyset \)
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span>processing = \(\emptyset \)
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span>ordering = Stack
</p>

</li>
<li>

<p>
<span class="listmarker"></span>
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>procedure</b> <span class="textsc">DFS</span>(\(v\))
</p>

</li>
<li>

<p>
<span class="listmarker"></span>         <span style="width:12pt; display:inline-block;"></span>mark \(v\) as visited
</p>

</li>
<li>

<p>
<span class="listmarker"></span>         <span style="width:12pt; display:inline-block;"></span>processing(v) = True
</p>

</li>
<li>

<p>
<span class="listmarker"></span>         <span style="width:12pt; display:inline-block;"></span><b>for</b> \(u\) such that \((v, u) \in E\) <b>do</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>            <span style="width:24pt; display:inline-block;"></span><b>if</b> \(u \not \in visited\) <b>then</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>               <span style="width:36pt; display:inline-block;"></span>DFS(\(u\))
</p>

</li>
<li>

<p>
<span class="listmarker"></span>            <span style="width:24pt; display:inline-block;"></span><b>else</b> <b>if</b> \(u\) is a node currently being processed <b>then</b> <b>return</b> ”no topological ordering”
</p>

</li>
<li>

<p>
<span class="listmarker"></span>            <span style="width:24pt; display:inline-block;"></span><b>end</b> <b>if</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>         <span style="width:12pt; display:inline-block;"></span><b>end</b> <b>for</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>         <span style="width:12pt; display:inline-block;"></span>processing(v) = False
</p>

</li>
<li>

<p>
<span class="listmarker"></span>         <span style="width:12pt; display:inline-block;"></span>ordering.push(v)
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>end</b> <b>procedure</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>for</b> \(v \in V\) <b>do</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>         <span style="width:12pt; display:inline-block;"></span><b>if</b> \(v \not \in visited\) <b>then</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>            <span style="width:24pt; display:inline-block;"></span>DFS(\(v\))
</p>

</li>
<li>

<p>
<span class="listmarker"></span>         <span style="width:12pt; display:inline-block;"></span><b>end</b> <b>if</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>end</b> <b>for</b><b>return</b> ordering
</p>
</li>
</ul>

</figure>
<!--
...... subsection Strongly Connected Components ......
-->
<h5 id="autosec-47">Strongly Connected Components</h5>
<a id="index-autopage-47"></a>


<p>
We define ”strongly-connected” as a relation between two vertices \(u, v \in V\) such that \((u, v) \in R\) if there exists a path from \(u\) to \(v\) and a path from \(v\) to \(u\). Strongly connected components represent an equivalence class of the vertices of that
component.
</p>

<p>
Kosaraju’s algorithm computes the strongly connected components of \(G = (V, E)\) via two passes. The first past computes a ”topological ordering” of the reverse of \(G\), \(G_{\text {rev}}\), which provides the ordering necessary to provide to an additional pass of
DFS.
</p>

<p>
> Note that there cannot be a valid topological ordering in the strictest sense due to the fact that there must be a cycle in a directed graph in order for two vertices to be strongly connected.
</p>

<figure id="autoid-4" class="algorithm ruled">

<div class="figurecaption">
<p>
Algorithm&nbsp;4:&nbsp;Kosaraju-Sharir
</p>
</div>
<ul class="list" style="list-style-type:none">

<li>
<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span>scc = \(\emptyset \)
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span>count = 0
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span>visited = \(\emptyset \)
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span>ordering = <span class="textsc">TopoSort</span>(\(G_{\text {rev}}\))
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>function</b> <span class="textsc">DFS-SCC</span>(\(G, v\))
</p>

</li>
<li>

<p>
<span class="listmarker"></span>         <span style="width:12pt; display:inline-block;"></span>mark \(v\) as visited
</p>

</li>
<li>

<p>
<span class="listmarker"></span>         <span style="width:12pt; display:inline-block;"></span>scc(\(v\)) = count
</p>

</li>
<li>

<p>
<span class="listmarker"></span>         <span style="width:12pt; display:inline-block;"></span><b>for</b> \(u \in V\) such that \((v, u) \in E\) <b>do</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>            <span style="width:24pt; display:inline-block;"></span><b>if</b> \(u \not \in \) visited <b>then</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>               <span style="width:36pt; display:inline-block;"></span>DFS-SCC(\(G, u\))
</p>

</li>
<li>

<p>
<span class="listmarker"></span>            <span style="width:24pt; display:inline-block;"></span><b>end</b> <b>if</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>         <span style="width:12pt; display:inline-block;"></span><b>end</b> <b>for</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>end</b> <b>function</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>for</b> \(v\) in ordering <b>do</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>         <span style="width:12pt; display:inline-block;"></span>DFS-SCC(\(G, v\))
</p>

</li>
<li>

<p>
<span class="listmarker"></span>         <span style="width:12pt; display:inline-block;"></span>count = count + 1
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>end</b> <b>for</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span>
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <b>return</b> scc
</p>
</li>
</ul>

</figure>

</section>

</main>

</div>

<footer>

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

</footer>


<nav class="botnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|Greedy.html|-->

<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Anthony" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="Personal notes on Mathematics and Computer Science" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Notes on Everything — Greedy</title>
<link rel="stylesheet" type="text/css" href="lwarp.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
  subequations: "0",
  section: "",
  loader: {
    load: ['[tex]/tagformat', '[tex]/textmacros'],
  },
  startup: {
    ready() {
      // These would be replaced by import commands if you wanted to make
      // a proper extension.
      const Configuration = MathJax._.input.tex.Configuration.Configuration;
      const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
      const Macro = MathJax._.input.tex.Symbol.Macro;
      const TexError = MathJax._.input.tex.TexError.default;
      const ParseUtil = MathJax._.input.tex.ParseUtil.default;
      const expandable = MathJax._.util.Options.expandable;

       // Insert the replacement string into the TeX string, and check
       // that there haven't been too many maxro substitutions (prevents
       // infinite loops).
       const useArgument = (parser, text) => {
         parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
         parser.i = 0;
         if (++parser.macroCount > parser.configuration.options.maxMacros) {
           throw new TexError('MaxMacroSub1',
           'MathJax maximum macro substitution count exceeded; ' +
           'is there a recursive macro call?');
         }
       }

       // Create the command map for:
       //     \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
       new CommandMap('Lwarp-macros', {
         ifstar: 'IfstarFunction',
         ifnextchar: 'IfnextcharFunction',
         ifblank: 'IfblankFunction',
         ifstrequal: 'IfstrequalFunction',
         gsubstitute: 'GsubstituteFunction',
         seteqnumber: 'SeteqnumberFunction'
       }, {
         // This function implements an ifstar macro.
         IfstarFunction(parser, name) {
            const resultstar = parser.GetArgument(name);
            const resultnostar = parser.GetArgument(name);
            const star = parser.GetStar();                 // true if there is a *
            useArgument(parser, star ? resultstar : resultnostar);
         },

          // This function implements an ifnextchar macro.
          IfnextcharFunction(parser, name) {
            let whichchar = parser.GetArgument(name);
            if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
              // $ syntax highlighting
              whichchar = String.fromCodePoint(parseInt(whichchar));
            }
            const resultnextchar = parser.GetArgument(name);
            const resultnotnextchar = parser.GetArgument(name);
            const gotchar = (parser.GetNext() === whichchar);
            useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
          },

          // This function implements an ifblank macro.
          IfblankFunction(parser, name) {
            const blankarg = parser.GetArgument(name);
            const resultblank = parser.GetArgument(name);
            const resultnotblank = parser.GetArgument(name);
            const isblank = (blankarg.trim() == "");
            useArgument(parser, isblank ? resultblank : resultnotblank);
          },

          // This function implements an ifstrequal macro.
          IfstrequalFunction(parser, name) {
            const strequalfirst = parser.GetArgument(name);
            const strequalsecond = parser.GetArgument(name);
            const resultequal = parser.GetArgument(name);
            const resultnotequal = parser.GetArgument(name);
            const isequal = (strequalfirst == strequalsecond);
            useArgument(parser, isequal ? resultequal : resultnotequal);
          },

          // This function implements a gsub macro.
          GsubstituteFunction(parser, name) {
            const gsubfirst = parser.GetArgument(name);
            const gsubsecond = parser.GetArgument(name);
            const gsubthird = parser.GetArgument(name);
            let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
            useArgument(parser, gsubresult);
          },

          // This function modifies the equation numbers.
          SeteqnumberFunction(parser, name) {
              // Get the macro parameters
              const star = parser.GetStar();                  // true if there is a *
              const optBrackets = parser.GetBrackets(name);   // contents of optional brackets
              const newsubequations = parser.GetArgument(name); // the subequations argument
              const neweqsection = parser.GetArgument(name); // the eq section argument
              const neweqnumber = parser.GetArgument(name);   // the eq number argument
              MathJax.config.subequations=newsubequations ;   // a string with boolean meaning
              MathJax.config.section=neweqsection ;           // a string with numeric meaning
              parser.tags.counter = parser.tags.allCounter = neweqnumber ;
          }

       });

       // Create the Lwarp-macros package
       Configuration.create('Lwarp-macros', {
         handler: {macro: ['Lwarp-macros']}
       });

       MathJax.startup.defaultReady();

       // For forward references:
       MathJax.startup.input[0].preFilters.add(({math}) => {
         if (math.inputData.recompile){
             MathJax.config.subequations = math.inputData.recompile.subequations;
             MathJax.config.section = math.inputData.recompile.section;
         }
       });
       MathJax.startup.input[0].postFilters.add(({math}) => {
         if (math.inputData.recompile){
             math.inputData.recompile.subequations = MathJax.config.subequations;
             math.inputData.recompile.section = MathJax.config.section;
         }
       });

         // For \left, \right with unicode-math:
         const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
         const {Symbol} = MathJax._.input.tex.Symbol;
         const {MapHandler} = MathJax._.input.tex.MapHandler;
         const delimiter = MapHandler.getMap('delimiter');
         delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
         delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
         delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
         delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
         delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
         delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
         delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
         delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
         delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
         delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
         delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
         delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
         delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
         delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
         delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
         delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
         delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
         delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
         delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
         delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
         delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
         delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
         delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
         delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
         delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
         delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
         delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
         delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
         delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
         delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
         delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
         delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
         delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
         delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
         delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
         delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
         delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
         delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
         delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
   }     // ready
 },      // startup

 tex: {
   packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
   tags: "ams",
        tagformat: {
            number: function (n) {
                if(MathJax.config.subequations==0)
                    return(MathJax.config.section + n);
                else
                    return(MathJax.config.section + String.fromCharCode(96+n));
            },
        },
 }
}
</script>

<script
    id="MathJax-script"
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="index-autopage-48"></a>
<nav class="topnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Notes on Everything</span>
</p>

<p>
Subjects
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="Sums.html#autosec-6" class="tocchapter" >
Sums</a>
</p>


<p>
<a href="Sums.html#autosec-7" class="tocsection" >
Manipulating Sums</a>
</p>


<p>
<a href="Sums.html#autosec-8" class="tocsubsection" >
Basic Rules</a>
</p>


<p>
<a href="Sums.html#autosec-10" class="tocsubsection" >
Iverson Notation</a>
</p>


<p>
<a href="Sums.html#autosec-13" class="tocsubsection" >
Perturbing the Sum</a>
</p>


<p>
<a href="Sums.html#autosec-16" class="tocsubsection" >
Multiple Sums</a>
</p>


<p>
<a href="Finite-Calculus.html#autosec-24" class="tocsection" >
Finite Calculus</a>
</p>


<p>
<a href="Finite-Calculus.html#autosec-25" class="tocsubsection" >
The Difference Operator</a>
</p>


<p>
<a href="Finite-Calculus.html#autosec-26" class="tocsubsection" >
Rising and Falling Factorials</a>
</p>


<p>
<a href="Algorithms.html#autosec-30" class="tocchapter" >
Algorithms</a>
</p>


<p>
<a href="Algorithms.html#autosec-31" class="tocsection" >
Graphs</a>
</p>


<p>
<a href="Algorithms.html#autosec-32" class="tocsubsection" >
Cuts</a>
</p>


<p>
<a href="Algorithms.html#autosec-42" class="tocsubsection" >
Depth-First Search</a>
</p>


<p>
<a href="Algorithms.html#autosec-44" class="tocsubsection" >
Breadth-First Search</a>
</p>


<p>
<a href="Algorithms.html#autosec-46" class="tocsubsection" >
Topological Ordering</a>
</p>


<p>
<a href="Algorithms.html#autosec-47" class="tocsubsection" >
Strongly Connected Components</a>
</p>


<p>
<a href="Greedy.html#autosec-49" class="tocsection" >
Greedy</a>
</p>


<p>
<a href="Greedy.html#autosec-50" class="tocsubsection" >
Dijkstra’s Shortest Path Algorithm</a>
</p>


<p>
<a href="Greedy.html#autosec-61" class="tocsubsection" >
Prim’s MST Algorithm</a>
</p>


<p>
<a href="Greedy.html#autosec-70" class="tocsubsection" >
Kruskal’s MST Algorithm</a>
</p>


<p>
<a href="Greedy.html#autosec-77" class="tocsubsection" >
Huffman Codes</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-84" class="tocsection" >
Divide and Conquer</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-85" class="tocsubsection" >
Master Theorem</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-87" class="tocsubsection" >
MergeSort</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-89" class="tocsubsection" >
Counting Array Inversions</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-92" class="tocsubsection" >
Karatsuba Multiplication</a>
</p>


<p>
<a href="Combinatorics.html#autosec-94" class="tocchapter" >
Combinatorics</a>
</p>


<p>
<a href="Combinatorics.html#autosec-95" class="tocsection" >
Basics of Counting</a>
</p>


<p>
<a href="Combinatorics.html#autosec-96" class="tocsubsection" >
Product Rule</a>
</p>


<p>
<a href="Combinatorics.html#autosec-99" class="tocsubsection" >
Complement Rule</a>
</p>


<p>
<a href="Combinatorics.html#autosec-103" class="tocsubsection" >
Inclusion/Exclusion</a>
</p>


<p>
<a href="Combinatorics.html#autosec-106" class="tocsubsection" >
Permutations</a>
</p>


<p>
<a href="Probability.html#autosec-109" class="tocchapter" >
Probability</a>
</p>


<p>
<a href="Probability.html#autosec-110" class="tocsection" >
Basics</a>
</p>


<p>
<a href="Probability.html#autosec-111" class="tocsubsection" >
Terminology</a>
</p>


<p>
<a href="Probability.html#autosec-113" class="tocsubsection" >
Naive Definition of Probability</a>
</p>


<p>
<a href="Probability.html#autosec-115" class="tocsubsection" >
Non-Naive Definition of Probability</a>
</p>


<p>
<a href="Foundations.html#autosec-120" class="tocchapter" >
Foundations</a>
</p>


<p>
<a href="Foundations.html#autosec-121" class="tocsection" >
Set Theory</a>
</p>


<p>
<a href="Foundations.html#autosec-125" class="tocsubsection" >
Basic Definitions</a>
</p>


<p>
<a href="Foundations.html#autosec-126" class="tocsubsection" >
Laws</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-152" class="tocsection" >
Factoring Tricks</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-153" class="tocsubsection" >
Basic Identities</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-154" class="tocsubsection" >
Splitting Apart a Monomial</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-155" class="tocsubsection" >
Adding Zero</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-156" class="tocsubsection" >
\((a^n - b^n) \)</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-158" class="tocsubsection" >
\((a^n + b^n) \)</a>
</p>


<p>
<a href="Quadratics.html#autosec-162" class="tocsection" >
Quadratics</a>
</p>


<p>
<a href="Quadratics.html#autosec-163" class="tocsubsection" >
Finding Roots of a Quadratic Function</a>
</p>


<p>
<a href="Quadratics.html#autosec-169" class="tocsubsection" >
Vieta’s Theorem</a>
</p>


<p>
<a href="Quadratics.html#autosec-172" class="tocsubsection" >
The Quadratic Formula</a>
</p>


</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<h1>Notes on Everything</h1>

<!--MathJax customizations:-->
<div data-nosnippet
    style="display:none"
>

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

</div>

<!--
...... section Greedy ......
-->
<h4 id="autosec-49">Greedy</h4>
<a id="index-autopage-49"></a>
<a id="index-autofile-4"></a>

<p>
The greedy algorithm design paradigm produces straightforward and fast solutions to certain problems. Usually, however, greedy algorithms do not produce correct results, and great care must be taken to prove their correctness.
</p>

<p>
In general, the strategy is to choose a locally optimal solution in the hopes that it produces a globally optimal output. Proofs of correctness and optimality usually involve an exchange argument and/or induction.
</p>
<!--
...... subsection Dijkstra's Shortest Path Algorithm ......
-->
<h5 id="autosec-50">Dijkstra’s Shortest Path Algorithm</h5>
<a id="index-autopage-50"></a>


<p>
The canonical greedy algorithm. Dijkstra’s algorithm computes the shortest paths from a starting vertex by choose the least costly edge spanning a graph ”cut” or partition incident to the visited nodes. In other words, greedily choose the edge which minimizes the current
distance traveled.
</p>

<figure id="autoid-5" class="figure ">
<div class="center">

<p>
<span
    id="lateximage-index-2"
    class="lateximagesource"
><!--
        V
    1           6


S           2       T
    4           3

        W
--><img
    src="index-images/image-2.svg"
    alt="(-tikz-&nbsp;diagram)"
    style=""
    class="lateximage"
></span>
</p>

<div class="figurecaption">
<p>
Figure&nbsp;1:&nbsp;Weighted, directed graph
</p>
</div>

<a id="fig:dijkstra1"></a>

</div>

</figure>

<p>
The shortest path algorithm outputs the following when starting from \(S\):
</p>
<table>

<tr style="display:none"><th>.</th></tr>

<tr class="hline">
<td class="tdc tvertbarl tvertbarr" style="border-left: 1px solid black; border-right: 1px solid black">Vertex</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">Shortest Path</td>
</tr>

<tr class="hline">
<td class="tdc tvertbarl tvertbarr" style="border-left: 1px solid black; border-right: 1px solid black">S</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">0</td>
</tr>

<tr class="hline">
<td class="tdc tvertbarl tvertbarr" style="border-left: 1px solid black; border-right: 1px solid black">V</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">1</td>
</tr>

<tr class="hline">
<td class="tdc tvertbarl tvertbarr" style="border-left: 1px solid black; border-right: 1px solid black">W</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">3</td>
</tr>

<tr class="hline">
<td class="tdc tvertbarl tvertbarr" style="border-left: 1px solid black; border-right: 1px solid black">T</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">6</td>
</tr>

<tr class="hline" aria-hidden="true">
<td class="tdc"></td>
<td class="tdc"></td>
</tr>
</table>

<figure id="autoid-6" class="algorithm ruled">

<div class="figurecaption">
<p>
Algorithm&nbsp;5:&nbsp;Dijkstra’s Shortest-Path
</p>
</div>
<ul class="list" style="list-style-type:none">

<li>
<p>
<span class="listmarker"><b>Require:</b></span> \(G = (V, E)\) has nonnegative edge weights
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span>\(X = \{s\}\)
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span>len(s) = 0, len(v) = \(+\infty \) for every \(v \neq s\)
</p>

</li>
<li>

<p>
<span class="listmarker"></span>
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>while</b> There exists an edge \((v, w) \; v \in X, w \not \in X\) <b>do</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>         <span style="width:12pt; display:inline-block;"></span>\((v&apos;, w&apos;)\) = edge minimizing \(len(v) + l_{vw}\)
</p>

</li>
<li>

<p>
<span class="listmarker"></span>         <span style="width:12pt; display:inline-block;"></span>Add \(w&apos;\) to \(X\)
</p>

</li>
<li>

<p>
<span class="listmarker"></span>         <span style="width:12pt; display:inline-block;"></span>len(w’) = len(v’) + \(l_{v&apos;w&apos;}\)
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <b>return</b> len
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>end</b> <b>while</b>
</p>
</li>
</ul>

</figure>

<p>
The proof of Dijkstra’s shortest-path algorithm differs from that of Prim’s and Kruskal’s in that it proceeds by basic induction rather than presenting a proof by contradiction and exchange argument<sup>1</sup><a id="index-autopage-54"></a>.
</p>

<p>
First, a precise statement of the theorem:
</p>
<div role="note" class="footnotes">

<a id="index-autopage-55"></a>

<p>
<sup>1</sup>&nbsp;Consequently, I find this proof to be slightly more difficult
</p>


</div>



<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker">
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">2</span></span>. </span> <a id="thm:dijkstra"></a> For every directed graph \(G = (V, E)\), for every starting vertex \(s \in V\), Dijkstra’s
shortest-path algorithm outputs the distance of the shortest paths from \(s\) to every (reachable) \(v \in V\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="index-autopage-56"></a>

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof of Dijkstra’s Shortest-Path Algorithm.</span></span> <a id="prf:dijkstra"></a> Let \(k\) be the current iteration of the while loop in Dijkstra’s algorithm, that is, the \(k\)th choice of vertex, say,
\(v\) to be added to the solution. During this iteration, the shortest distance \(dist[v]\) from \(s\) is computed. The goal of this proof is to show that every iteration of the algorithm gives the correct distance from \(s\) for all vertices.
</p>

<p>
Proceeding by induction, for \(k = 1\) the computed distance from the starting vertex \(s\) to itself is 0, which is clearly correct. Now assume the correct distance is computed for all \(k = 1, 2, \dots n-1\), and consider the moment the algorithm must choose the
\(n\)th vertex, call it \(u\), to add to the solution and let the edge chosen by the algorithm be labeled \((v, u)\).
</p>

<p>
By the algorithm, \(u\)’s distance is computed to be:
</p>

<p>
\[ dist[u] = dist[v] + length_{vu} \]
</p>

<p>
To show that this is indeed the shortest path from \(s\) to \(u\), consider an arbitrary path \(P\) from \(s\) to \(u\). We will show the length of this path is at least the value produced by Dijkstra’s algorithm. We can deduce that \(P\) must be comprised of three
segments:
</p>

<ul class="itemize" style="list-style-type:none">


<li>
<p>
<span class="listmarker">•</span> A prefix of vertices already processed
</p>


</li>
<li>


<p>
<span class="listmarker">•</span> At least one edge crossing the cut of visited and unvisited nodes
</p>


</li>
<li>


<p>
<span class="listmarker">•</span> A path consisting of unvisited nodes that reaches \(u\)
</p>
</li>
</ul>

<figure id="autoid-7" class="figure ">
<div class="center">

<p>
<span
      id="lateximage-index-3"
      class="lateximagesource"
><!--
s   a   b   u
--><img
      src="index-images/image-3.svg"
      alt="(-tikz-&nbsp;diagram)"
      style=""
      class="lateximage"
></span>
</p>


<div class="figurecaption">
<p>
Figure&nbsp;2:&nbsp;Arbitrary                                                                                                                    shortest                                                                                                                     path
</p>
</div>

<a id="fig:shortest_path"></a>

</div>

</figure>

<p>
Let \((a, b)\) be the edge in \(P\) bridging the aforementioned cut. It suffices to compute a lower bound for the length of \(P\). The first segment consisting of a path from \(s\) to \(a\) has length \(dist[a]\). By the inductive hypothesis, each vertex in the first
segment has its correct shortest distance recorded. The segment consisting of only the edge \((a, b)\) has length \(length_{ab}\). Finally, the final segment must be non-negative due to the restrictions the algorithm imposes on the input graph.
</p>

<p>
\[ len(P) \geqslant dist[a] + length_{ab} \]
</p>

<p>
The final step in the proof makes use of the fact that Dijkstra’s algorithm always chooses the edge which minimizes the sum of a candidate path’s prefix and the edge cross the cut. In other words, we have shown:
</p>

<p>
\[ dist[u] + length_{uw} \leqslant dist[a] + length_{ab} \leqslant len(P) \]
</p>

<p>
therefore, the path chosen by the algorithm is always the shortest such path. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<!--
...... subsubsection Analysis ......
-->
<h6 id="autosec-60">Analysis</h6>
<a id="index-autopage-60"></a>


<p>
The cost of repeatedly selecting the minimum edge via brute force dominates the runtime of the algorithm. For \(G = (V, E)\), we traverse \(|V|\) nodes, each time performing \(O(|E|)\) work to select the minimum edge crossing the cut. Therefore, the naive version of
Dijkstra’s runs in \(O(|E||V|)\).
</p>

<p>
Using a [[Heap]] this algorithm can be sped up significantly, achieving \(O((|E| + |V|)\log |V|)\) runtime.
</p>
<!--
...... subsection Prim's MST Algorithm ......
-->
<h5 id="autosec-61">Prim’s MST Algorithm</h5>
<a id="index-autopage-61"></a>


<p>
”Robert Prim’s” algorithm, which was actually discovered a few decades prior, computes a minimum spanning tree of an undirected graph. The general strategy is very close to how Dijkstra’s chooses which edge weight will be used in order to compute the current distance
from the starting vertex. The main idea here is simply to choose the minimum edge out of all the edges crossing the cut formed by visited and unvisited nodes in \(V\).
</p>

<p>
The key difference is subtle, but important. Dijkstra’s algorithm chooses the edge which minimizes the total distance from the starting vertex, while Prim’s chooses the edge with minimum individual cost. This has the overall effect of <em>minimizing</em> the
<em>maximum</em> edge cost along every path. This key fact is critical in proving Prim’s algorithm correct.
</p>
<div class="center">

<p>
<span
    id="lateximage-index-4"
    class="lateximagesource"
><!--
        1
a           b
        3
4               2

    c       d
        5
--><img
    src="index-images/image-4.svg"
    alt="(-tikz-&nbsp;diagram)"
    style=""
    class="lateximage"
></span>
</p>
</div>

<figure id="autoid-8" class="algorithm ruled">

<div class="figurecaption">
<p>
Algorithm&nbsp;6:&nbsp;Prim’s MST Algorithm
</p>
</div>
<ul class="list" style="list-style-type:none">

<li>
<p>
<span class="listmarker"><b>Require:</b></span> \(G = (V, E)\) is connected
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span>\(X = \{s\}\)
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span>\(T = \emptyset \)
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>while</b> There is an edge \((v, w)\) s.t \(v \in X\), \(w \not \in X\) <b>do</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>     <span style="width:12pt; display:inline-block;"></span>\((v&apos;, w&apos;)\) = minimum cost edge
</p>

</li>
<li>

<p>
<span class="listmarker"></span>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>     <span style="width:12pt; display:inline-block;"></span>Add \(w&apos;\) to \(X\)
</p>

</li>
<li>

<p>
<span class="listmarker"></span>     <span style="width:12pt; display:inline-block;"></span>Add \((v&apos;, w&apos;)\) to \(T\)
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>end</b> <b>while</b><b>return</b> \(T\)
</p>
</li>
</ul>

</figure>
<!--
...... subsubsection Correctness ......
-->
<h6 id="autosec-65">Correctness</h6>
<a id="index-autopage-65"></a>


<p>
We need to prove that Prim’s algorithm not only computes a spanning tree, but that this tree is the best possible one that could have been produced. The main ideas of this proof rely on properties of graph <a href="Algorithms.html#sec:graphs:cuts"></a>, and the
crucial fact that Prim’s only ever chooses the minimal edge spanning the cut.
</p>

<p>
Proving each part as separate lemmas keeps the arguments nice and tidy:
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><a id="index-autopage-66"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">3</span></span>. </span> Prim’s algorithm outputs a spanning tree.
</p>

</li>

</ul>

</div>

<p>
The first order of business is to show that Prim’s algorithm maintains the invariant that \(T\) spans the visited nodes in \(X\). In other words, \(T\) is a graph that contains all of the vertices in \(X\) at every iteration. This can be achieved via a straightforward inductive
proof. All that really needs to be shown here is that whenever the algorithm adds a vertex to \(X\), it always adds the edge that led to that vertex. This is clear from reading the code, but a proof is good for building character.
</p>
<div class="amsthmproof">

<a id="index-autopage-67"></a>

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> Consider Prim’s algorithm given an input graph of exactly one edge. Clearly this edge will immediately be added to \(T\) during the first iteration, and since this edge is incident to the
only two vertices in the graph, \(T\) spans \(X\) trivially. Now assume the \(T\) spans \(X\) for graphs having \(n \geqslant 2\) vertices. Notice when the \(n+1\)st vertex \(w&apos;\) is added to \(X\), then so is the edge incident to it. By hypothesis, \(T\) spans all
\(n\) vertices already added to \(X\), and by virtue of adding an edge incident to \(w&apos;\), must also span \(w&apos;\) as well. Thus, \(T\) spans \(X\) at every iteration of Prim’s algorithm. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
Onto more interesting business. We know that \(T\) spans \(X\), but still need to show the algorithm terminates eventually, and that \(T\) is in fact a spanning tree by the time the loop is finished. This is where a clever application of the <a
href="Algorithms.html#lem:emptycut">1</a> lemma helps out in a proof by contradiction.
</p>

<p>
Since the algorithm adds a vertex to \(X\) every iteration, we’ll eventually run out of edges that cross the cut, and therefore exit the loop. What if the algorithm terminates early, however? Can \(T\) fail to span all of the nodes in \(G\)? From the pseudocode, the while
loop stops as soon as there are no further edges to be processed. If there are nodes left in \(V-X\) when this happens, we have ourselves a graph cut. By the empty cut lemma, this means that \(G\) must have been disconnected, violating the constraints of the algorithm!
The proof sketch is solid, now to get to work.
</p>
<div class="amsthmproof">

<a id="index-autopage-68"></a>

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> To see that Prim’s algorithm terminates, notice that every iteration of the while loop some vertex is added to \(X\). Because \(G\) is finite, there can only be a finite number of edges to
cross the cut. Therefore, since each iteration of the loop reduces this number by exactly one, the loop will terminate by induction.
</p>

<p>
Now to show that the output \(T\) spans all vertices of \(G\), assume by way of contradiction that there are vertices in \(G\) which \(T\) does not span. By the previous lemma, \(T\) spans all vertices in \(X\), and so those \(T\) does not span must be in \(V-X\). This
exhibits a graph cut which must have no crossing edges by way of the termination condition. But then by the empty cut lemma, \(G\) is disconnected, contradicting the constraint on the input to the algorithm.
</p>

<p>
Thus, the output graph \(T\) spans all vertices in \(G\). <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<!--
...... subsubsection Runtime Analysis ......
-->
<h6 id="autosec-69">Runtime Analysis</h6>
<a id="index-autopage-69"></a>


<p>
Once again the cost of repeatedly selecting the minimum edge dominates the runtime of the algorithm leading to \(O(|V||E|)\) worst-case runtime.
</p>

<p>
We can employ the same technique of using a Heap as in Dijkstra’s algorithm to achieve a runtime of \(O(|E|\log |V|)\).
</p>
<!--
...... subsection Kruskal's MST Algorithm ......
-->
<h5 id="autosec-70">Kruskal’s MST Algorithm</h5>
<a id="index-autopage-70"></a>


<p>
Kruskal’s algorithm adopts a different approach, instead opting to choose the minimum edge that would not introduce a cycle.
</p>

<p>
<span
    id="lateximage-index-5"
    class="lateximagesource"
><!--
    1
a       b
    3
4       2


c   5   d
--><img
    src="index-images/image-5.svg"
    alt="(-tikz-&nbsp;diagram)"
    style=""
    class="lateximage"
></span>
</p>

<p>
Kruskal’s algorithm would execute the following steps:
</p>

<ul class="enumerate" style="list-style-type:none">

<li>
<p>
<span class="listmarker">1.</span> Choose \((a, b)\), since it is the minimum cost edge
</p>

</li>
<li>

<p>
<span class="listmarker">2.</span> Choose \((b, d)\), since no cycle is produced
</p>

</li>
<li>

<p>
<span class="listmarker">3.</span> Choose \((d, e)\), since \((a, c)\) would produce a cycle
</p>

</li>
<li>

<p>
<span class="listmarker">4.</span> The chosen edges form a spanning tree of minimum cost!
</p>
</li>
</ul>

<figure id="autoid-9" class="figure ">
<div class="center">

<p>
<span
    id="lateximage-index-6"
    class="lateximagesource"
><!--
        1
a           b
4               2

    c       d
--><img
    src="index-images/image-6.svg"
    alt="(-tikz-&nbsp;diagram)"
    style=""
    class="lateximage"
></span>
</p>

<div class="figurecaption">
<p>
Figure&nbsp;3:&nbsp;Minimum spanning tree
</p>
</div>

<a id="fig:kruskal-mst"></a>

</div>

</figure>

<p>
In a real program, we sort the edges of the input graph \(G\) by weight as a pre-processing step to avoid quadratic searches for successive minima.
</p>

<figure id="autoid-10" class="algorithm ruled">

<div class="figurecaption">
<p>
Algorithm&nbsp;7:&nbsp;Kruskal’s Algorithm
</p>
</div>
<ul class="list" style="list-style-type:none">

<li>
<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span>\(T = \emptyset \)
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span>sort \(E\) by edge weight
</p>

</li>
<li>

<p>
<span class="listmarker"></span>
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>for</b> \((v, w) \in E\) <b>do</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>        <span style="width:12pt; display:inline-block;"></span><b>if</b> \((v, w)\) does not produce a cycle in \(T\) <b>then</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>           <span style="width:24pt; display:inline-block;"></span>add \((v, w)\) to \(T\)
</p>

</li>
<li>

<p>
<span class="listmarker"></span>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>        <span style="width:12pt; display:inline-block;"></span><b>end</b> <b>if</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>end</b> <b>for</b><b>return</b> \(T\)
</p>
</li>
</ul>

</figure>
<!--
...... subsubsection Analysis ......
-->
<h6 id="autosec-76">Analysis</h6>
<a id="index-autopage-76"></a>


<p>
Sorting the edges takes \(O(n\log n)\) time. Cycle detection in the inner loop dominates the runtime of naive Kruskal’s and therefore the overall runtime is subject to the implementation details. For a brute-force cycle detection approach, the inner loop runs \(O(|E||E +
V|) = O(|E||V|)\) time.
</p>

<p>
By using a Union-Find data structure, we can dramatically improve the runtime. In particular by implementing optimizations such as Path Compression and Union-by-Rank
</p>

<p>
> TODO: Do the detailed analysis later, (Inverse Ackermann)
</p>
<!--
...... subsection Huffman Codes ......
-->
<h5 id="autosec-77">Huffman Codes</h5>
<a id="index-autopage-77"></a>


<p>
Invented by David Huffman in the 50s as a way to compute the optimal prefix-free variable length encoding for a (mathematical) language \(\sum \). The algorithm constructs a tree from the ”bottom up”, repeatedly merging the least frequently occurring codes in order
to ensure the most frequently occurring have minimum possible depth.
</p>

<figure id="autoid-11" class="algorithm ruled">

<div class="figurecaption">
<p>
Algorithm&nbsp;8:&nbsp;Huffman Encoding
</p>
</div>
<ul class="list" style="list-style-type:none">

<li>
<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span>\(H = \emptyset \)
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>for</b> symbol \(\sigma \in \sum \) <b>do</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>       <span style="width:12pt; display:inline-block;"></span>\({T_\sigma } = (\sigma , P_\sigma )\)
</p>

</li>
<li>

<p>
<span class="listmarker"></span>       <span style="width:12pt; display:inline-block;"></span>\(H = H \cup T_\sigma \)
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>end</b> <b>for</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>while</b> There is more than one \(T_\sigma \in H\) <b>do</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>       <span style="width:12pt; display:inline-block;"></span>\(T_1\) = tree with minimum frequency
</p>

</li>
<li>

<p>
<span class="listmarker"></span>       <span style="width:12pt; display:inline-block;"></span>\(T_2\) = tree with 2nd smallest frequency
</p>

</li>
<li>

<p>
<span class="listmarker"></span>       <span style="width:12pt; display:inline-block;"></span>\(T_3\) = <span class="textsc">MergeTrees</span>(\(T_1, T_2\))
</p>

</li>
<li>

<p>
<span class="listmarker"></span>       <span style="width:12pt; display:inline-block;"></span>\(H = H \cup T_3\)
</p>

</li>
<li>

<p>
<span class="listmarker"></span>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>end</b> <b>while</b>
</p>
</li>
</ul>

</figure>

<p>
For example, given the frequencies:
</p>
<table>

<tr style="display:none"><th>.</th></tr>

<tr class="hline">
<td class="tdc tvertbarl tvertbarr" style="border-left: 1px solid black; border-right: 1px solid black">Symbol</td>
<td class="tdr tvertbarr" style="border-right: 1px solid black">Frequency</td>
</tr>

<tr class="hline">
<td class="tdc tvertbarl tvertbarr" style="border-left: 1px solid black; border-right: 1px solid black">a</td>
<td class="tdr tvertbarr" style="border-right: 1px solid black">0.60</td>
</tr>

<tr class="hline">
<td class="tdc tvertbarl tvertbarr" style="border-left: 1px solid black; border-right: 1px solid black">b</td>
<td class="tdr tvertbarr" style="border-right: 1px solid black">0.25</td>
</tr>

<tr class="hline">
<td class="tdc tvertbarl tvertbarr" style="border-left: 1px solid black; border-right: 1px solid black">c</td>
<td class="tdr tvertbarr" style="border-right: 1px solid black">0.10</td>
</tr>

<tr class="hline">
<td class="tdc tvertbarl tvertbarr" style="border-left: 1px solid black; border-right: 1px solid black">d</td>
<td class="tdr tvertbarr" style="border-right: 1px solid black">0.05</td>
</tr>

<tr class="hline" aria-hidden="true">
<td class="tdc"></td>
<td class="tdr"></td>
</tr>
</table>

<p>
Huffman’s greedy algorithm will produce the following encoding tree:
</p>

<figure id="autoid-12" class="figure ">
<div class="center">

<p>
<span
    id="lateximage-index-7"
    class="lateximagesource"
><!--
    0           1


a
            0               1


        b
                        0       1

                    c               d
--><img
    src="index-images/image-7.svg"
    alt="(-tikz-&nbsp;diagram)"
    style=""
    class="lateximage"
></span>
</p>

<div class="figurecaption">
<p>
Figure&nbsp;4:&nbsp;The output of Huffman’s greedy algorithm
</p>
</div>

<a id="fig:huffman_tree"></a>

</div>

</figure>

<p>
which ensures that symbol \(a\), the most frequently encountered will be the quickest to encode and decode since its depth in minimized in the output.
</p>
<!--
...... subsubsection Analysis ......
-->
<h6 id="autosec-82">Analysis</h6>
<a id="index-autopage-82"></a>


<p>
Preprocessing the nodes can be done quickly in \(O(n)\) time. The inner loop of the algorithm is bound by the time it takes to select a minimum, therefore, repeated brute-force searching for minima each iteration leads to a runtime of \(O(n^2)\).
</p>

<p>
Once again, the Heap data structure is a perfect fit for this kind of problem. A heap is initialized with the frequencies provided to the algorithm, and keeps track of the current minimum by re-balancing in \(O(\log n)\) time. This speeds up Huffman’s algorithm
tremendously, bringing the runtime down to \(O(n \log n)\).
</p>

</section>

</main>

</div>

<footer>

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

</footer>


<nav class="botnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|Divide-Conquer.html|-->

<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Anthony" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="Personal notes on Mathematics and Computer Science" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Notes on Everything — Divide and Conquer</title>
<link rel="stylesheet" type="text/css" href="lwarp.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
  subequations: "0",
  section: "",
  loader: {
    load: ['[tex]/tagformat', '[tex]/textmacros'],
  },
  startup: {
    ready() {
      // These would be replaced by import commands if you wanted to make
      // a proper extension.
      const Configuration = MathJax._.input.tex.Configuration.Configuration;
      const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
      const Macro = MathJax._.input.tex.Symbol.Macro;
      const TexError = MathJax._.input.tex.TexError.default;
      const ParseUtil = MathJax._.input.tex.ParseUtil.default;
      const expandable = MathJax._.util.Options.expandable;

       // Insert the replacement string into the TeX string, and check
       // that there haven't been too many maxro substitutions (prevents
       // infinite loops).
       const useArgument = (parser, text) => {
         parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
         parser.i = 0;
         if (++parser.macroCount > parser.configuration.options.maxMacros) {
           throw new TexError('MaxMacroSub1',
           'MathJax maximum macro substitution count exceeded; ' +
           'is there a recursive macro call?');
         }
       }

       // Create the command map for:
       //     \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
       new CommandMap('Lwarp-macros', {
         ifstar: 'IfstarFunction',
         ifnextchar: 'IfnextcharFunction',
         ifblank: 'IfblankFunction',
         ifstrequal: 'IfstrequalFunction',
         gsubstitute: 'GsubstituteFunction',
         seteqnumber: 'SeteqnumberFunction'
       }, {
         // This function implements an ifstar macro.
         IfstarFunction(parser, name) {
            const resultstar = parser.GetArgument(name);
            const resultnostar = parser.GetArgument(name);
            const star = parser.GetStar();                 // true if there is a *
            useArgument(parser, star ? resultstar : resultnostar);
         },

          // This function implements an ifnextchar macro.
          IfnextcharFunction(parser, name) {
            let whichchar = parser.GetArgument(name);
            if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
              // $ syntax highlighting
              whichchar = String.fromCodePoint(parseInt(whichchar));
            }
            const resultnextchar = parser.GetArgument(name);
            const resultnotnextchar = parser.GetArgument(name);
            const gotchar = (parser.GetNext() === whichchar);
            useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
          },

          // This function implements an ifblank macro.
          IfblankFunction(parser, name) {
            const blankarg = parser.GetArgument(name);
            const resultblank = parser.GetArgument(name);
            const resultnotblank = parser.GetArgument(name);
            const isblank = (blankarg.trim() == "");
            useArgument(parser, isblank ? resultblank : resultnotblank);
          },

          // This function implements an ifstrequal macro.
          IfstrequalFunction(parser, name) {
            const strequalfirst = parser.GetArgument(name);
            const strequalsecond = parser.GetArgument(name);
            const resultequal = parser.GetArgument(name);
            const resultnotequal = parser.GetArgument(name);
            const isequal = (strequalfirst == strequalsecond);
            useArgument(parser, isequal ? resultequal : resultnotequal);
          },

          // This function implements a gsub macro.
          GsubstituteFunction(parser, name) {
            const gsubfirst = parser.GetArgument(name);
            const gsubsecond = parser.GetArgument(name);
            const gsubthird = parser.GetArgument(name);
            let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
            useArgument(parser, gsubresult);
          },

          // This function modifies the equation numbers.
          SeteqnumberFunction(parser, name) {
              // Get the macro parameters
              const star = parser.GetStar();                  // true if there is a *
              const optBrackets = parser.GetBrackets(name);   // contents of optional brackets
              const newsubequations = parser.GetArgument(name); // the subequations argument
              const neweqsection = parser.GetArgument(name); // the eq section argument
              const neweqnumber = parser.GetArgument(name);   // the eq number argument
              MathJax.config.subequations=newsubequations ;   // a string with boolean meaning
              MathJax.config.section=neweqsection ;           // a string with numeric meaning
              parser.tags.counter = parser.tags.allCounter = neweqnumber ;
          }

       });

       // Create the Lwarp-macros package
       Configuration.create('Lwarp-macros', {
         handler: {macro: ['Lwarp-macros']}
       });

       MathJax.startup.defaultReady();

       // For forward references:
       MathJax.startup.input[0].preFilters.add(({math}) => {
         if (math.inputData.recompile){
             MathJax.config.subequations = math.inputData.recompile.subequations;
             MathJax.config.section = math.inputData.recompile.section;
         }
       });
       MathJax.startup.input[0].postFilters.add(({math}) => {
         if (math.inputData.recompile){
             math.inputData.recompile.subequations = MathJax.config.subequations;
             math.inputData.recompile.section = MathJax.config.section;
         }
       });

         // For \left, \right with unicode-math:
         const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
         const {Symbol} = MathJax._.input.tex.Symbol;
         const {MapHandler} = MathJax._.input.tex.MapHandler;
         const delimiter = MapHandler.getMap('delimiter');
         delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
         delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
         delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
         delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
         delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
         delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
         delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
         delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
         delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
         delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
         delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
         delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
         delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
         delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
         delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
         delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
         delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
         delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
         delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
         delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
         delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
         delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
         delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
         delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
         delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
         delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
         delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
         delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
         delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
         delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
         delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
         delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
         delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
         delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
         delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
         delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
         delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
         delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
         delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
   }     // ready
 },      // startup

 tex: {
   packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
   tags: "ams",
        tagformat: {
            number: function (n) {
                if(MathJax.config.subequations==0)
                    return(MathJax.config.section + n);
                else
                    return(MathJax.config.section + String.fromCharCode(96+n));
            },
        },
 }
}
</script>

<script
    id="MathJax-script"
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="index-autopage-83"></a>
<nav class="topnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Notes on Everything</span>
</p>

<p>
Subjects
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="Sums.html#autosec-6" class="tocchapter" >
Sums</a>
</p>


<p>
<a href="Sums.html#autosec-7" class="tocsection" >
Manipulating Sums</a>
</p>


<p>
<a href="Sums.html#autosec-8" class="tocsubsection" >
Basic Rules</a>
</p>


<p>
<a href="Sums.html#autosec-10" class="tocsubsection" >
Iverson Notation</a>
</p>


<p>
<a href="Sums.html#autosec-13" class="tocsubsection" >
Perturbing the Sum</a>
</p>


<p>
<a href="Sums.html#autosec-16" class="tocsubsection" >
Multiple Sums</a>
</p>


<p>
<a href="Finite-Calculus.html#autosec-24" class="tocsection" >
Finite Calculus</a>
</p>


<p>
<a href="Finite-Calculus.html#autosec-25" class="tocsubsection" >
The Difference Operator</a>
</p>


<p>
<a href="Finite-Calculus.html#autosec-26" class="tocsubsection" >
Rising and Falling Factorials</a>
</p>


<p>
<a href="Algorithms.html#autosec-30" class="tocchapter" >
Algorithms</a>
</p>


<p>
<a href="Algorithms.html#autosec-31" class="tocsection" >
Graphs</a>
</p>


<p>
<a href="Algorithms.html#autosec-32" class="tocsubsection" >
Cuts</a>
</p>


<p>
<a href="Algorithms.html#autosec-42" class="tocsubsection" >
Depth-First Search</a>
</p>


<p>
<a href="Algorithms.html#autosec-44" class="tocsubsection" >
Breadth-First Search</a>
</p>


<p>
<a href="Algorithms.html#autosec-46" class="tocsubsection" >
Topological Ordering</a>
</p>


<p>
<a href="Algorithms.html#autosec-47" class="tocsubsection" >
Strongly Connected Components</a>
</p>


<p>
<a href="Greedy.html#autosec-49" class="tocsection" >
Greedy</a>
</p>


<p>
<a href="Greedy.html#autosec-50" class="tocsubsection" >
Dijkstra’s Shortest Path Algorithm</a>
</p>


<p>
<a href="Greedy.html#autosec-61" class="tocsubsection" >
Prim’s MST Algorithm</a>
</p>


<p>
<a href="Greedy.html#autosec-70" class="tocsubsection" >
Kruskal’s MST Algorithm</a>
</p>


<p>
<a href="Greedy.html#autosec-77" class="tocsubsection" >
Huffman Codes</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-84" class="tocsection" >
Divide and Conquer</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-85" class="tocsubsection" >
Master Theorem</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-87" class="tocsubsection" >
MergeSort</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-89" class="tocsubsection" >
Counting Array Inversions</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-92" class="tocsubsection" >
Karatsuba Multiplication</a>
</p>


<p>
<a href="Combinatorics.html#autosec-94" class="tocchapter" >
Combinatorics</a>
</p>


<p>
<a href="Combinatorics.html#autosec-95" class="tocsection" >
Basics of Counting</a>
</p>


<p>
<a href="Combinatorics.html#autosec-96" class="tocsubsection" >
Product Rule</a>
</p>


<p>
<a href="Combinatorics.html#autosec-99" class="tocsubsection" >
Complement Rule</a>
</p>


<p>
<a href="Combinatorics.html#autosec-103" class="tocsubsection" >
Inclusion/Exclusion</a>
</p>


<p>
<a href="Combinatorics.html#autosec-106" class="tocsubsection" >
Permutations</a>
</p>


<p>
<a href="Probability.html#autosec-109" class="tocchapter" >
Probability</a>
</p>


<p>
<a href="Probability.html#autosec-110" class="tocsection" >
Basics</a>
</p>


<p>
<a href="Probability.html#autosec-111" class="tocsubsection" >
Terminology</a>
</p>


<p>
<a href="Probability.html#autosec-113" class="tocsubsection" >
Naive Definition of Probability</a>
</p>


<p>
<a href="Probability.html#autosec-115" class="tocsubsection" >
Non-Naive Definition of Probability</a>
</p>


<p>
<a href="Foundations.html#autosec-120" class="tocchapter" >
Foundations</a>
</p>


<p>
<a href="Foundations.html#autosec-121" class="tocsection" >
Set Theory</a>
</p>


<p>
<a href="Foundations.html#autosec-125" class="tocsubsection" >
Basic Definitions</a>
</p>


<p>
<a href="Foundations.html#autosec-126" class="tocsubsection" >
Laws</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-152" class="tocsection" >
Factoring Tricks</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-153" class="tocsubsection" >
Basic Identities</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-154" class="tocsubsection" >
Splitting Apart a Monomial</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-155" class="tocsubsection" >
Adding Zero</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-156" class="tocsubsection" >
\((a^n - b^n) \)</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-158" class="tocsubsection" >
\((a^n + b^n) \)</a>
</p>


<p>
<a href="Quadratics.html#autosec-162" class="tocsection" >
Quadratics</a>
</p>


<p>
<a href="Quadratics.html#autosec-163" class="tocsubsection" >
Finding Roots of a Quadratic Function</a>
</p>


<p>
<a href="Quadratics.html#autosec-169" class="tocsubsection" >
Vieta’s Theorem</a>
</p>


<p>
<a href="Quadratics.html#autosec-172" class="tocsubsection" >
The Quadratic Formula</a>
</p>


</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<h1>Notes on Everything</h1>

<!--MathJax customizations:-->
<div data-nosnippet
    style="display:none"
>

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

</div>

<!--
...... section Divide and Conquer ......
-->
<h4 id="autosec-84">Divide and Conquer</h4>
<a id="index-autopage-84"></a>
<a id="index-autofile-5"></a>

<p>
Divide and conquer algorithms are characterized by a procedure which breaks a problem into distinct subproblems (divide) and produces the solution to the overall problem by combining the results of the subproblems (conquer).
</p>

<p>
This paradigm differs from Dynamic Programming in that the subproblems produced by the divide step are usually independent.
</p>
<!--
...... subsection Master Theorem ......
-->
<h5 id="autosec-85">Master Theorem</h5>
<a id="index-autopage-85"></a>


<p>
The master theorem is a concise summary of the runtime of certain specific recurrences which come about naturally in divide-and-conquer algorithms. This is mainly a shortcut to avoid the verbose computation of determining the value of a geometric series.
</p>

<p>
Let \(T(n)\) be a recurrence with upper bound defined as follows:
</p>

<p>
\[ T(n) \leqslant a \cdot T(\frac n b) + O(n^d) \]
</p>

<p>
Then we have,
</p>

<p>
\[ T(n) = \begin {cases} O(n^d \log n) &amp; \text {if $a = b^d$} \\ O(n^d) &amp; \text {if $a &lt; b^d$} \\ O(n^{\log _b a}) &amp; \text {if $a &gt; b^d$} \\ \end {cases} \]
</p>

<p>
Where
</p>
<ul class="itemize" style="list-style-type:none">

<li>
<p>
<span class="listmarker">•</span> \(a\) Is the number of recursive calls,
</p>

</li>
<li>

<p>
<span class="listmarker">•</span> \(b\) Is the decrease in the size of a subproblem in a recursive call, and
</p>

</li>
<li>

<p>
<span class="listmarker">•</span> \(d\) Is the order of the work performed for each subproblem
</p>
</li>
</ul>

<p>
The runtimes follow naturally from reasoning about the upper bound in each case.
</p>
<!--
...... subsubsection Proof ......
-->
<h6 id="autosec-86">Proof</h6>
<a id="index-autopage-86"></a>


<p>
TODO
</p>
<!--
...... subsection MergeSort ......
-->
<h5 id="autosec-87">MergeSort</h5>
<a id="index-autopage-87"></a>


<p>
Probably the most famous divide and conquer algorithm. The core idea behind MergeSort is to repeatedly bisect an array until reaching a trivial sorting problem of one element and then recursively merge each subarray, placing the element in ascending order in the final
output.
</p>

<figure id="autoid-13" class="algorithm ruled">

<div class="figurecaption">
<p>
Algorithm&nbsp;9:&nbsp;MergeSort
</p>
</div>
<ul class="list" style="list-style-type:none">

<li>
<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>procedure</b> <span class="textsc">Merge</span>(\(A, B\))
</p>

</li>
<li>

<p>
<span class="listmarker"></span>        <span style="width:12pt; display:inline-block;"></span>\(i = 0, j = 0\)
</p>

</li>
<li>

<p>
<span class="listmarker"></span>        <span style="width:12pt; display:inline-block;"></span>\(C = []\)
</p>

</li>
<li>

<p>
<span class="listmarker"></span>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>        <span style="width:12pt; display:inline-block;"></span><b>for</b> \(k = 0\) To \(n-1\) <b>do</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>           <span style="width:24pt; display:inline-block;"></span><b>if</b> \(A[i] &lt; B[j]\) <b>then</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>              <span style="width:36pt; display:inline-block;"></span>\(C[k] = A[i]\)
</p>

</li>
<li>

<p>
<span class="listmarker"></span>              <span style="width:36pt; display:inline-block;"></span>\(i = i + 1\)
</p>

</li>
<li>

<p>
<span class="listmarker"></span>           <span style="width:24pt; display:inline-block;"></span><b>else</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>              <span style="width:36pt; display:inline-block;"></span>\(C[k] = B[j]\)
</p>

</li>
<li>

<p>
<span class="listmarker"></span>              <span style="width:36pt; display:inline-block;"></span>\(j = j + 1\)
</p>

</li>
<li>

<p>
<span class="listmarker"></span>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>           <span style="width:24pt; display:inline-block;"></span><b>end</b> <b>if</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>        <span style="width:12pt; display:inline-block;"></span><b>end</b> <b>for</b><b>return</b> \(C\)
</p>

</li>
<li>

<p>
<span class="listmarker"></span>
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>end</b> <b>procedure</b>
</p>
</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>procedure</b> <span class="textsc">MergeSort</span>(\(A\))
</p>

</li>
<li>

<p>
<span class="listmarker"></span>        <span style="width:12pt; display:inline-block;"></span><b>if</b> \(len(A) \leqslant 1\) <b>then</b> <b>return</b> \(A\)
</p>

</li>
<li>

<p>
<span class="listmarker"></span>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>        <span style="width:12pt; display:inline-block;"></span><b>end</b> <b>if</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>        <span style="width:12pt; display:inline-block;"></span>\(L =\) <span class="textsc">MergeSort</span>(left half of \(A\))
</p>

</li>
<li>

<p>
<span class="listmarker"></span>        <span style="width:12pt; display:inline-block;"></span>\(R =\) <span class="textsc">MergeSort</span>(right half of \(A\))
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <b>return</b> <span class="textsc">Merge</span>(\(L, R\))
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>end</b> <b>procedure</b>
</p>
</li>
</ul>

</figure>
<!--
...... subsubsection Analysis ......
-->
<h6 id="autosec-88">Analysis</h6>
<a id="index-autopage-88"></a>


<p>
From the pseudocode, we see there are 2 recursive calls per iteration, each dividing the input in half. Additionally, the ‘Merge‘ routine performs linear work per call, leading to the following recurrence:
</p>

<p>
\[ T(n) \leqslant 2 \cdot T(\frac n 2) + O(n) \]
</p>

<p>
Applying the master theorem with \(a = 2 = 2^1 = b^d\), we arrive at a runtime of \(O(n\log n)\).
</p>
<!--
...... subsection Counting Array Inversions ......
-->
<h5 id="autosec-89">Counting Array Inversions</h5>
<a id="index-autopage-89"></a>


<p>
Array inversions are the number of ”out of place” element with respect to the sorted list. For example,
</p>
<pre class="verbatim">
  A = [3, 1, 2]

</pre>

<p>
has 2 inversions. The trivial brute-force solution involves comparing every element against the rest of the \(n-1\) items, leading to a quadratic runtime.
</p>

<p>
The divide-and-conquer approach employs the generally useful idea of counting the inversions in the left and right subhalves as well as those than span the middle of the array. The following strategy sorts each subarray, counting the split inversions during the combine step.
</p>

<figure id="autoid-14" class="algorithm ruled">

<div class="figurecaption">
<p>
Algorithm&nbsp;10:&nbsp;Count Inversions
</p>
</div>
<ul class="list" style="list-style-type:none">

<li>
<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>procedure</b> <span class="textsc">CountSplitInv</span>(\(A, B\))
</p>

</li>
<li>

<p>
<span class="listmarker"></span>        <span style="width:12pt; display:inline-block;"></span>i = j = 0
</p>

</li>
<li>

<p>
<span class="listmarker"></span>        <span style="width:12pt; display:inline-block;"></span>inv = 0
</p>

</li>
<li>

<p>
<span class="listmarker"></span>        <span style="width:12pt; display:inline-block;"></span>Out = []
</p>

</li>
<li>

<p>
<span class="listmarker"></span>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>        <span style="width:12pt; display:inline-block;"></span><b>for</b> \(k\) To \(n-1\) <b>do</b> <span class="floatright">&#x25B7; No Inversion</span>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>            <span style="width:24pt; display:inline-block;"></span><b>if</b> A[i] < B[j] <b>then</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>               <span style="width:36pt; display:inline-block;"></span>Out[k] = B[j]
</p>

</li>
<li>

<p>
<span class="listmarker"></span>               <span style="width:36pt; display:inline-block;"></span>i = i + 1
</p>

</li>
<li>

<p>
<span class="listmarker"></span>            <span style="width:24pt; display:inline-block;"></span><b>else</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>               <span style="width:36pt; display:inline-block;"></span>Out[k] = A[j]
</p>

</li>
<li>

<p>
<span class="listmarker"></span>               <span style="width:36pt; display:inline-block;"></span>j = j + 1
</p>

</li>
<li>

<p>
<span class="listmarker"></span>               <span style="width:36pt; display:inline-block;"></span>inv = inv + (n - i)
</p>

</li>
<li>

<p>
<span class="listmarker"></span>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>            <span style="width:24pt; display:inline-block;"></span><b>end</b> <b>if</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>        <span style="width:12pt; display:inline-block;"></span><b>end</b> <b>for</b><b>return</b> (Out, inv)
</p>

</li>
<li>

<p>
<span class="listmarker"></span>
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>end</b> <b>procedure</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>procedure</b> <span class="textsc">CountInv</span>(\(A\))
</p>

</li>
<li>

<p>
<span class="listmarker"></span>        <span style="width:12pt; display:inline-block;"></span><b>if</b> \(n \leqslant 1\) <b>then</b> <b>return</b> (A, 0)
</p>

</li>
<li>

<p>
<span class="listmarker"></span>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>        <span style="width:12pt; display:inline-block;"></span><b>end</b> <b>if</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>        <span style="width:12pt; display:inline-block;"></span>(L, leftInv) = <span class="textsc">CountInv</span>(left half of \(A\))
</p>

</li>
<li>

<p>
<span class="listmarker"></span>        <span style="width:12pt; display:inline-block;"></span>(R, rightInv) = <span class="textsc">CountInv</span>(right half of \(A\))
</p>

</li>
<li>

<p>
<span class="listmarker"></span>        <span style="width:12pt; display:inline-block;"></span>(Merged, splitInv) = <span class="textsc">CountSplitInv</span>(L, R)
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <b>return</b> (Merged, leftInv + rightInv + splitInv)
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>end</b> <b>procedure</b>
</p>
</li>
</ul>

</figure>
<!--
...... subsubsection Analysis ......
-->
<h6 id="autosec-91">Analysis</h6>
<a id="index-autopage-91"></a>


<p>
Similar to <b>MergeSort</b>, we see two recursive calls and linear work per recursive iteration:
</p>

<p>
\[ T(n) \leqslant 2 \cdot T(\frac n 2) + O(n) \]
</p>

<p>
And therefore <b>CountInv</b> has a runtime of \(O(n \log n)\) as well.
</p>
<!--
...... subsection Karatsuba Multiplication ......
-->
<h5 id="autosec-92">Karatsuba Multiplication</h5>
<a id="index-autopage-92"></a>


<p>
Anatoly Karatsuba invented this algorithm as a faster way to multiply very large integers. This happens to be the multiplication algorithm used by Python. The idea behind the algorithm is to recursively split apart each integer into halves until they are small enough to
be multiplied in constant time with the normal ‘*‘ operator.
</p>

<p>
The combine step involves some manipulation of the quadratic identity.
</p>

<figure id="autoid-15" class="algorithm ruled">

<div class="figurecaption">
<p>
Algorithm&nbsp;11:&nbsp;Karatsuba
</p>
</div>
<ul class="list" style="list-style-type:none">

<li>
<p>
<span class="listmarker"><b>Require:</b></span> \(x\) and \(y\) have the same number of digits
</p>
</li>
</ul>

</figure>

</section>

</main>

</div>

<footer>

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

</footer>


<nav class="botnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|Combinatorics.html|-->

<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Anthony" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="Personal notes on Mathematics and Computer Science" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Notes on Everything — Combinatorics</title>
<link rel="stylesheet" type="text/css" href="lwarp.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
  subequations: "0",
  section: "",
  loader: {
    load: ['[tex]/tagformat', '[tex]/textmacros'],
  },
  startup: {
    ready() {
      // These would be replaced by import commands if you wanted to make
      // a proper extension.
      const Configuration = MathJax._.input.tex.Configuration.Configuration;
      const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
      const Macro = MathJax._.input.tex.Symbol.Macro;
      const TexError = MathJax._.input.tex.TexError.default;
      const ParseUtil = MathJax._.input.tex.ParseUtil.default;
      const expandable = MathJax._.util.Options.expandable;

       // Insert the replacement string into the TeX string, and check
       // that there haven't been too many maxro substitutions (prevents
       // infinite loops).
       const useArgument = (parser, text) => {
         parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
         parser.i = 0;
         if (++parser.macroCount > parser.configuration.options.maxMacros) {
           throw new TexError('MaxMacroSub1',
           'MathJax maximum macro substitution count exceeded; ' +
           'is there a recursive macro call?');
         }
       }

       // Create the command map for:
       //     \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
       new CommandMap('Lwarp-macros', {
         ifstar: 'IfstarFunction',
         ifnextchar: 'IfnextcharFunction',
         ifblank: 'IfblankFunction',
         ifstrequal: 'IfstrequalFunction',
         gsubstitute: 'GsubstituteFunction',
         seteqnumber: 'SeteqnumberFunction'
       }, {
         // This function implements an ifstar macro.
         IfstarFunction(parser, name) {
            const resultstar = parser.GetArgument(name);
            const resultnostar = parser.GetArgument(name);
            const star = parser.GetStar();                 // true if there is a *
            useArgument(parser, star ? resultstar : resultnostar);
         },

          // This function implements an ifnextchar macro.
          IfnextcharFunction(parser, name) {
            let whichchar = parser.GetArgument(name);
            if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
              // $ syntax highlighting
              whichchar = String.fromCodePoint(parseInt(whichchar));
            }
            const resultnextchar = parser.GetArgument(name);
            const resultnotnextchar = parser.GetArgument(name);
            const gotchar = (parser.GetNext() === whichchar);
            useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
          },

          // This function implements an ifblank macro.
          IfblankFunction(parser, name) {
            const blankarg = parser.GetArgument(name);
            const resultblank = parser.GetArgument(name);
            const resultnotblank = parser.GetArgument(name);
            const isblank = (blankarg.trim() == "");
            useArgument(parser, isblank ? resultblank : resultnotblank);
          },

          // This function implements an ifstrequal macro.
          IfstrequalFunction(parser, name) {
            const strequalfirst = parser.GetArgument(name);
            const strequalsecond = parser.GetArgument(name);
            const resultequal = parser.GetArgument(name);
            const resultnotequal = parser.GetArgument(name);
            const isequal = (strequalfirst == strequalsecond);
            useArgument(parser, isequal ? resultequal : resultnotequal);
          },

          // This function implements a gsub macro.
          GsubstituteFunction(parser, name) {
            const gsubfirst = parser.GetArgument(name);
            const gsubsecond = parser.GetArgument(name);
            const gsubthird = parser.GetArgument(name);
            let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
            useArgument(parser, gsubresult);
          },

          // This function modifies the equation numbers.
          SeteqnumberFunction(parser, name) {
              // Get the macro parameters
              const star = parser.GetStar();                  // true if there is a *
              const optBrackets = parser.GetBrackets(name);   // contents of optional brackets
              const newsubequations = parser.GetArgument(name); // the subequations argument
              const neweqsection = parser.GetArgument(name); // the eq section argument
              const neweqnumber = parser.GetArgument(name);   // the eq number argument
              MathJax.config.subequations=newsubequations ;   // a string with boolean meaning
              MathJax.config.section=neweqsection ;           // a string with numeric meaning
              parser.tags.counter = parser.tags.allCounter = neweqnumber ;
          }

       });

       // Create the Lwarp-macros package
       Configuration.create('Lwarp-macros', {
         handler: {macro: ['Lwarp-macros']}
       });

       MathJax.startup.defaultReady();

       // For forward references:
       MathJax.startup.input[0].preFilters.add(({math}) => {
         if (math.inputData.recompile){
             MathJax.config.subequations = math.inputData.recompile.subequations;
             MathJax.config.section = math.inputData.recompile.section;
         }
       });
       MathJax.startup.input[0].postFilters.add(({math}) => {
         if (math.inputData.recompile){
             math.inputData.recompile.subequations = MathJax.config.subequations;
             math.inputData.recompile.section = MathJax.config.section;
         }
       });

         // For \left, \right with unicode-math:
         const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
         const {Symbol} = MathJax._.input.tex.Symbol;
         const {MapHandler} = MathJax._.input.tex.MapHandler;
         const delimiter = MapHandler.getMap('delimiter');
         delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
         delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
         delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
         delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
         delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
         delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
         delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
         delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
         delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
         delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
         delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
         delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
         delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
         delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
         delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
         delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
         delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
         delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
         delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
         delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
         delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
         delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
         delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
         delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
         delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
         delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
         delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
         delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
         delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
         delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
         delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
         delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
         delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
         delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
         delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
         delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
         delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
         delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
         delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
   }     // ready
 },      // startup

 tex: {
   packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
   tags: "ams",
        tagformat: {
            number: function (n) {
                if(MathJax.config.subequations==0)
                    return(MathJax.config.section + n);
                else
                    return(MathJax.config.section + String.fromCharCode(96+n));
            },
        },
 }
}
</script>

<script
    id="MathJax-script"
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="index-autopage-93"></a>
<nav class="topnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Notes on Everything</span>
</p>

<p>
Subjects
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="Sums.html#autosec-6" class="tocchapter" >
Sums</a>
</p>


<p>
<a href="Sums.html#autosec-7" class="tocsection" >
Manipulating Sums</a>
</p>


<p>
<a href="Sums.html#autosec-8" class="tocsubsection" >
Basic Rules</a>
</p>


<p>
<a href="Sums.html#autosec-10" class="tocsubsection" >
Iverson Notation</a>
</p>


<p>
<a href="Sums.html#autosec-13" class="tocsubsection" >
Perturbing the Sum</a>
</p>


<p>
<a href="Sums.html#autosec-16" class="tocsubsection" >
Multiple Sums</a>
</p>


<p>
<a href="Finite-Calculus.html#autosec-24" class="tocsection" >
Finite Calculus</a>
</p>


<p>
<a href="Finite-Calculus.html#autosec-25" class="tocsubsection" >
The Difference Operator</a>
</p>


<p>
<a href="Finite-Calculus.html#autosec-26" class="tocsubsection" >
Rising and Falling Factorials</a>
</p>


<p>
<a href="Algorithms.html#autosec-30" class="tocchapter" >
Algorithms</a>
</p>


<p>
<a href="Algorithms.html#autosec-31" class="tocsection" >
Graphs</a>
</p>


<p>
<a href="Algorithms.html#autosec-32" class="tocsubsection" >
Cuts</a>
</p>


<p>
<a href="Algorithms.html#autosec-42" class="tocsubsection" >
Depth-First Search</a>
</p>


<p>
<a href="Algorithms.html#autosec-44" class="tocsubsection" >
Breadth-First Search</a>
</p>


<p>
<a href="Algorithms.html#autosec-46" class="tocsubsection" >
Topological Ordering</a>
</p>


<p>
<a href="Algorithms.html#autosec-47" class="tocsubsection" >
Strongly Connected Components</a>
</p>


<p>
<a href="Greedy.html#autosec-49" class="tocsection" >
Greedy</a>
</p>


<p>
<a href="Greedy.html#autosec-50" class="tocsubsection" >
Dijkstra’s Shortest Path Algorithm</a>
</p>


<p>
<a href="Greedy.html#autosec-61" class="tocsubsection" >
Prim’s MST Algorithm</a>
</p>


<p>
<a href="Greedy.html#autosec-70" class="tocsubsection" >
Kruskal’s MST Algorithm</a>
</p>


<p>
<a href="Greedy.html#autosec-77" class="tocsubsection" >
Huffman Codes</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-84" class="tocsection" >
Divide and Conquer</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-85" class="tocsubsection" >
Master Theorem</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-87" class="tocsubsection" >
MergeSort</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-89" class="tocsubsection" >
Counting Array Inversions</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-92" class="tocsubsection" >
Karatsuba Multiplication</a>
</p>


<p>
<a href="Combinatorics.html#autosec-94" class="tocchapter" >
Combinatorics</a>
</p>


<p>
<a href="Combinatorics.html#autosec-95" class="tocsection" >
Basics of Counting</a>
</p>


<p>
<a href="Combinatorics.html#autosec-96" class="tocsubsection" >
Product Rule</a>
</p>


<p>
<a href="Combinatorics.html#autosec-99" class="tocsubsection" >
Complement Rule</a>
</p>


<p>
<a href="Combinatorics.html#autosec-103" class="tocsubsection" >
Inclusion/Exclusion</a>
</p>


<p>
<a href="Combinatorics.html#autosec-106" class="tocsubsection" >
Permutations</a>
</p>


<p>
<a href="Probability.html#autosec-109" class="tocchapter" >
Probability</a>
</p>


<p>
<a href="Probability.html#autosec-110" class="tocsection" >
Basics</a>
</p>


<p>
<a href="Probability.html#autosec-111" class="tocsubsection" >
Terminology</a>
</p>


<p>
<a href="Probability.html#autosec-113" class="tocsubsection" >
Naive Definition of Probability</a>
</p>


<p>
<a href="Probability.html#autosec-115" class="tocsubsection" >
Non-Naive Definition of Probability</a>
</p>


<p>
<a href="Foundations.html#autosec-120" class="tocchapter" >
Foundations</a>
</p>


<p>
<a href="Foundations.html#autosec-121" class="tocsection" >
Set Theory</a>
</p>


<p>
<a href="Foundations.html#autosec-125" class="tocsubsection" >
Basic Definitions</a>
</p>


<p>
<a href="Foundations.html#autosec-126" class="tocsubsection" >
Laws</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-152" class="tocsection" >
Factoring Tricks</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-153" class="tocsubsection" >
Basic Identities</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-154" class="tocsubsection" >
Splitting Apart a Monomial</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-155" class="tocsubsection" >
Adding Zero</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-156" class="tocsubsection" >
\((a^n - b^n) \)</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-158" class="tocsubsection" >
\((a^n + b^n) \)</a>
</p>


<p>
<a href="Quadratics.html#autosec-162" class="tocsection" >
Quadratics</a>
</p>


<p>
<a href="Quadratics.html#autosec-163" class="tocsubsection" >
Finding Roots of a Quadratic Function</a>
</p>


<p>
<a href="Quadratics.html#autosec-169" class="tocsubsection" >
Vieta’s Theorem</a>
</p>


<p>
<a href="Quadratics.html#autosec-172" class="tocsubsection" >
The Quadratic Formula</a>
</p>


</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<h1>Notes on Everything</h1>

<!--MathJax customizations:-->
<div data-nosnippet
    style="display:none"
>

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

</div>

<!--
...... chapter Combinatorics ......
-->
<h3 id="autosec-94">Combinatorics</h3>
<a id="index-autopage-94"></a>
<a id="index-autofile-6"></a>
<!--
...... section Basics of Counting ......
-->
<h4 id="autosec-95">Basics of Counting</h4>
<a id="index-autopage-95"></a>


<p>
These are the basic ”rules” of counting. In general, counting using these rules involves modeling the problem as a correct sequence of choices and applying the appropriate strategy to the sequence.
</p>

<p>
Proofs of the basic counting principles are usually extremely heavy on notation and formalism. As such, they tend to be cryptic and not offer very much in the way of an intuitive understanding of combinatorics. Actually, as it turns out, not much can serve as a silver
bullet for imbuing the contrived way of thinking involved in solving difficult combinatorics problems.
</p>

<p>
Solving an absurd number of problems is just about the only way to approach the subject unfortunately.
</p>
<!--
...... subsection Product Rule ......
-->
<h5 id="autosec-96">Product Rule</h5>
<a id="index-autopage-96"></a>


<p>
The Product rule is used when a counting problem is modeled after a sequence of choices. A heuristic for understanding when to use the product rule comes from comparing a situation to a logical and \(\land \) operator. In other words, if we need to pick among some
choices <em>and</em> some other choices, the total number of outcomes is given by multiplying them together.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><a id="index-autopage-97"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">3</span></span>. </span> Let \(A\) be a set of \(n\) outcomes and \(B\) be a set of \(m\) outcomes. The number of ways to choose an outcome of \(A\) and
an outcome of \(B\) is given by:
</p>

<span class="hidden"> \(\seteqnumber{0}{}{0}\)</span>

<!--


                                                                                                                  number of ways = n · m                                                                                                               (1)

-->

<p>


\begin{equation}
\text {number of ways} = n \cdot m
\end{equation}


</p>

<p>
generalizing over sets \(A_1, A_2, \dots , A_n\), the total number of outcomes is given by<sup>2</sup>:
</p>

<span class="hidden"> \(\seteqnumber{0}{}{1}\)</span>

<!--


                                                                                                                   |A1 | · |A2 | · · · · · |An |                                                                                                       (2)

-->

<p>


\begin{equation}
|A_1| \cdot |A_2| \cdot \dots \cdot |A_n|
\end{equation}


</p>

<p>


</p>

</li>

</ul>
<div role="note" class="footnotes">

<a id="index-autopage-98"></a>

<p>
<sup>2</sup>&nbsp;Unlike most of the other rules, the proof of the product rule is actually insightful, but sadly just as convoluted
</p>


</div>

</div>

<p>
This rule along with the Sum rule are the basis for virtually every counting problem. A good way to visualize the product rule is by considering the number of branches of a decision tree:
</p>
<!--
...... subsection Complement Rule ......
-->
<h5 id="autosec-99">Complement Rule</h5>
<a id="index-autopage-99"></a>


<p>
The Complement rule is helpful when expressing the size of a subset. The main idea here is to express the elements of \(A\) as a disjoint combination of \(U\) and \(A\). This comes in handy every once in a while in proofs.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><a id="index-autopage-100"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">4</span></span>. </span> Suppose \(A \subseteq B\), then
</p>

<p>
\[ |A| = |U| - |U - A| \]
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="index-autopage-101"></a>

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> Since this just involves some straightforward thinking about sets, we might as well go ahead and prove it. Thinking through the notation slowly, all we do in the righthand expression is
remove any element not in \(A\) from \(U\). This is because the elements we take away from \(U\) are those leftover from deleting the ones in \(A\).
</p>

<p>
Admittedly, this still takes a moment to sink in. Another way of expressing this identity is to realize that we’re just talking about integers, since the equation is in terms of the <em>sizes</em> of sets. We can use a little algebra to help out:
</p>

<span class="hidden"> \(\seteqnumber{0}{}{2}\)</span>


<!--



                                                                                                                                   a = u − (u − a)
                                                                                                                                     =u−u+a
                                                                                                                                     =a



-->


<p>


\begin{align*}
a &amp;= u - (u - a) \\ &amp;= u - u + a \\ &amp;= a
\end{align*}


</p>

<p>
Since \(A \subseteq U\), all of \(A\) is already inside of \(U\). Taking away any elements not in \(A\) leaves us with exactly \(A\). Here’s a formal way of saying that<sup>3</sup>:
</p>

<p>
Suppose \(A \subseteq U\). We will show both sides of the provided equation are subsets of one another, and therefore equal by set equality. Let \(x \in A\). Then \(x \in U\) by definition of subset, and likewise \(x \not in U - A\) by set subtraction. But then \(x
\in U - (U - A)\) since it will not be removed from \(U\) during the subtraction, and so \(A \subseteq U - (U - A)\).
</p>

<p>
Now suppose \(x \in U - (U - A)\). Then \(x \in U\) and not \(U - A\) by definition of set subtraction. But if \(x \not \in U - A\), then \(x \in A\). Therefore the righthand side is also a subset of \(A\), and the proof is complete. <span
class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>
<div role="note" class="footnotes">

<a id="index-autopage-102"></a>

<p>
<sup>3</sup>&nbsp;Actually, a subtle fact that’s glossed over here is that the theorem claims the sets are the same size. This demands that we establish a bijection between the sets, however, proving that they’re exactly the same set is (probably) good enough here
</p>


</div>

</div>
<!--
...... subsection Inclusion/Exclusion ......
-->
<h5 id="autosec-103">Inclusion/Exclusion</h5>
<a id="index-autopage-103"></a>


<p>
The Inclusion/Exclusion rule adjusts for overcounting the union of sets whose intersection is non-empty. The intuition is fairly straightforward; when taking the union of two non-disjoint sets, any element found in <em>both</em> sets will be double counted. To correct for
this misake, the inclusion/exclusion rule subtracts the intersection of the two elements, ensuring a given element is only ever counted once.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><a id="index-autopage-104"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">5</span></span>. </span> Suppose \(A\) and \(B\) are sets, not necessarily disjoint. The total number of elements in the union of \(A\) and \(B\) is given
by:
</p>

<p>
\[ |A \cup B| = |A| + |B| - |A \cap B| \]
</p>

<p>


</p>

</li>

</ul>

</div>

<p>
A special case arises when \(A\) and \(B\) are disjoint. This reduces the equation to \(|A \cup B| = |A| + |B|\) since \(|A \cap B|\) is empty, which clearly has no elements. This identity is called the <b>Sum Rule</b>. Most of the time, it’s a good idea to think in
terms of the inclusion/exclusion rule until confirming whether \(A\) and \(B\) have any shared elements.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><a id="index-autopage-105"></a>
<span class="amsthmnameplain">Example</span><span class="amsthmnumberplain"> <span class="textup">1</span></span>. </span> For example, let \(A = \{1, 2, 3\}, \; B = \{2, 3\}\). Since \(A\) and \(B\) are not disjoint, we only want to count the
elements in their union once:
</p>

<span class="hidden"> \(\seteqnumber{0}{}{2}\)</span>


<!--



                                                                                                                             A = {1, 2, 3}
                                                                                                                             B = {2, 3}
                                                                                                                         A ∪ B = {1, 2, 3, 2, 3}
                                                                                                                         A ∩ B = {2, 3}
                                                                                                             (A ∪ B) − (A ∩ B) = {1, 2, 3}



-->


<p>


\begin{align*}
A &amp;= \{1, 2, 3\} \\ B &amp;= \{2, 3\} \\ A \cup B &amp;= \{1, 2, 3, 2, 3\} \\ A \cap B &amp;= \{2, 3\} \\ (A \cup B) - (A \cap B) &amp;= \{1, 2, 3\}
\end{align*}


</p>

</li>

</ul>

</div>
<!--
...... subsection Permutations ......
-->
<h5 id="autosec-106">Permutations</h5>
<a id="index-autopage-106"></a>


<p>
We can think of a permutation of a sequence \(n\) as a particular ordering of its elements. We consider each ordering to be a unique object. Another way to think of a permutation is a function that sends an item located at index \(i\) to index \(j\) in the output.
</p>

<p>
for example, consider the string \(S = \text {abc}\). Then the permutations of \(S\) are:
</p>

<p>
\[ \{ abc, acb, bac, bca, cab, cba \} \]
</p>

<p>
The process of arranging the elements of \(S\) is called <b>permuting</b>.
</p>

<p>
The number of permutations a given string has can be modeled as a sequence of choices for the positions of each of its characters. For a string of length \(n\) there are initially \(n\) choices. After the first character is chosen, there are \(n-1\) choices, and so on. Using the
Product Rule:
</p>

<p>
\[ n(n-1)(n-2) \dots 1 = n! \]
</p>
<!--
...... subsubsection K-Permutations ......
-->
<h6 id="autosec-107">K-Permutations</h6>
<a id="index-autopage-107"></a>


<p>
A \(K\)-Permutation follows the same basic idea of a permutation. The goal here is to count the number of subsets of size \(K\) a given set.
</p>

<p>
(Permutations can be thought of as \(k\)-permutations where \(k=n\))
</p>

<p>
Let \(S = \text {abc}, \; k = 2\). Then the \(2\)-permutations of \(S\) are:
</p>

<p>
\[ \{ ab, ba, ac, ca, bc, cb \} \]
</p>

<p>
The formula for a \(k\)-permutation uses the product rule again, this time making choices on a sequence of length \(n-k+1\):
</p>

<p>
\[ (n)(n-1)(n-2)\dots (n-k+1) = \frac {n!} {(n-k)!} \]
</p>

</section>

</main>

</div>

<footer>

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

</footer>


<nav class="botnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|Probability.html|-->

<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Anthony" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="Personal notes on Mathematics and Computer Science" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Notes on Everything — Probability</title>
<link rel="stylesheet" type="text/css" href="lwarp.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
  subequations: "0",
  section: "",
  loader: {
    load: ['[tex]/tagformat', '[tex]/textmacros'],
  },
  startup: {
    ready() {
      // These would be replaced by import commands if you wanted to make
      // a proper extension.
      const Configuration = MathJax._.input.tex.Configuration.Configuration;
      const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
      const Macro = MathJax._.input.tex.Symbol.Macro;
      const TexError = MathJax._.input.tex.TexError.default;
      const ParseUtil = MathJax._.input.tex.ParseUtil.default;
      const expandable = MathJax._.util.Options.expandable;

       // Insert the replacement string into the TeX string, and check
       // that there haven't been too many maxro substitutions (prevents
       // infinite loops).
       const useArgument = (parser, text) => {
         parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
         parser.i = 0;
         if (++parser.macroCount > parser.configuration.options.maxMacros) {
           throw new TexError('MaxMacroSub1',
           'MathJax maximum macro substitution count exceeded; ' +
           'is there a recursive macro call?');
         }
       }

       // Create the command map for:
       //     \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
       new CommandMap('Lwarp-macros', {
         ifstar: 'IfstarFunction',
         ifnextchar: 'IfnextcharFunction',
         ifblank: 'IfblankFunction',
         ifstrequal: 'IfstrequalFunction',
         gsubstitute: 'GsubstituteFunction',
         seteqnumber: 'SeteqnumberFunction'
       }, {
         // This function implements an ifstar macro.
         IfstarFunction(parser, name) {
            const resultstar = parser.GetArgument(name);
            const resultnostar = parser.GetArgument(name);
            const star = parser.GetStar();                 // true if there is a *
            useArgument(parser, star ? resultstar : resultnostar);
         },

          // This function implements an ifnextchar macro.
          IfnextcharFunction(parser, name) {
            let whichchar = parser.GetArgument(name);
            if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
              // $ syntax highlighting
              whichchar = String.fromCodePoint(parseInt(whichchar));
            }
            const resultnextchar = parser.GetArgument(name);
            const resultnotnextchar = parser.GetArgument(name);
            const gotchar = (parser.GetNext() === whichchar);
            useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
          },

          // This function implements an ifblank macro.
          IfblankFunction(parser, name) {
            const blankarg = parser.GetArgument(name);
            const resultblank = parser.GetArgument(name);
            const resultnotblank = parser.GetArgument(name);
            const isblank = (blankarg.trim() == "");
            useArgument(parser, isblank ? resultblank : resultnotblank);
          },

          // This function implements an ifstrequal macro.
          IfstrequalFunction(parser, name) {
            const strequalfirst = parser.GetArgument(name);
            const strequalsecond = parser.GetArgument(name);
            const resultequal = parser.GetArgument(name);
            const resultnotequal = parser.GetArgument(name);
            const isequal = (strequalfirst == strequalsecond);
            useArgument(parser, isequal ? resultequal : resultnotequal);
          },

          // This function implements a gsub macro.
          GsubstituteFunction(parser, name) {
            const gsubfirst = parser.GetArgument(name);
            const gsubsecond = parser.GetArgument(name);
            const gsubthird = parser.GetArgument(name);
            let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
            useArgument(parser, gsubresult);
          },

          // This function modifies the equation numbers.
          SeteqnumberFunction(parser, name) {
              // Get the macro parameters
              const star = parser.GetStar();                  // true if there is a *
              const optBrackets = parser.GetBrackets(name);   // contents of optional brackets
              const newsubequations = parser.GetArgument(name); // the subequations argument
              const neweqsection = parser.GetArgument(name); // the eq section argument
              const neweqnumber = parser.GetArgument(name);   // the eq number argument
              MathJax.config.subequations=newsubequations ;   // a string with boolean meaning
              MathJax.config.section=neweqsection ;           // a string with numeric meaning
              parser.tags.counter = parser.tags.allCounter = neweqnumber ;
          }

       });

       // Create the Lwarp-macros package
       Configuration.create('Lwarp-macros', {
         handler: {macro: ['Lwarp-macros']}
       });

       MathJax.startup.defaultReady();

       // For forward references:
       MathJax.startup.input[0].preFilters.add(({math}) => {
         if (math.inputData.recompile){
             MathJax.config.subequations = math.inputData.recompile.subequations;
             MathJax.config.section = math.inputData.recompile.section;
         }
       });
       MathJax.startup.input[0].postFilters.add(({math}) => {
         if (math.inputData.recompile){
             math.inputData.recompile.subequations = MathJax.config.subequations;
             math.inputData.recompile.section = MathJax.config.section;
         }
       });

         // For \left, \right with unicode-math:
         const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
         const {Symbol} = MathJax._.input.tex.Symbol;
         const {MapHandler} = MathJax._.input.tex.MapHandler;
         const delimiter = MapHandler.getMap('delimiter');
         delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
         delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
         delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
         delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
         delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
         delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
         delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
         delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
         delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
         delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
         delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
         delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
         delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
         delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
         delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
         delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
         delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
         delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
         delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
         delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
         delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
         delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
         delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
         delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
         delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
         delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
         delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
         delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
         delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
         delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
         delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
         delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
         delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
         delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
         delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
         delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
         delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
         delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
         delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
   }     // ready
 },      // startup

 tex: {
   packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
   tags: "ams",
        tagformat: {
            number: function (n) {
                if(MathJax.config.subequations==0)
                    return(MathJax.config.section + n);
                else
                    return(MathJax.config.section + String.fromCharCode(96+n));
            },
        },
 }
}
</script>

<script
    id="MathJax-script"
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="index-autopage-108"></a>
<nav class="topnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Notes on Everything</span>
</p>

<p>
Subjects
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="Sums.html#autosec-6" class="tocchapter" >
Sums</a>
</p>


<p>
<a href="Sums.html#autosec-7" class="tocsection" >
Manipulating Sums</a>
</p>


<p>
<a href="Sums.html#autosec-8" class="tocsubsection" >
Basic Rules</a>
</p>


<p>
<a href="Sums.html#autosec-10" class="tocsubsection" >
Iverson Notation</a>
</p>


<p>
<a href="Sums.html#autosec-13" class="tocsubsection" >
Perturbing the Sum</a>
</p>


<p>
<a href="Sums.html#autosec-16" class="tocsubsection" >
Multiple Sums</a>
</p>


<p>
<a href="Finite-Calculus.html#autosec-24" class="tocsection" >
Finite Calculus</a>
</p>


<p>
<a href="Finite-Calculus.html#autosec-25" class="tocsubsection" >
The Difference Operator</a>
</p>


<p>
<a href="Finite-Calculus.html#autosec-26" class="tocsubsection" >
Rising and Falling Factorials</a>
</p>


<p>
<a href="Algorithms.html#autosec-30" class="tocchapter" >
Algorithms</a>
</p>


<p>
<a href="Algorithms.html#autosec-31" class="tocsection" >
Graphs</a>
</p>


<p>
<a href="Algorithms.html#autosec-32" class="tocsubsection" >
Cuts</a>
</p>


<p>
<a href="Algorithms.html#autosec-42" class="tocsubsection" >
Depth-First Search</a>
</p>


<p>
<a href="Algorithms.html#autosec-44" class="tocsubsection" >
Breadth-First Search</a>
</p>


<p>
<a href="Algorithms.html#autosec-46" class="tocsubsection" >
Topological Ordering</a>
</p>


<p>
<a href="Algorithms.html#autosec-47" class="tocsubsection" >
Strongly Connected Components</a>
</p>


<p>
<a href="Greedy.html#autosec-49" class="tocsection" >
Greedy</a>
</p>


<p>
<a href="Greedy.html#autosec-50" class="tocsubsection" >
Dijkstra’s Shortest Path Algorithm</a>
</p>


<p>
<a href="Greedy.html#autosec-61" class="tocsubsection" >
Prim’s MST Algorithm</a>
</p>


<p>
<a href="Greedy.html#autosec-70" class="tocsubsection" >
Kruskal’s MST Algorithm</a>
</p>


<p>
<a href="Greedy.html#autosec-77" class="tocsubsection" >
Huffman Codes</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-84" class="tocsection" >
Divide and Conquer</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-85" class="tocsubsection" >
Master Theorem</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-87" class="tocsubsection" >
MergeSort</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-89" class="tocsubsection" >
Counting Array Inversions</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-92" class="tocsubsection" >
Karatsuba Multiplication</a>
</p>


<p>
<a href="Combinatorics.html#autosec-94" class="tocchapter" >
Combinatorics</a>
</p>


<p>
<a href="Combinatorics.html#autosec-95" class="tocsection" >
Basics of Counting</a>
</p>


<p>
<a href="Combinatorics.html#autosec-96" class="tocsubsection" >
Product Rule</a>
</p>


<p>
<a href="Combinatorics.html#autosec-99" class="tocsubsection" >
Complement Rule</a>
</p>


<p>
<a href="Combinatorics.html#autosec-103" class="tocsubsection" >
Inclusion/Exclusion</a>
</p>


<p>
<a href="Combinatorics.html#autosec-106" class="tocsubsection" >
Permutations</a>
</p>


<p>
<a href="Probability.html#autosec-109" class="tocchapter" >
Probability</a>
</p>


<p>
<a href="Probability.html#autosec-110" class="tocsection" >
Basics</a>
</p>


<p>
<a href="Probability.html#autosec-111" class="tocsubsection" >
Terminology</a>
</p>


<p>
<a href="Probability.html#autosec-113" class="tocsubsection" >
Naive Definition of Probability</a>
</p>


<p>
<a href="Probability.html#autosec-115" class="tocsubsection" >
Non-Naive Definition of Probability</a>
</p>


<p>
<a href="Foundations.html#autosec-120" class="tocchapter" >
Foundations</a>
</p>


<p>
<a href="Foundations.html#autosec-121" class="tocsection" >
Set Theory</a>
</p>


<p>
<a href="Foundations.html#autosec-125" class="tocsubsection" >
Basic Definitions</a>
</p>


<p>
<a href="Foundations.html#autosec-126" class="tocsubsection" >
Laws</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-152" class="tocsection" >
Factoring Tricks</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-153" class="tocsubsection" >
Basic Identities</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-154" class="tocsubsection" >
Splitting Apart a Monomial</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-155" class="tocsubsection" >
Adding Zero</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-156" class="tocsubsection" >
\((a^n - b^n) \)</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-158" class="tocsubsection" >
\((a^n + b^n) \)</a>
</p>


<p>
<a href="Quadratics.html#autosec-162" class="tocsection" >
Quadratics</a>
</p>


<p>
<a href="Quadratics.html#autosec-163" class="tocsubsection" >
Finding Roots of a Quadratic Function</a>
</p>


<p>
<a href="Quadratics.html#autosec-169" class="tocsubsection" >
Vieta’s Theorem</a>
</p>


<p>
<a href="Quadratics.html#autosec-172" class="tocsubsection" >
The Quadratic Formula</a>
</p>


</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<h1>Notes on Everything</h1>

<!--MathJax customizations:-->
<div data-nosnippet
    style="display:none"
>

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

</div>

<!--
...... chapter Probability ......
-->
<h3 id="autosec-109">Probability</h3>
<a id="index-autopage-109"></a>
<a id="index-autofile-7"></a>
<!--
...... section Basics ......
-->
<h4 id="autosec-110">Basics</h4>
<a id="index-autopage-110"></a>


<p>
Probability is intimately related to combinatorics and set theory, and theorems from both routinely show up when trying to precisely describe the total number of outcomes of something happening.
</p>
<!--
...... subsection Terminology ......
-->
<h5 id="autosec-111">Terminology</h5>
<a id="index-autopage-111"></a>


<p>
Generally, outcomes in a <b>random experiment</b> belong to an universal set called the <b>sample space</b>. Groups of outcomes (subsets) are referred to as <b>events</b>, and an event is said to occurred if one of its outcomes was the result of the experiment.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><a id="index-autopage-112"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">3</span></span>. </span> <a id="def:samplespace"></a> The sample space of a random experiment is the set of all possible outcomes of that experiment.
Denote the sample space by \(\Omega \) and define \(A\) to be a subset of \(\Omega \). We call \(A\) an <em>event</em> of sample space \(\Omega \). We say \(A\) <em>occurred</em> if one of its outcomes was produced by the random experiment.
</p>

</li>

</ul>

</div>

<p>
The comparatively droll theorems and identities found in set theory make their presence known throughout all of probability theory. Likewise, the basics of counting and combinatorial proofs are very prominient in determining the number of outcomes of a certain
experiment.
</p>
<!--
...... subsection Naive Definition of Probability ......
-->
<h5 id="autosec-113">Naive Definition of Probability</h5>
<a id="index-autopage-113"></a>


<p>
A simple yet easily abused model of Probability is called the <b>naive</b> definition of probability. This applies when:
</p>

<ul class="itemize" style="list-style-type:none">

<li>
<p>
<span class="listmarker">•</span> There is <em>symmetry</em> in events, (e.g a Deck of Cards)
</p>

</li>
<li>

<p>
<span class="listmarker">•</span> The experiment is defined to have equally likely outcomes (e.g Dice)
</p>

</li>
<li>

<p>
<span class="listmarker">•</span> As a thought experiment, to be compared against a more realistic model
</p>
</li>
</ul>

<p>
Formally:
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><a id="index-autopage-114"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">4</span></span>. </span> Let \(A \subseteq \Omega \) be an event in the sample space of an experiment. We define the <em>Naive Probability</em> of
\(A\) as:
</p>

<p>
\[ P_{naive}(A) = \frac {|A|} {|\Omega |} \]
</p>

<p>
In other words, the ratio of outcomes in \(A\) and total outcomes in \(\Omega \).
</p>

</li>

</ul>

</div>
<!--
...... subsection Non-Naive Definition of Probability ......
-->
<h5 id="autosec-115">Non-Naive Definition of Probability</h5>
<a id="index-autopage-115"></a>


<p>
As the name implies, this definition is used when the outcomes in an experiment are not equally likely. Predictably, this requires a bit more thought and care to set up as a workable model of probability. Fortunately, there are only two axioms to worry about (for now).
</p>

<p>
We also want to define a <b>probability space</b> as a mathematical object consisting of a sample space and a <b>probability function</b>. This function maps events in a sample space to real numbers, letting us define the likelihood that an event in the sample
space occurs.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><a id="index-autopage-116"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">5</span></span>. </span> A probability space consists of a sample space \(\Omega \) and a probability function \(P\) defined as:
</p>

<p>
\[ P : A \subseteq \Omega \to \mathbb {R}, \; P(A) = \; \text {the probability of $A$} \]
</p>

<p>
and governed by the following axioms:
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><a id="index-autopage-117"></a>
<span class="amsthmnameplain">axiom</span><span class="amsthmnumberplain"> <span class="textup">1</span></span>. </span> \(P(\emptyset ) = 0\) and \(P(\Omega ) = 1\)
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><a id="index-autopage-118"></a>
<span class="amsthmnameplain">axiom</span><span class="amsthmnumberplain"> <span class="textup">2</span></span>. </span> If \(A_1, A_2, \dots , A_n\) are disjoint events of \(\Omega \), then
</p>

<p>
\[ P(\bigcup _{k=1}^n A_k) = \sum _{k=1}^n P(A_k) \]
</p>

<p>


</p>

</li>

</ul>

</div>

</li>

</ul>

</div>

</section>

</main>

</div>

<footer>

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

</footer>


<nav class="botnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|Foundations.html|-->

<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Anthony" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="Personal notes on Mathematics and Computer Science" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Notes on Everything — Foundations</title>
<link rel="stylesheet" type="text/css" href="lwarp.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
  subequations: "0",
  section: "",
  loader: {
    load: ['[tex]/tagformat', '[tex]/textmacros'],
  },
  startup: {
    ready() {
      // These would be replaced by import commands if you wanted to make
      // a proper extension.
      const Configuration = MathJax._.input.tex.Configuration.Configuration;
      const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
      const Macro = MathJax._.input.tex.Symbol.Macro;
      const TexError = MathJax._.input.tex.TexError.default;
      const ParseUtil = MathJax._.input.tex.ParseUtil.default;
      const expandable = MathJax._.util.Options.expandable;

       // Insert the replacement string into the TeX string, and check
       // that there haven't been too many maxro substitutions (prevents
       // infinite loops).
       const useArgument = (parser, text) => {
         parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
         parser.i = 0;
         if (++parser.macroCount > parser.configuration.options.maxMacros) {
           throw new TexError('MaxMacroSub1',
           'MathJax maximum macro substitution count exceeded; ' +
           'is there a recursive macro call?');
         }
       }

       // Create the command map for:
       //     \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
       new CommandMap('Lwarp-macros', {
         ifstar: 'IfstarFunction',
         ifnextchar: 'IfnextcharFunction',
         ifblank: 'IfblankFunction',
         ifstrequal: 'IfstrequalFunction',
         gsubstitute: 'GsubstituteFunction',
         seteqnumber: 'SeteqnumberFunction'
       }, {
         // This function implements an ifstar macro.
         IfstarFunction(parser, name) {
            const resultstar = parser.GetArgument(name);
            const resultnostar = parser.GetArgument(name);
            const star = parser.GetStar();                 // true if there is a *
            useArgument(parser, star ? resultstar : resultnostar);
         },

          // This function implements an ifnextchar macro.
          IfnextcharFunction(parser, name) {
            let whichchar = parser.GetArgument(name);
            if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
              // $ syntax highlighting
              whichchar = String.fromCodePoint(parseInt(whichchar));
            }
            const resultnextchar = parser.GetArgument(name);
            const resultnotnextchar = parser.GetArgument(name);
            const gotchar = (parser.GetNext() === whichchar);
            useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
          },

          // This function implements an ifblank macro.
          IfblankFunction(parser, name) {
            const blankarg = parser.GetArgument(name);
            const resultblank = parser.GetArgument(name);
            const resultnotblank = parser.GetArgument(name);
            const isblank = (blankarg.trim() == "");
            useArgument(parser, isblank ? resultblank : resultnotblank);
          },

          // This function implements an ifstrequal macro.
          IfstrequalFunction(parser, name) {
            const strequalfirst = parser.GetArgument(name);
            const strequalsecond = parser.GetArgument(name);
            const resultequal = parser.GetArgument(name);
            const resultnotequal = parser.GetArgument(name);
            const isequal = (strequalfirst == strequalsecond);
            useArgument(parser, isequal ? resultequal : resultnotequal);
          },

          // This function implements a gsub macro.
          GsubstituteFunction(parser, name) {
            const gsubfirst = parser.GetArgument(name);
            const gsubsecond = parser.GetArgument(name);
            const gsubthird = parser.GetArgument(name);
            let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
            useArgument(parser, gsubresult);
          },

          // This function modifies the equation numbers.
          SeteqnumberFunction(parser, name) {
              // Get the macro parameters
              const star = parser.GetStar();                  // true if there is a *
              const optBrackets = parser.GetBrackets(name);   // contents of optional brackets
              const newsubequations = parser.GetArgument(name); // the subequations argument
              const neweqsection = parser.GetArgument(name); // the eq section argument
              const neweqnumber = parser.GetArgument(name);   // the eq number argument
              MathJax.config.subequations=newsubequations ;   // a string with boolean meaning
              MathJax.config.section=neweqsection ;           // a string with numeric meaning
              parser.tags.counter = parser.tags.allCounter = neweqnumber ;
          }

       });

       // Create the Lwarp-macros package
       Configuration.create('Lwarp-macros', {
         handler: {macro: ['Lwarp-macros']}
       });

       MathJax.startup.defaultReady();

       // For forward references:
       MathJax.startup.input[0].preFilters.add(({math}) => {
         if (math.inputData.recompile){
             MathJax.config.subequations = math.inputData.recompile.subequations;
             MathJax.config.section = math.inputData.recompile.section;
         }
       });
       MathJax.startup.input[0].postFilters.add(({math}) => {
         if (math.inputData.recompile){
             math.inputData.recompile.subequations = MathJax.config.subequations;
             math.inputData.recompile.section = MathJax.config.section;
         }
       });

         // For \left, \right with unicode-math:
         const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
         const {Symbol} = MathJax._.input.tex.Symbol;
         const {MapHandler} = MathJax._.input.tex.MapHandler;
         const delimiter = MapHandler.getMap('delimiter');
         delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
         delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
         delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
         delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
         delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
         delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
         delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
         delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
         delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
         delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
         delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
         delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
         delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
         delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
         delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
         delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
         delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
         delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
         delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
         delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
         delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
         delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
         delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
         delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
         delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
         delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
         delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
         delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
         delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
         delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
         delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
         delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
         delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
         delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
         delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
         delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
         delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
         delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
         delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
   }     // ready
 },      // startup

 tex: {
   packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
   tags: "ams",
        tagformat: {
            number: function (n) {
                if(MathJax.config.subequations==0)
                    return(MathJax.config.section + n);
                else
                    return(MathJax.config.section + String.fromCharCode(96+n));
            },
        },
 }
}
</script>

<script
    id="MathJax-script"
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="index-autopage-119"></a>
<nav class="topnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Notes on Everything</span>
</p>

<p>
Subjects
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="Sums.html#autosec-6" class="tocchapter" >
Sums</a>
</p>


<p>
<a href="Sums.html#autosec-7" class="tocsection" >
Manipulating Sums</a>
</p>


<p>
<a href="Sums.html#autosec-8" class="tocsubsection" >
Basic Rules</a>
</p>


<p>
<a href="Sums.html#autosec-10" class="tocsubsection" >
Iverson Notation</a>
</p>


<p>
<a href="Sums.html#autosec-13" class="tocsubsection" >
Perturbing the Sum</a>
</p>


<p>
<a href="Sums.html#autosec-16" class="tocsubsection" >
Multiple Sums</a>
</p>


<p>
<a href="Finite-Calculus.html#autosec-24" class="tocsection" >
Finite Calculus</a>
</p>


<p>
<a href="Finite-Calculus.html#autosec-25" class="tocsubsection" >
The Difference Operator</a>
</p>


<p>
<a href="Finite-Calculus.html#autosec-26" class="tocsubsection" >
Rising and Falling Factorials</a>
</p>


<p>
<a href="Algorithms.html#autosec-30" class="tocchapter" >
Algorithms</a>
</p>


<p>
<a href="Algorithms.html#autosec-31" class="tocsection" >
Graphs</a>
</p>


<p>
<a href="Algorithms.html#autosec-32" class="tocsubsection" >
Cuts</a>
</p>


<p>
<a href="Algorithms.html#autosec-42" class="tocsubsection" >
Depth-First Search</a>
</p>


<p>
<a href="Algorithms.html#autosec-44" class="tocsubsection" >
Breadth-First Search</a>
</p>


<p>
<a href="Algorithms.html#autosec-46" class="tocsubsection" >
Topological Ordering</a>
</p>


<p>
<a href="Algorithms.html#autosec-47" class="tocsubsection" >
Strongly Connected Components</a>
</p>


<p>
<a href="Greedy.html#autosec-49" class="tocsection" >
Greedy</a>
</p>


<p>
<a href="Greedy.html#autosec-50" class="tocsubsection" >
Dijkstra’s Shortest Path Algorithm</a>
</p>


<p>
<a href="Greedy.html#autosec-61" class="tocsubsection" >
Prim’s MST Algorithm</a>
</p>


<p>
<a href="Greedy.html#autosec-70" class="tocsubsection" >
Kruskal’s MST Algorithm</a>
</p>


<p>
<a href="Greedy.html#autosec-77" class="tocsubsection" >
Huffman Codes</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-84" class="tocsection" >
Divide and Conquer</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-85" class="tocsubsection" >
Master Theorem</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-87" class="tocsubsection" >
MergeSort</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-89" class="tocsubsection" >
Counting Array Inversions</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-92" class="tocsubsection" >
Karatsuba Multiplication</a>
</p>


<p>
<a href="Combinatorics.html#autosec-94" class="tocchapter" >
Combinatorics</a>
</p>


<p>
<a href="Combinatorics.html#autosec-95" class="tocsection" >
Basics of Counting</a>
</p>


<p>
<a href="Combinatorics.html#autosec-96" class="tocsubsection" >
Product Rule</a>
</p>


<p>
<a href="Combinatorics.html#autosec-99" class="tocsubsection" >
Complement Rule</a>
</p>


<p>
<a href="Combinatorics.html#autosec-103" class="tocsubsection" >
Inclusion/Exclusion</a>
</p>


<p>
<a href="Combinatorics.html#autosec-106" class="tocsubsection" >
Permutations</a>
</p>


<p>
<a href="Probability.html#autosec-109" class="tocchapter" >
Probability</a>
</p>


<p>
<a href="Probability.html#autosec-110" class="tocsection" >
Basics</a>
</p>


<p>
<a href="Probability.html#autosec-111" class="tocsubsection" >
Terminology</a>
</p>


<p>
<a href="Probability.html#autosec-113" class="tocsubsection" >
Naive Definition of Probability</a>
</p>


<p>
<a href="Probability.html#autosec-115" class="tocsubsection" >
Non-Naive Definition of Probability</a>
</p>


<p>
<a href="Foundations.html#autosec-120" class="tocchapter" >
Foundations</a>
</p>


<p>
<a href="Foundations.html#autosec-121" class="tocsection" >
Set Theory</a>
</p>


<p>
<a href="Foundations.html#autosec-125" class="tocsubsection" >
Basic Definitions</a>
</p>


<p>
<a href="Foundations.html#autosec-126" class="tocsubsection" >
Laws</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-152" class="tocsection" >
Factoring Tricks</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-153" class="tocsubsection" >
Basic Identities</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-154" class="tocsubsection" >
Splitting Apart a Monomial</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-155" class="tocsubsection" >
Adding Zero</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-156" class="tocsubsection" >
\((a^n - b^n) \)</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-158" class="tocsubsection" >
\((a^n + b^n) \)</a>
</p>


<p>
<a href="Quadratics.html#autosec-162" class="tocsection" >
Quadratics</a>
</p>


<p>
<a href="Quadratics.html#autosec-163" class="tocsubsection" >
Finding Roots of a Quadratic Function</a>
</p>


<p>
<a href="Quadratics.html#autosec-169" class="tocsubsection" >
Vieta’s Theorem</a>
</p>


<p>
<a href="Quadratics.html#autosec-172" class="tocsubsection" >
The Quadratic Formula</a>
</p>


</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<h1>Notes on Everything</h1>

<!--MathJax customizations:-->
<div data-nosnippet
    style="display:none"
>

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

</div>

<!--
...... chapter Foundations ......
-->
<h3 id="autosec-120">Foundations</h3>
<a id="index-autopage-120"></a>
<a id="index-autofile-8"></a>

<p>
This section explains a lot of what highschool teachers ought to have during math class. Oh well.
</p>
<!--
...... section Set Theory ......
-->
<h4 id="autosec-121">Set Theory</h4>
<a id="index-autopage-121"></a>


<p>
Sets represent unordered, arbitrary collections. Most of modern mathematics is founded on the basics of set theory, and they show up in any serious treatment of a mathematical subject. These notes contain some simple proofs about sets. I hope I have provided an
unbearable amount of detail in the explanations.
</p>

<p>
Despite usually being among the first proofs students learn, some of the longer set proofs can be somewhat tricky, and involve multiple proof techniques.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><a id="index-autopage-122"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">6</span></span>. </span> These two axioms form the basis for nearly all set identities and proofs.
</p>

<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">1.</span> There exists a set with no elements called the null set (\(\emptyset \))
</p>


</li>
<li>


<p>
<span class="listmarker">2.</span> If every element \(x \in X\) is also in \(Y\) and vice-versa, then \(X = Y\)
</p>
</li>
</ul>

</li>

</ul>

</div>

<p>
A clever proof by contradiction establishes the fact that \(\emptyset \) is unique (in other words, there is exactly one \(\emptyset \)). The main idea behind this proof is to use axiom two in order to prove that any two sets with no elements are actually subsets of one
another and by definition the same set.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><a id="index-autopage-123"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">6</span></span>. </span> There is exactly one empty set.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="index-autopage-124"></a>

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> Suppose not, there there are at least two sets, \(\emptyset _1\) and \(\emptyset _2\) such that \(\emptyset _1 \neq \emptyset _2\). By definition of empty, there is no element
\(x\) in either of the sets. However, this means that exactly the same elements are in \(\emptyset _1\) and \(\emptyset _2\), and axiom 2 establishes they must be equal. Therefore we have arrived at a contradiction, and so there can only be a single, unique empty set.
<span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<!--
...... subsection Basic Definitions ......
-->
<h5 id="autosec-125">Basic Definitions</h5>
<a id="index-autopage-125"></a>


<p>
The following set operations are ubiquitous in set proofs.
</p>

<span class="hidden"> \(\seteqnumber{0}{}{2}\)</span>


<!--


                                                                    X = {x | x 6∈ X}                                                                              Complement


                                                                X − Y = {x | x ∈ X, x 6∈ Y }                                                                        Difference


                                                                 P(A) = {A0 | A0 ⊆ A}                                                                               Power Set


                                                                X × Y = {(x, y) | x ∈ X, y ∈ Y }                                                             Cartesian Product


-->


<p>

\begin{align*}
\overline {X} &amp;= \{ x \mid x \not \in X \} &amp;\text {Complement} \\\\ X - Y &amp;= \{ x \mid x \in X, x \not \in Y \} &amp;\text {Difference} \\\\ \mathcal {P}(A) &amp;= \{ A&apos; \mid A&apos; \subseteq A \} &amp;\text {Power Set}
\\\\ X \times Y &amp;= \{ (x, y) \mid x \in X, y \in Y \} &amp;\text {Cartesian Product}
\end{align*}

</p>
<!--
...... subsection Laws ......
-->
<h5 id="autosec-126">Laws</h5>
<a id="index-autopage-126"></a>


<p>
Set laws are identities proven by thinking through the membership of arbitrary elements in a set and applying some basic logical operators. These come up all the time, so it’s worth having a small list jotted down somewhere.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><a id="index-autopage-127"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">7</span></span>. </span> The set union operator \(\cup \) is associative, that is
</p>

<p>
\[ A \cup (B \cup C) = (A \cup B) \cup C \]
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="index-autopage-128"></a>

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> Suppose \(x \in A \cup (B \cup C)\). Then by definition of set union, \(x\) is either in \(A\) or \(B \cup C\) (or both). Breaking down these cases:
</p>

<p>
If \(x \in A\). Then \(x\) is in \(A \cup B\), and so it is in the right-hand side.
</p>

<p>
Alternatively, if \(x \in (B \cup C\), this breaks down into another two cases, \(x \in B\) or \(x \in C\). If \(x \in C\), then it’s automatically in the union of \(C\) and anything else, and if \(x \in B\), then \(x \in (A \cup B)\) and so must be in \((A \cup B)
\cup C\).
</p>

<p>
Since we’ve proven the two expressions are subsets of one another, they must be the same set by axiom two, and the proof is complete. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><a id="index-autopage-129"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">8</span></span>. </span>
</p>

<p>
\[ A \cap B \subseteq B \]
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="index-autopage-130"></a>

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> Intuitively, this is saying that if an element is in \(A\) <em>and</em> \(B\), then it must be in \(B\). This is just the definition of set intersection. Formally:
</p>

<p>
Suppose \(x \in A \cap B\), then \(x \in A\) and \(x \in B\). But then \(x\) must be an element in \(B\) by definition. Because \(x\) was arbitrarily chosen, every element in \(A \cap B\) must be in \(B\), and therefore the definition of subset is satisfied. <span
class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><a id="index-autopage-131"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">9</span></span>. </span> The union operation is distributive over a set expression.
</p>

<p>
\[ X \cup (Y \cap Z) = (X \cup Y) \cap (X \cup Z) \]
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="index-autopage-132"></a>

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> Starting with the right-hand side, we see that \(X\) is involved in two unions, meaning that every element in \(X\) automatically shows up in the intersection. This is consistent with the
left-hand side, since an element being in \(X\) can be thought of as ”short-circuting” the union expression; we don’t even need to consider the other operations to know an element is present in whatever comes next.
</p>

<p>
On the other hand, if an element is not in \(X\), then it had better be in both \(Y\) <em>and</em> \(Z\). This is similar to the rules of logic, in which a known false combined with a proposition reduces to just the proposition. In other words, since we know the element is
not in \(X\), we can imagine the form on the right as:
</p>

<span class="hidden"> \(\seteqnumber{0}{}{2}\)</span>


<!--



                                                                                                                      (x ∈ X ∨ x ∈ Y ) ∧ (x ∈ X ∨ x ∈ Z)
                                                                                                                        ⇐⇒ (F ∨ x ∈ Y ) ∧ (F ∨ x ∈ Z)
                                                                                                                        ⇐⇒ (x ∈ Y ) ∧ (x ∈ Z)



-->


<p>


\begin{align*}
&amp;(x \in X \lor x \in Y) \land (x \in X \lor x \in Z) \\ &amp;\iff (F \lor x \in Y) \land (F \lor x \in Z) \\ &amp;\iff (x \in Y) \land (x \in Z)
\end{align*}


</p>

<p>
which is precisely what the left-hand side is saying. More formally:
</p>

<p>
Suppose \(x \in X\). Then \(x \in (X \cup Y)\) and \(x \in (X \cup Z)\) by union of two sets, and so \(x\) is in the right-hand expression. By similar argument, if \(x \in (Y \cap Z)\), then \(x \in (X \cup Y)\) and \(x \in (X \cup Z)\), and so the forward
direction holds.
</p>

<p>
Now suppose \(x \in (X \cup Y) \cap (X \cup Z)\). Then \(x \in X\) or \(x\) is in both \(Y\) and \(Z\) by definition of set union. But then \(x \in X \cup (Y \cap Z)\) and since both expressions are subsets of one another, the identity holds. <span
class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><a id="index-autopage-133"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">10</span></span>. </span> A Cartesian Product distributes over a set union.
</p>

<p>
\[ A \times (B \cup C) = (A \times B) \cup (A \times C) \]
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="index-autopage-134"></a>

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> The main idea here is to think about all the ordered pairs that would end up on the left-hand side. Taking every element in \(A\) and forming a tuple with all the elements in either
\(B\) or \(C\), we get
</p>

<p>
\[ (a_1, b_1), (a_1, c_1), (a_2, b_1), \dots (a_n, b_m), (a_n, c_k) \]
</p>

<p>
but these are the same ordered pairs as if we had taken each product by itself and combined the results together:
</p>

<p>
\[ (a_1, b_1), (a_1, b_2), \dots (a_n, b_m) \cup (a_1, c_1) \dots (a_n, c_k) \]
</p>

<p>
For the actual proof, we consider an arbitrary ordered pair in each of the expressions and once again prove both sides are subsets of one another.
</p>

<p>
Take \((x, y) \in A \times (B \cup C)\), then by definition of set union and Cartesian product, \(x \in A\) and either \(y \in B\) or \(y \in C\).
</p>

<p>
Suppose \(y \in B\), then \((x, y) \in (A \times B)\) and so it is in the union on the right. Now let \(y \in C\), and see by similar argument it is also in the union. Now assume \((x, y) \in (A \times B) \cup (A \times C)\). Then once againt, \(x \in A\) and
\(y \in B\) or \(y \in C\). This completes the proof as in either case, \((x, y) \in A \times (B \cup C)\) and so the sets are equal. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><a id="index-autopage-135"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">11</span></span>. </span>
</p>

<p>
\[ A \setminus B \subseteq \overline {B} \]
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="index-autopage-136"></a>

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> Any element left over after \(A \setminus B\) couldn’t have been in \(B\) by the definition of set subtraction. In other words, every such element would have to be in \(\overline
{B}\), otherwise it wouldn’t have survived the operation. This yields a fairly straightforward proof.
</p>

<p>
Let \(x \in A \setminus B\). Then by definition of the set difference operator, \(x \in \overline {B}\) and so because \(x\) was arbitrarily chosen, the identity must hold for any element of \(A \setminus B\) and the subset relation is shown. <span
class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><a id="index-autopage-137"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">12</span></span>. </span>
</p>

<p>
\[ A \cap \overline {B} = A \setminus B \]
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="index-autopage-138"></a>

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> As in the previous proof, we know that any element that is left over after a set subtraction must have been in the first set <em>and</em> not the second. But this is verbatim what the
left side of the equation claims, so all that’s left to do is show the bi-directional relation once more.
</p>

<p>
Let \(x\) be an element in \(A \cap \overline {B}\). Then by definition, \(x \in A\) and \(x \not \in B\) which means that \(x \in \overline {B}\). Then by set difference, \(x\) must be in \(A \setminus B\).
</p>

<p>
Now assume \(x \in A \setminus B\). Once again, \(x \in A\) and \(x \not \in B\), and set equality is shown in both directions. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><a id="index-autopage-139"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">13</span></span>. </span>
</p>

<p>
\[ A \cup (A \cap B) = A \]
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="index-autopage-140"></a>

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> There are a couple of decent ways of thinking about this identity. The most straightforward way might be to say that this boils down to declaring all the elements in \(A\), do in fact,
belong to \(A\). This line of thought comes from the fact that any element in \(A \cap B\) must be in \(A\), and so the expression reduces to \(A \cup A\), which of course is \(A\) itself.
</p>

<p>
Another clever way of thinking about this is to consider the problem in terms of boolean logic, in which a similar identity is presented:
</p>

<p>
\[ A \cup (A \cap B) \iff T \lor (T \land P) \iff T \]
</p>

<p>
here, the value of \(P\) is irrelevant, because the \(T\) immediately renders the entire expression true regardless. Analogously, if we know \(x \in A\), then we don’t have to consider again whether \(x \in A\), since the intersection with \(B\) could only ever produce
elements that were in \(A\) anyway.
</p>

<p>
Let \(x \in A \cup (A \cap B)\). Then \(x \in A\) or \(x \in (A \cap B\). In either case, \(x \in A\). Now suppose \(x \in A\). It immediately follows that \(x\) is in the union by virtue of being in \(A\), and the proof is complete.
</p>

<p>
Something interesting about this theorem is that we could instead try to apply the previously shown distributive property as a first step:
</p>

<p>
\[ A \cup (A \cap B) = (A \cup A) \cap (A \cup B) = A \cap (A \cup B) \]
</p>

<p>
Since we’ve proven the original identity and that this one is equivalent, we get another identity (basically) for free! <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><a id="index-autopage-141"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">14</span></span>. </span> DeMorgan’s Law for Sets
</p>

<p>
\[ \overline {A \cup B} = \overline {A} \cap \overline {B} \]
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="index-autopage-142"></a>

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> Another direct analog to boolean logic. Essentially this works in exactly the same way as applying DeMorgan’s law to logical operators. In plain English, this can be described as simply
saying if an element is not in \(A\) or \(B\), it can’t be in \(A\) and it also can’t be in \(B\).
</p>

<p>
Let \(x \in \overline {A \cup B}\), then by definition of set complement, \(x\) is not in the union of \(A\) and \(B\), which means \(x \not \in A\) and \(x \not \in B\). This implies that \(x \in \overline {A}\) and \(x \in \overline {B}\) and is therefore in
the intersection of the two.
</p>

<p>
Conversely, if \(x \in \overline {A} \cap \overline {B}\), it is neither in \(A\) nor \(B\), so it does not exist in their union and must therefore be in the complement of the union, \(\overline {A \cup B}\), and the proof is complete. <span
class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><a id="index-autopage-143"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">15</span></span>. </span>
</p>

<p>
\[ (A \setminus B) \cap B = \emptyset \]
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="index-autopage-144"></a>

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> This theorem can be thought of as the logical negation of \(A \cup (A \cap B)\) if we treat the \(\emptyset \) as a contradiction (logically always false). This makes sense, since if we
delete all the elements found in \(B\) from \(A\), and afterwards ask the question how many elements are now in both \(B\) and \(A\), we will always find exactly zero (we just got rid of any!).
</p>

<p>
For ”fun” and variety, this proof can proceed by contradiction. It also makes subtle use of the very first proof in that once we show the left-hand side is empty, we have proven that is must be equal to the unique empty set, and so the proof of the converse statement can be
skipped straight away.
</p>

<p>
Suppose not, that there is some element \(x\) in \(A \setminus B \cap B\). Then it must be the case that \(x \in A \setminus B\) and \(x \in B\) by definition of intersection. However, if \(x \in A \setminus B\), then \(x\) cannot be in \(B\). This contradicts the
original assumption that there was some element in the set, and so there can be no such element. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><a id="index-autopage-145"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">16</span></span>. </span> This theorem is actually <b>false</b>, but sets up the next theorem nicely and demonstrates a disproof.
</p>

<p>
\[ (A \setminus B) \cup B = A \]
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="index-autopage-146"></a>

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Counterexample.</span></span> As the next theorem shows, this is only true of \(B\) is a subset of \(A\). This can be shown with a simple counterexample:
</p>

<p>
Let \(A = \{1\}, \; B = \{2\}\). Then \(A \setminus B = \{1\}\), but this set and \(B\) have a union of \(\{1, 2\} \neq A\).
</p>

<p>
The reason this fails when \(B\) is not a subset of \(A\) is because when the set difference occurs, only those elements in \(B\) are taken away from \(A\). If any elements of \(B\) are not in \(A\), they’ll be tacked on as ”extra” in the union.
</p>

<p>
The next theorem provides the corrected claim. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><a id="index-autopage-147"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">17</span></span>. </span>
</p>

<p>
\[ B \subseteq A \iff (A \setminus B) \cup B = A \]
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="index-autopage-148"></a>

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> In contrast to the previous false claim, the condition that \(B\) is a subset of \(A\) ensures that the elements we take away during the set difference are exactly the same as the ones
added back during the set union. This follows from the definition of subset, which says that <em>every</em> element in \(B\) must also be in \(A\). This guarantees the operations cancel each other out.
</p>

<p>
The first part of this proof shows the forward direction in the usual way, while the second proceeds by contradiction since it ties in nicely with the reasoning of the previous disproof.
</p>

<p>
To see the forward claim, let \(B \subseteq A\) and let \(x\) be an element in \((A \setminus B) \cup B\). By definition of union and set difference, either \(x \in A\) and \(x \not \in B\) or \(x \in B\). In the first case, \(x \in A\) shows the identity immediately.
Now assume \(x \in B\). Once again, we know \(x \in A\) by definition of subset and so the first part of the claim is proven.
</p>

<p>
Now assume \((A \setminus B) \cup B = A\) and assume for the sake of obtaining a contradiction that \(B\) is not a subset of \(A\). Then there is some element, say, \(y \in B\) that is not in \(A\). But then \(y \in (A \setminus B) \cup B\), contradicting the
assumption that this set was equal to \(A\). Therefore, \(B\) must be a subset of \(A\), and the claim holds in both directions. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><a id="index-autopage-149"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">18</span></span>. </span>
</p>

<p>
\[ A \cap (B \setminus (A \cap B)) = \emptyset \]
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="index-autopage-150"></a>

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> There’s a lot of notation here, but translating to English helps. This claims that there are no elements both in \(A\) and in \(B\) after taking away those in \(A\) and \(B\) from \(B\).
This gets us a little closer to what’s going on, but we can break the problem down slowly and focus on the ”inner” expression first.
</p>

<p>
\[ B \setminus (A \cap B) \]
</p>

<p>
This expression remove anything in both \(B\) and \(A\) from \(B\). Crucially, this means any trace of \(A\) vanishes from \(B\), and so we’re left with exactly no elements in common between the two sets by the time we take the intersection. Of course, this shows that
there can never be any element in this set!
</p>

<p>
Doing this proof directly isn’t terribly difficult, but it is pretty tedious given the slighty subtle cases. Instead, we can try to find a contradiction.
</p>

<p>
Suppose by way of contradiction there there is some element in the left-hand expression, call it \(x\). Then \(x \in A\) and \(x \in B \setminus (A \cap B)\). Because \(x \in B \setminus (A \cap B)\), it must also be in \(B\), and not in \(A \cap B\). However,
this contradicts the fact that \(x\) must be in both \(A\) and \(B\) in order to be present in the intersection. Therefore, we have shown there can be no such element, and the proof is finished. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

</section>

</main>

</div>

<footer>

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

</footer>


<nav class="botnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|Factoring-Tricks.html|-->

<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Anthony" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="Personal notes on Mathematics and Computer Science" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Notes on Everything — Factoring Tricks</title>
<link rel="stylesheet" type="text/css" href="lwarp.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
  subequations: "0",
  section: "",
  loader: {
    load: ['[tex]/tagformat', '[tex]/textmacros'],
  },
  startup: {
    ready() {
      // These would be replaced by import commands if you wanted to make
      // a proper extension.
      const Configuration = MathJax._.input.tex.Configuration.Configuration;
      const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
      const Macro = MathJax._.input.tex.Symbol.Macro;
      const TexError = MathJax._.input.tex.TexError.default;
      const ParseUtil = MathJax._.input.tex.ParseUtil.default;
      const expandable = MathJax._.util.Options.expandable;

       // Insert the replacement string into the TeX string, and check
       // that there haven't been too many maxro substitutions (prevents
       // infinite loops).
       const useArgument = (parser, text) => {
         parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
         parser.i = 0;
         if (++parser.macroCount > parser.configuration.options.maxMacros) {
           throw new TexError('MaxMacroSub1',
           'MathJax maximum macro substitution count exceeded; ' +
           'is there a recursive macro call?');
         }
       }

       // Create the command map for:
       //     \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
       new CommandMap('Lwarp-macros', {
         ifstar: 'IfstarFunction',
         ifnextchar: 'IfnextcharFunction',
         ifblank: 'IfblankFunction',
         ifstrequal: 'IfstrequalFunction',
         gsubstitute: 'GsubstituteFunction',
         seteqnumber: 'SeteqnumberFunction'
       }, {
         // This function implements an ifstar macro.
         IfstarFunction(parser, name) {
            const resultstar = parser.GetArgument(name);
            const resultnostar = parser.GetArgument(name);
            const star = parser.GetStar();                 // true if there is a *
            useArgument(parser, star ? resultstar : resultnostar);
         },

          // This function implements an ifnextchar macro.
          IfnextcharFunction(parser, name) {
            let whichchar = parser.GetArgument(name);
            if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
              // $ syntax highlighting
              whichchar = String.fromCodePoint(parseInt(whichchar));
            }
            const resultnextchar = parser.GetArgument(name);
            const resultnotnextchar = parser.GetArgument(name);
            const gotchar = (parser.GetNext() === whichchar);
            useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
          },

          // This function implements an ifblank macro.
          IfblankFunction(parser, name) {
            const blankarg = parser.GetArgument(name);
            const resultblank = parser.GetArgument(name);
            const resultnotblank = parser.GetArgument(name);
            const isblank = (blankarg.trim() == "");
            useArgument(parser, isblank ? resultblank : resultnotblank);
          },

          // This function implements an ifstrequal macro.
          IfstrequalFunction(parser, name) {
            const strequalfirst = parser.GetArgument(name);
            const strequalsecond = parser.GetArgument(name);
            const resultequal = parser.GetArgument(name);
            const resultnotequal = parser.GetArgument(name);
            const isequal = (strequalfirst == strequalsecond);
            useArgument(parser, isequal ? resultequal : resultnotequal);
          },

          // This function implements a gsub macro.
          GsubstituteFunction(parser, name) {
            const gsubfirst = parser.GetArgument(name);
            const gsubsecond = parser.GetArgument(name);
            const gsubthird = parser.GetArgument(name);
            let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
            useArgument(parser, gsubresult);
          },

          // This function modifies the equation numbers.
          SeteqnumberFunction(parser, name) {
              // Get the macro parameters
              const star = parser.GetStar();                  // true if there is a *
              const optBrackets = parser.GetBrackets(name);   // contents of optional brackets
              const newsubequations = parser.GetArgument(name); // the subequations argument
              const neweqsection = parser.GetArgument(name); // the eq section argument
              const neweqnumber = parser.GetArgument(name);   // the eq number argument
              MathJax.config.subequations=newsubequations ;   // a string with boolean meaning
              MathJax.config.section=neweqsection ;           // a string with numeric meaning
              parser.tags.counter = parser.tags.allCounter = neweqnumber ;
          }

       });

       // Create the Lwarp-macros package
       Configuration.create('Lwarp-macros', {
         handler: {macro: ['Lwarp-macros']}
       });

       MathJax.startup.defaultReady();

       // For forward references:
       MathJax.startup.input[0].preFilters.add(({math}) => {
         if (math.inputData.recompile){
             MathJax.config.subequations = math.inputData.recompile.subequations;
             MathJax.config.section = math.inputData.recompile.section;
         }
       });
       MathJax.startup.input[0].postFilters.add(({math}) => {
         if (math.inputData.recompile){
             math.inputData.recompile.subequations = MathJax.config.subequations;
             math.inputData.recompile.section = MathJax.config.section;
         }
       });

         // For \left, \right with unicode-math:
         const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
         const {Symbol} = MathJax._.input.tex.Symbol;
         const {MapHandler} = MathJax._.input.tex.MapHandler;
         const delimiter = MapHandler.getMap('delimiter');
         delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
         delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
         delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
         delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
         delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
         delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
         delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
         delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
         delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
         delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
         delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
         delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
         delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
         delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
         delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
         delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
         delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
         delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
         delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
         delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
         delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
         delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
         delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
         delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
         delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
         delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
         delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
         delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
         delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
         delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
         delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
         delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
         delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
         delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
         delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
         delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
         delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
         delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
         delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
   }     // ready
 },      // startup

 tex: {
   packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
   tags: "ams",
        tagformat: {
            number: function (n) {
                if(MathJax.config.subequations==0)
                    return(MathJax.config.section + n);
                else
                    return(MathJax.config.section + String.fromCharCode(96+n));
            },
        },
 }
}
</script>

<script
    id="MathJax-script"
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="index-autopage-151"></a>
<nav class="topnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Notes on Everything</span>
</p>

<p>
Subjects
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="Sums.html#autosec-6" class="tocchapter" >
Sums</a>
</p>


<p>
<a href="Sums.html#autosec-7" class="tocsection" >
Manipulating Sums</a>
</p>


<p>
<a href="Sums.html#autosec-8" class="tocsubsection" >
Basic Rules</a>
</p>


<p>
<a href="Sums.html#autosec-10" class="tocsubsection" >
Iverson Notation</a>
</p>


<p>
<a href="Sums.html#autosec-13" class="tocsubsection" >
Perturbing the Sum</a>
</p>


<p>
<a href="Sums.html#autosec-16" class="tocsubsection" >
Multiple Sums</a>
</p>


<p>
<a href="Finite-Calculus.html#autosec-24" class="tocsection" >
Finite Calculus</a>
</p>


<p>
<a href="Finite-Calculus.html#autosec-25" class="tocsubsection" >
The Difference Operator</a>
</p>


<p>
<a href="Finite-Calculus.html#autosec-26" class="tocsubsection" >
Rising and Falling Factorials</a>
</p>


<p>
<a href="Algorithms.html#autosec-30" class="tocchapter" >
Algorithms</a>
</p>


<p>
<a href="Algorithms.html#autosec-31" class="tocsection" >
Graphs</a>
</p>


<p>
<a href="Algorithms.html#autosec-32" class="tocsubsection" >
Cuts</a>
</p>


<p>
<a href="Algorithms.html#autosec-42" class="tocsubsection" >
Depth-First Search</a>
</p>


<p>
<a href="Algorithms.html#autosec-44" class="tocsubsection" >
Breadth-First Search</a>
</p>


<p>
<a href="Algorithms.html#autosec-46" class="tocsubsection" >
Topological Ordering</a>
</p>


<p>
<a href="Algorithms.html#autosec-47" class="tocsubsection" >
Strongly Connected Components</a>
</p>


<p>
<a href="Greedy.html#autosec-49" class="tocsection" >
Greedy</a>
</p>


<p>
<a href="Greedy.html#autosec-50" class="tocsubsection" >
Dijkstra’s Shortest Path Algorithm</a>
</p>


<p>
<a href="Greedy.html#autosec-61" class="tocsubsection" >
Prim’s MST Algorithm</a>
</p>


<p>
<a href="Greedy.html#autosec-70" class="tocsubsection" >
Kruskal’s MST Algorithm</a>
</p>


<p>
<a href="Greedy.html#autosec-77" class="tocsubsection" >
Huffman Codes</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-84" class="tocsection" >
Divide and Conquer</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-85" class="tocsubsection" >
Master Theorem</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-87" class="tocsubsection" >
MergeSort</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-89" class="tocsubsection" >
Counting Array Inversions</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-92" class="tocsubsection" >
Karatsuba Multiplication</a>
</p>


<p>
<a href="Combinatorics.html#autosec-94" class="tocchapter" >
Combinatorics</a>
</p>


<p>
<a href="Combinatorics.html#autosec-95" class="tocsection" >
Basics of Counting</a>
</p>


<p>
<a href="Combinatorics.html#autosec-96" class="tocsubsection" >
Product Rule</a>
</p>


<p>
<a href="Combinatorics.html#autosec-99" class="tocsubsection" >
Complement Rule</a>
</p>


<p>
<a href="Combinatorics.html#autosec-103" class="tocsubsection" >
Inclusion/Exclusion</a>
</p>


<p>
<a href="Combinatorics.html#autosec-106" class="tocsubsection" >
Permutations</a>
</p>


<p>
<a href="Probability.html#autosec-109" class="tocchapter" >
Probability</a>
</p>


<p>
<a href="Probability.html#autosec-110" class="tocsection" >
Basics</a>
</p>


<p>
<a href="Probability.html#autosec-111" class="tocsubsection" >
Terminology</a>
</p>


<p>
<a href="Probability.html#autosec-113" class="tocsubsection" >
Naive Definition of Probability</a>
</p>


<p>
<a href="Probability.html#autosec-115" class="tocsubsection" >
Non-Naive Definition of Probability</a>
</p>


<p>
<a href="Foundations.html#autosec-120" class="tocchapter" >
Foundations</a>
</p>


<p>
<a href="Foundations.html#autosec-121" class="tocsection" >
Set Theory</a>
</p>


<p>
<a href="Foundations.html#autosec-125" class="tocsubsection" >
Basic Definitions</a>
</p>


<p>
<a href="Foundations.html#autosec-126" class="tocsubsection" >
Laws</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-152" class="tocsection" >
Factoring Tricks</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-153" class="tocsubsection" >
Basic Identities</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-154" class="tocsubsection" >
Splitting Apart a Monomial</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-155" class="tocsubsection" >
Adding Zero</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-156" class="tocsubsection" >
\((a^n - b^n) \)</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-158" class="tocsubsection" >
\((a^n + b^n) \)</a>
</p>


<p>
<a href="Quadratics.html#autosec-162" class="tocsection" >
Quadratics</a>
</p>


<p>
<a href="Quadratics.html#autosec-163" class="tocsubsection" >
Finding Roots of a Quadratic Function</a>
</p>


<p>
<a href="Quadratics.html#autosec-169" class="tocsubsection" >
Vieta’s Theorem</a>
</p>


<p>
<a href="Quadratics.html#autosec-172" class="tocsubsection" >
The Quadratic Formula</a>
</p>


</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<h1>Notes on Everything</h1>

<!--MathJax customizations:-->
<div data-nosnippet
    style="display:none"
>

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

</div>

<!--
...... section Factoring Tricks ......
-->
<h4 id="autosec-152">Factoring Tricks</h4>
<a id="index-autopage-152"></a>
<a id="index-autofile-9"></a>

<p>
Factoring a polynomial is a ubquitous technique and is especially helpful with certain types of integrals (or rather in avoiding their tedious computation).
</p>

<p>
It is important to show the derivations of these ”tricks”, since they develop critical problem-solving ability. Many of the clever ideas used in obtaining a factorization (especially ”adding zero”) are helpful regardless of context.
</p>
<!--
...... subsection Basic Identities ......
-->
<h5 id="autosec-153">Basic Identities</h5>
<a id="index-autopage-153"></a>


<p>
These are worth ”memorizing” or rather, it’s a very good idea to work enough problems involving these identities that they become muscle memory. Being able to recognize when a problem reduces to one of these expressions is incredibly satisfying.
</p>

<span class="hidden"> \(\seteqnumber{0}{}{2}\)</span>


<!--


                                                                       (a + b)2 = a2 + 2ab + b2


                                                                       (a + b)3 = a3 + 3a2 b + 3ab2 + b3


                                                                       (a2 − b2 ) = (a + b)(a − b)                                                                             Difference of Squares


                                                                       (a3 − b3 ) = (a − b)(a2 + ab + b2 )                                                                       Difference of Cubes




-->


<p>

\begin{align*}
&amp;(a + b)^2 = a^2 + 2ab + b^2 \\\\ &amp;(a + b)^3 = a^3 + 3a^2b + 3ab^2 + b^3 \\\\ &amp;(a^2 - b^2) = (a + b)(a - b) &amp;\text {Difference of Squares} \\\\ &amp;(a^3 - b^3) = (a - b)(a^2 + ab + b^2) &amp;\text {Difference of Cubes}
\\\\
\end{align*}

</p>
<!--
...... subsection Splitting Apart a Monomial ......
-->
<h5 id="autosec-154">Splitting Apart a Monomial</h5>
<a id="index-autopage-154"></a>


<p>
This strategy is mostly a matter of trial and error. The overall objective here varies, but usually what we want is to be able to decompose a single term into multiple in order to be able to apply a more straightforward technique.
</p>

<p>
Splitting out terms like this doesn’t always work, but it’s simple and cheap to try.
</p>

<span class="hidden"> \(\seteqnumber{0}{}{2}\)</span>


<!--


                                                                                                                  a4 + 2a2 b2 + b4 = a4 + a2 b2 + a2 b2 + b4
                                                                                                                                   = a4 + a2 b2 + b4 + a2 b2
                                                                                                                                   = a2 (a2 + b2 ) + b2 (a2 + b2 )
                                                                                                                                   = (a2 + b2 )2


-->


<p>

\begin{align*}
a^4 + 2a^2b^2 + b^4 &amp;= a^4 + a^2b^2 + a^2b^2 + b^4 \\ &amp;= a^4 + a^2b^2 + b^4 + a^2b^2 \\ &amp;= a^2(a^2 + b^2) + b^2(a^2 + b^2) \\ &amp;= (a^2 + b^2)^2
\end{align*}

</p>

<p>
Intuition for when this works is probably a matter of experience. Here we can see somewhat of a hint due to the fact that \(2a^2b^2\) is suspiciously ”close” to either \(a^4\) or \(b^4\). If a problem doesn’t seem to work out after shuffling the terms around, it’s likely a
good idea to move on to another strategy rather than spend a lot of time fiddling with this one.
</p>
<!--
...... subsection Adding Zero ......
-->
<h5 id="autosec-155">Adding Zero</h5>
<a id="index-autopage-155"></a>


<p>
A fan favorite. This is used quite frequently in clever proofs as well as in simplifying nasty computations. The intuition for when to try this comes with experience and time. Until then, it’ll seem like a dirty trick reserved for the truly enlightened.
</p>

<p>
Patience is key here.
</p>

<p>
The idea is similar in spirit to splitting part a monomial with the exception that the term we’re breaking up is ”invisible”. We’re free to add and subtract the same quantity of course, since we’d just be <em>adding zero</em>. This can be a good way to break up a rational
expression or introduce a ”missing” term that would support a factorization.
</p>

<span class="hidden"> \(\seteqnumber{0}{}{2}\)</span>


<!--


                                                                                                             x5 + x + 1 = x5 + (x4 + x3 + x2 − x4 − x3 − x2 ) + x + 1
                                                                                                                        = x3 (x2 + x + 1) − x2 (x2 + x + 1) + x2 + x + 1
                                                                                                                        = (x3 − x2 + 1)(x2 + x + 1)


-->


<p>

\begin{align*}
x^5 + x + 1 &amp;= x^5 + (x^4 + x^3 + x^2 - x^4 - x^3 - x^2) + x + 1 \\ &amp;= x^3(x^2 + x + 1) - x^2(x^2 + x + 1) + x^2 + x + 1 \\ &amp;= (x^3 - x^2 + 1)(x^2 + x + 1)
\end{align*}

</p>

<p>
The particular usage of adding zero above is sometimes called adding back the ”annihilated” term(s). The reasoning behind this is that we imagine the term we want to add back as being cancelled out (annihiliated) at some point during the expansion of the polynomial.
</p>

<p>
As with other techniques, there isn’t a universal indicator as to whether this one will work. Even in the event that adding zero doesn’t work, however, some information is usually gained from the attempt.
</p>
<!--
...... subsection ......
-->
<h5 id="autosec-156">\((a^n - b^n) \)</h5>
<a id="index-autopage-156"></a>


<p>
Here is a good example of where adding zero works really well. We know at some point in any polynomial of degree \(n\) there must have been terms raised to the power \(1, 2, \dots , n-1\), so the key idea is to enumerate them and see how the problem changes.
</p>

<p>
Adding this many terms back ought to be done systematically so none is left out. If we ignore the coefficients (they get cancelled out anyway), we can make use of the binomial theorem as a completely mechanical way of writing down these terms in the same way every time.
</p>

<p>
\[ \sum _{k=1}^n a^{n-k} b^k \]
</p>

<p>
This has the somewhat unfortunate drawback of itemizing each term in a specific order, which may make it more difficult to see how the terms can be rearranged to work their magic. Some books that show off this strategy appear to magically place the terms in precisely
the correct location that reveals the solution.
</p>

<p>
Good for them.
</p>

<p>
It’s worth spending some time playing around with the ordering and making some educated guesses, but spending a lot of time trying dozens of permutations is ill-advised<sup>4</sup>.
</p>

<p>
These derivations are worth working out as practice for manipulating terms and the satisfaction of solving the puzzle, however, after a few cases (maybe two), a general pattern starts to emerge. It’s probably a good idea to conserve brain power and jot down the general
identities somewhere (like GitHub) for posterity rather than working them out each time from scratch.
</p>

<p>
After fooling around for awhile, the simplicity of having an \((a - b)\) factor in the solution seems plausible. It’s good to stop and think about this hypothesis. If we’re after \((a - b)\), it wouldn’t make sense to group \((-ab^2 - b^3)\), since the \(-1\) would factor
out into \(-(ab^2 + b^3)\). This at least tells us that we should think about grouping terms with alternate signs. Such clues are subtle, but can save some wasted effort.
</p>

<p>
All that remains is to keep working at the problem until all the pieces fit or it’s time to take a break and grab another coffee.
</p>

<span class="hidden"> \(\seteqnumber{0}{}{2}\)</span>


<!--


                                                                                                                   a3 − b3 = a3 + (a2 b + ab2 − a2 b − ab2 ) − b3
                                                                                                                            = (a3 − a2 b) + (a2 b − ab2 ) + (ab3 − b3 )
                                                                                                                            = a2 (a − b) + ab(a − b) + b2 (a − b)
                                                                                                                            = (a − b)(a2 + ab + b2 )


-->


<p>

\begin{align*}
a^3 - b^3 &amp;= a^3 + (a^2b + ab^2 - a^2b - ab^2) - b^3 \\ &amp;= (a^3 - a^2b) + (a^2b - ab^2) + (ab^3 - b^3) \\ &amp;= a^2(a - b) + ab(a - b) + b^2(a-b) \\ &amp;= (a - b)(a^2 + ab + b^2)
\end{align*}

</p>

<p>
Here’s another example:
</p>

<span class="hidden"> \(\seteqnumber{0}{}{2}\)</span>


<!--


                                                                                                           a4 − b4 = a4 + a3 b + a2 b2 + ab3 − a3 b − a2 b2 − ab3 − b4
                                                                                                                   = (a4 − a3 b) + (a2 b2 − ab3 ) + (a3 b − a2 b2 ) + (ab3 − b4 )
                                                                                                                   = a3 (a − b) + ab2 (a − b) + a2 b(a − b) + b3 (a − b)
                                                                                                                   = (a − b)(a3 + a2 b + ab2 + b3 )


-->


<p>

\begin{align*}
a^4 - b^4 &amp;= a^4 + a^3b + a^2b^2 + ab^3 -a^3b - a^2b^2 - ab^3 - b^4 \\ &amp;= (a^4 - a^3b) + (a^2b^2 - ab^3) + (a^3b - a^2b^2) + (ab^3 - b^4) \\ &amp;= a^3(a - b) + ab^2(a - b) + a^2b(a - b) + b^3(a - b) \\ &amp;= (a - b)(a^3 + a^2b +
ab^2 + b^3)
\end{align*}

</p>

<p>
Suspiciously similar to the cubic example. A mathematician may be inspired to pose a conjecture and provide a proof. For now, we’ll be satisfied that one is likely to exist and move on.
</p>

<p>
\[ a^n - b^n = (a - b)(a^{n-1} + a^{n-2}b + \dots + ab^{n-2} + b^{n-1}) \]
</p>

<p>
The best thing to do when discovering a new tool is play around with it. Here’s a general formula, so try some concrete values. An interesting identity arises when \(b = 1\):
</p>

<p>
\[ (a^n - 1) = (a - 1)(a^{n-1} + a^{n-2} + \dots + a + 1) \]
</p>
<div role="note" class="footnotes">

<a id="index-autopage-157"></a>
<p>
<sup>4</sup>&nbsp;Perhaps there is a rhyme or reason to figuring out the way to group the terms and unlock the secret of the factorization, but most of the time it feels like luck. Thankfully, this particular family of factorizations has a general form we can follow
</p>


</div>
<!--
...... subsection ......
-->
<h5 id="autosec-158">\((a^n + b^n) \)</h5>
<a id="index-autopage-158"></a>


<p>
Approaching this kind of problem directly is too difficult. Breaking it into subproblems may reveal a way to re-use some of the techniques previously worked out. Since \(n\) is a positive integer, a good guess is to consider the cases in which \(n\) is even and
odd<sup>5</sup>
</p>
<div role="note" class="footnotes">

<a id="index-autopage-159"></a>
<p>
<sup>5</sup>&nbsp;As it turns out, this is almost always worth a shot when dealing with integers.
</p>


</div>
<!--
...... subsubsection is odd ......
-->
<h6 id="autosec-160">\(n\) is odd</h6>
<a id="index-autopage-160"></a>


<p>
What is special about numbers being raised to an odd power? There are a few ways to think about this, but scribbling down some examples is usually handy:
</p>

<span class="hidden"> \(\seteqnumber{0}{}{2}\)</span>


<!--


                                                                                                                                     23 = 8
                                                                                                                                 43 = 6453 = 125
                                                                                                                                    35 = 243


-->


<p>

\begin{gather*}
2^3 = 8 \\ 4^3 = 64 5^3 = 125 \\ 3^5 = 243
\end{gather*}

</p>

<p>
Nothing terribly insightful, however, this is due to our poor choices of \(a\) and \(b\). Variety is key here, since the forumla should hold for <em>all</em> numbers \(a\) and \(b\). Trying out some negative numbers reveals a big clue:
</p>

<span class="hidden"> \(\seteqnumber{0}{}{2}\)</span>


<!--


                                                                                                                                   −13 = −1
                                                                                                                                   −23 = −8
                                                                                                                                  −35 = −243
                                                                                                                                   −25 = −32


-->


<p>

\begin{gather*}
-1^3 = -1 \\ -2^3 = -8 \\ -3^5 = -243 \\ -2^5 = -32
\end{gather*}

</p>

<p>
This shows that any number \(b^n\) has the same sign as \(b\) when \(n\) is odd. This property combined with the fact that \(a + b = a - (-b)\) allows the technique we showed previously to be used as-is:
</p>

<span class="hidden"> \(\seteqnumber{0}{}{2}\)</span>


<!--


                                                                                                    (an + bn ) = (an − (−bn ))
                                                                                                              = (a − (−b))(an−1 + an−2 (−b) + · · · + a(−b)n−2 + (−b)n−1 )
                                                                                                              = (a + b)(an−1 − an−2 b + · · · − abn−2 + bn−1 )


-->


<p>

\begin{align*}
(a^n + b^n) &amp;= (a^n - (-b^n)) \\ &amp;= (a - (-b))(a^{n-1} + a^{n-2}(-b) + \dots + a(-b)^{n-2} + (-b)^{n-1}) \\ &amp;= (a + b)(a^{n-1} - a^{n-2}b + \dots - ab^{n-2} + b^{n-1})
\end{align*}

</p>

<p>
Thinking through whether \(b\) is raised to an even power or odd power in each of the above terms explains why some terms are subtracted. Concrete examples help.
</p>

</section>

</main>

</div>

<footer>

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

</footer>


<nav class="botnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|Quadratics.html|-->

<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Anthony" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="Personal notes on Mathematics and Computer Science" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Notes on Everything — Quadratics</title>
<link rel="stylesheet" type="text/css" href="lwarp.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
  subequations: "0",
  section: "",
  loader: {
    load: ['[tex]/tagformat', '[tex]/textmacros'],
  },
  startup: {
    ready() {
      // These would be replaced by import commands if you wanted to make
      // a proper extension.
      const Configuration = MathJax._.input.tex.Configuration.Configuration;
      const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
      const Macro = MathJax._.input.tex.Symbol.Macro;
      const TexError = MathJax._.input.tex.TexError.default;
      const ParseUtil = MathJax._.input.tex.ParseUtil.default;
      const expandable = MathJax._.util.Options.expandable;

       // Insert the replacement string into the TeX string, and check
       // that there haven't been too many maxro substitutions (prevents
       // infinite loops).
       const useArgument = (parser, text) => {
         parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
         parser.i = 0;
         if (++parser.macroCount > parser.configuration.options.maxMacros) {
           throw new TexError('MaxMacroSub1',
           'MathJax maximum macro substitution count exceeded; ' +
           'is there a recursive macro call?');
         }
       }

       // Create the command map for:
       //     \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
       new CommandMap('Lwarp-macros', {
         ifstar: 'IfstarFunction',
         ifnextchar: 'IfnextcharFunction',
         ifblank: 'IfblankFunction',
         ifstrequal: 'IfstrequalFunction',
         gsubstitute: 'GsubstituteFunction',
         seteqnumber: 'SeteqnumberFunction'
       }, {
         // This function implements an ifstar macro.
         IfstarFunction(parser, name) {
            const resultstar = parser.GetArgument(name);
            const resultnostar = parser.GetArgument(name);
            const star = parser.GetStar();                 // true if there is a *
            useArgument(parser, star ? resultstar : resultnostar);
         },

          // This function implements an ifnextchar macro.
          IfnextcharFunction(parser, name) {
            let whichchar = parser.GetArgument(name);
            if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
              // $ syntax highlighting
              whichchar = String.fromCodePoint(parseInt(whichchar));
            }
            const resultnextchar = parser.GetArgument(name);
            const resultnotnextchar = parser.GetArgument(name);
            const gotchar = (parser.GetNext() === whichchar);
            useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
          },

          // This function implements an ifblank macro.
          IfblankFunction(parser, name) {
            const blankarg = parser.GetArgument(name);
            const resultblank = parser.GetArgument(name);
            const resultnotblank = parser.GetArgument(name);
            const isblank = (blankarg.trim() == "");
            useArgument(parser, isblank ? resultblank : resultnotblank);
          },

          // This function implements an ifstrequal macro.
          IfstrequalFunction(parser, name) {
            const strequalfirst = parser.GetArgument(name);
            const strequalsecond = parser.GetArgument(name);
            const resultequal = parser.GetArgument(name);
            const resultnotequal = parser.GetArgument(name);
            const isequal = (strequalfirst == strequalsecond);
            useArgument(parser, isequal ? resultequal : resultnotequal);
          },

          // This function implements a gsub macro.
          GsubstituteFunction(parser, name) {
            const gsubfirst = parser.GetArgument(name);
            const gsubsecond = parser.GetArgument(name);
            const gsubthird = parser.GetArgument(name);
            let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
            useArgument(parser, gsubresult);
          },

          // This function modifies the equation numbers.
          SeteqnumberFunction(parser, name) {
              // Get the macro parameters
              const star = parser.GetStar();                  // true if there is a *
              const optBrackets = parser.GetBrackets(name);   // contents of optional brackets
              const newsubequations = parser.GetArgument(name); // the subequations argument
              const neweqsection = parser.GetArgument(name); // the eq section argument
              const neweqnumber = parser.GetArgument(name);   // the eq number argument
              MathJax.config.subequations=newsubequations ;   // a string with boolean meaning
              MathJax.config.section=neweqsection ;           // a string with numeric meaning
              parser.tags.counter = parser.tags.allCounter = neweqnumber ;
          }

       });

       // Create the Lwarp-macros package
       Configuration.create('Lwarp-macros', {
         handler: {macro: ['Lwarp-macros']}
       });

       MathJax.startup.defaultReady();

       // For forward references:
       MathJax.startup.input[0].preFilters.add(({math}) => {
         if (math.inputData.recompile){
             MathJax.config.subequations = math.inputData.recompile.subequations;
             MathJax.config.section = math.inputData.recompile.section;
         }
       });
       MathJax.startup.input[0].postFilters.add(({math}) => {
         if (math.inputData.recompile){
             math.inputData.recompile.subequations = MathJax.config.subequations;
             math.inputData.recompile.section = MathJax.config.section;
         }
       });

         // For \left, \right with unicode-math:
         const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
         const {Symbol} = MathJax._.input.tex.Symbol;
         const {MapHandler} = MathJax._.input.tex.MapHandler;
         const delimiter = MapHandler.getMap('delimiter');
         delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
         delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
         delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
         delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
         delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
         delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
         delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
         delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
         delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
         delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
         delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
         delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
         delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
         delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
         delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
         delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
         delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
         delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
         delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
         delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
         delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
         delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
         delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
         delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
         delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
         delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
         delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
         delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
         delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
         delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
         delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
         delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
         delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
         delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
         delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
         delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
         delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
         delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
         delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
   }     // ready
 },      // startup

 tex: {
   packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
   tags: "ams",
        tagformat: {
            number: function (n) {
                if(MathJax.config.subequations==0)
                    return(MathJax.config.section + n);
                else
                    return(MathJax.config.section + String.fromCharCode(96+n));
            },
        },
 }
}
</script>

<script
    id="MathJax-script"
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="index-autopage-161"></a>
<nav class="topnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Notes on Everything</span>
</p>

<p>
Subjects
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="Sums.html#autosec-6" class="tocchapter" >
Sums</a>
</p>


<p>
<a href="Sums.html#autosec-7" class="tocsection" >
Manipulating Sums</a>
</p>


<p>
<a href="Sums.html#autosec-8" class="tocsubsection" >
Basic Rules</a>
</p>


<p>
<a href="Sums.html#autosec-10" class="tocsubsection" >
Iverson Notation</a>
</p>


<p>
<a href="Sums.html#autosec-13" class="tocsubsection" >
Perturbing the Sum</a>
</p>


<p>
<a href="Sums.html#autosec-16" class="tocsubsection" >
Multiple Sums</a>
</p>


<p>
<a href="Finite-Calculus.html#autosec-24" class="tocsection" >
Finite Calculus</a>
</p>


<p>
<a href="Finite-Calculus.html#autosec-25" class="tocsubsection" >
The Difference Operator</a>
</p>


<p>
<a href="Finite-Calculus.html#autosec-26" class="tocsubsection" >
Rising and Falling Factorials</a>
</p>


<p>
<a href="Algorithms.html#autosec-30" class="tocchapter" >
Algorithms</a>
</p>


<p>
<a href="Algorithms.html#autosec-31" class="tocsection" >
Graphs</a>
</p>


<p>
<a href="Algorithms.html#autosec-32" class="tocsubsection" >
Cuts</a>
</p>


<p>
<a href="Algorithms.html#autosec-42" class="tocsubsection" >
Depth-First Search</a>
</p>


<p>
<a href="Algorithms.html#autosec-44" class="tocsubsection" >
Breadth-First Search</a>
</p>


<p>
<a href="Algorithms.html#autosec-46" class="tocsubsection" >
Topological Ordering</a>
</p>


<p>
<a href="Algorithms.html#autosec-47" class="tocsubsection" >
Strongly Connected Components</a>
</p>


<p>
<a href="Greedy.html#autosec-49" class="tocsection" >
Greedy</a>
</p>


<p>
<a href="Greedy.html#autosec-50" class="tocsubsection" >
Dijkstra’s Shortest Path Algorithm</a>
</p>


<p>
<a href="Greedy.html#autosec-61" class="tocsubsection" >
Prim’s MST Algorithm</a>
</p>


<p>
<a href="Greedy.html#autosec-70" class="tocsubsection" >
Kruskal’s MST Algorithm</a>
</p>


<p>
<a href="Greedy.html#autosec-77" class="tocsubsection" >
Huffman Codes</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-84" class="tocsection" >
Divide and Conquer</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-85" class="tocsubsection" >
Master Theorem</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-87" class="tocsubsection" >
MergeSort</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-89" class="tocsubsection" >
Counting Array Inversions</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-92" class="tocsubsection" >
Karatsuba Multiplication</a>
</p>


<p>
<a href="Combinatorics.html#autosec-94" class="tocchapter" >
Combinatorics</a>
</p>


<p>
<a href="Combinatorics.html#autosec-95" class="tocsection" >
Basics of Counting</a>
</p>


<p>
<a href="Combinatorics.html#autosec-96" class="tocsubsection" >
Product Rule</a>
</p>


<p>
<a href="Combinatorics.html#autosec-99" class="tocsubsection" >
Complement Rule</a>
</p>


<p>
<a href="Combinatorics.html#autosec-103" class="tocsubsection" >
Inclusion/Exclusion</a>
</p>


<p>
<a href="Combinatorics.html#autosec-106" class="tocsubsection" >
Permutations</a>
</p>


<p>
<a href="Probability.html#autosec-109" class="tocchapter" >
Probability</a>
</p>


<p>
<a href="Probability.html#autosec-110" class="tocsection" >
Basics</a>
</p>


<p>
<a href="Probability.html#autosec-111" class="tocsubsection" >
Terminology</a>
</p>


<p>
<a href="Probability.html#autosec-113" class="tocsubsection" >
Naive Definition of Probability</a>
</p>


<p>
<a href="Probability.html#autosec-115" class="tocsubsection" >
Non-Naive Definition of Probability</a>
</p>


<p>
<a href="Foundations.html#autosec-120" class="tocchapter" >
Foundations</a>
</p>


<p>
<a href="Foundations.html#autosec-121" class="tocsection" >
Set Theory</a>
</p>


<p>
<a href="Foundations.html#autosec-125" class="tocsubsection" >
Basic Definitions</a>
</p>


<p>
<a href="Foundations.html#autosec-126" class="tocsubsection" >
Laws</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-152" class="tocsection" >
Factoring Tricks</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-153" class="tocsubsection" >
Basic Identities</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-154" class="tocsubsection" >
Splitting Apart a Monomial</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-155" class="tocsubsection" >
Adding Zero</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-156" class="tocsubsection" >
\((a^n - b^n) \)</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-158" class="tocsubsection" >
\((a^n + b^n) \)</a>
</p>


<p>
<a href="Quadratics.html#autosec-162" class="tocsection" >
Quadratics</a>
</p>


<p>
<a href="Quadratics.html#autosec-163" class="tocsubsection" >
Finding Roots of a Quadratic Function</a>
</p>


<p>
<a href="Quadratics.html#autosec-169" class="tocsubsection" >
Vieta’s Theorem</a>
</p>


<p>
<a href="Quadratics.html#autosec-172" class="tocsubsection" >
The Quadratic Formula</a>
</p>


</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<h1>Notes on Everything</h1>

<!--MathJax customizations:-->
<div data-nosnippet
    style="display:none"
>

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

</div>

<!--
...... section Quadratics ......
-->
<h4 id="autosec-162">Quadratics</h4>
<a id="index-autopage-162"></a>
<a id="index-autofile-10"></a>

<p>
Polynomials of the form \(ax^2 + bx + c\) are called <b>quadratic</b>. They can also be described as polynomials of degree 2, or <b>second order</b>. A huge number of problems in physics and engineering can be modeled after a quadratic equation, and they occur
frequently enough to warrant some special techniques.
</p>

<p>
\[ \boxed {ax^2 + bx + c} \]
</p>

<p>
where \(a \neq 0\)
</p>
<!--
...... subsection Finding Roots of a Quadratic Function ......
-->
<h5 id="autosec-163">Finding Roots of a Quadratic Function</h5>
<a id="index-autopage-163"></a>


<p>
A <b>root</b> of a polynomial function \(f\) is a number, say, \(\alpha \), such that \(f(\alpha ) = 0\). Finding roots of a quadratic function is equivalent to solving \(f(x) = ax^2 + bx + c = 0\).
</p>

<p>
Several techniques for finding roots exist:
</p>
<!--
...... subsubsection Factoring ......
-->
<h6 id="autosec-164">Factoring</h6>
<a id="index-autopage-164"></a>


<p>
Factoring here is used in the same context as listing the factors of an integer, such as in <em>prime factorization</em>. Factoring allows the polynomial to be written in such as a way as to make the values for which it takes on the value zero to be obvious.
</p>

<p>
Every polynomial can be written as a product of its factors. Quadratics have a simple form:
</p>

<p>
\[ P(x) = (x - \alpha )(x - \beta ) \]
</p>

<p>
where \(\alpha \) and \(\beta \) are roots of polynomial \(P\).
</p>

<p>
For example,
</p>

<p>
\[ x^2 - 4 = (x - 2)(x + 2) = 0 \]
</p>

<p>
This can easily be factored by noticing the expression is the difference of two squares. This equation has solutions at \(x \pm 2\).
</p>
<!--
...... subsubsection Completing the Square ......
-->
<h6 id="autosec-165">Completing the Square</h6>
<a id="index-autopage-165"></a>


<p>
A good indication to try this technique is when a quadratic function has a 1 as its first coefficient.
</p>

<p>
\[ x^2 + bx + c \]
</p>

<p>
This is referred to as a <b>reduced quadratic</b> form.
</p>

<p>
Completing the square is often taught as a formula to be memorized without any context or justification as to why it works. It helps to consider both what we mean geometrically and then derive the formula with algebra.
</p>
<!--
...... paragraph Geometric ......
-->


<p>
<span class="paragraph" id="autosec-166">Geometric</span>
<a id="index-autopage-166"></a>

</p>

<p>
TODO
</p>
<!--
...... paragraph Algebraic ......
-->


<p>
<span class="paragraph" id="autosec-167">Algebraic</span>
<a id="index-autopage-167"></a>

</p>

<p>
The clever idea behind coming up with the formula lies in thinking about what term would need to be added to \(x^2 + bx\) in order to make it a perfect square. Another way of thinking about this is how we could start with the square of a binomial, \((x + k)^2\) and
figure out what \(k\) and \(c\) need to be in order to be equivalent to the lefthand side<sup>6</sup>:
</p>

<p>
\[ x^2 + bx = (x + k)^2 - c \]
</p>

<p>
Naively computing \((x + b)^2\) might reveal a hint, since we’d end up with the square of a binomial by design. let \(k = b\):
</p>

<p>
\[ (x + b)^2 = x^2 + 2bx + b^2 \]
</p>

<p>
This is closer, but we got \(2bx\) instead of \(bx\) like we wanted. To get \(bx\), we could let \(k = \frac b 2\). Now see what happens:
</p>

<p>
\[ (x + \frac b 2)^2 = x^2 + 2 (\frac b 2) x + (\frac b 2)^2 \]
</p>

<p>
Nearly there! All that’s left to do is subtract \(c = (\frac b 2)^2\) from the equation. This gives us:
</p>

<p>
\[ \boxed {x^2 + bx = (x + \frac b 2)^2 - (\frac b 2)^2} \]
</p>

<p>
A typical follow-up to completing the square is solving for \(x\) via a shortcut used when an expression is the <em>difference of two squares</em>.
</p>
<div role="note" class="footnotes">

<a id="index-autopage-168"></a>
<p>
<sup>6</sup>&nbsp;Working backwards like this is the way that clicked for me when nothing else did
</p>


</div>
<!--
...... subsection Vieta's Theorem ......
-->
<h5 id="autosec-169">Vieta’s Theorem</h5>
<a id="index-autopage-169"></a>


<p>
Vieta’s theorem describes the roots of a quadratic polynomial in terms of its coefficients. This is especially helpful in eliminating candidates for roots if a more straightforward approach fails.
</p>

<p>
If a quadratic expression \(x^2 + px + q\) has distinct roots \(\alpha , \beta \), then
</p>

<span class="hidden"> \(\seteqnumber{0}{}{2}\)</span>


<!--


                                                                                         α+β                                                                                            = −p           (3)
                                                                                         αβ                                                                                             = −q           (4)


-->


<p>

\begin{align}
&amp;\alpha + \beta &amp;= -p \\ &amp;\alpha \beta &amp;= -q
\end{align}

</p>
<div class="amsthmproof">

<a id="index-autopage-170"></a>

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> (Theorem): <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
Vieta’s theorem also has a corollary:
</p>

<p>
If a quadratic expression \(x^2 + px + q\) has distinct roots \(\alpha , \beta \),
</p>

<p>
\[ (x - \alpha )(x - \beta ) = x^2 - (\alpha + \beta ) + \alpha \beta \]
</p>
<div class="amsthmproof">

<a id="index-autopage-171"></a>

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<!--
...... subsection The Quadratic Formula ......
-->
<h5 id="autosec-172">The Quadratic Formula</h5>
<a id="index-autopage-172"></a>


<p>
The famous quadratic formula has a surprisingly simple derivation based on the formula for completing the square. Simply solving a ”completed square” for \(x\) yields the formula.
</p>

<p>
Begin by factoring out the leading coefficient \(a\):
</p>

<span class="hidden"> \(\seteqnumber{0}{}{4}\)</span>


<!--


                                                                                  b     c
                                                             ax2 + bx + c = x2 + ( )x +
                                                                                  a     a

                                                                                    b 2     b    c
                                                                          = (x +      ) − ( )x −                                                                                      completing the square
                                                                                   2a      2a    a


                                                                                    b 2   b2 − 4ac
                                                                          = (x +      ) −                                                                                                        by algebra
                                                                                   2a        4a2

                                                                                        s                         s
                                                                                  b         b2 − 4ac        b         b2 − 4ac
                                                                          = (x +    +                )(x +    −                )                                                       difference of squares
                                                                                 2a            4a2         2a            4a2

                                                                                                √
                                                                                        b           b2 − 4ac
                                                                           =⇒ x = −       ±
                                                                                       2a             2a

                                                                                            √
                                                                                     −b ±     b2 − 4ac
                                                                           =⇒ x =
                                                                                             2a


-->


<p>

\begin{align*}
\label {eqn:quadratic_formula} ax^2 + bx + c &amp;= x^2 + (\frac b a)x + \frac c a \\\\ &amp;= (x + \frac b {2a})^2 - (\frac b {2a})x - \frac c a &amp;\text {completing the square} \\\\ &amp;= (x + \frac b {2a})^2 - \frac {b^2 - 4ac}
{4a^2} &amp;\text {by algebra} \\\\ &amp;= (x + \frac b {2a} + \sqrt {\frac {b^2 - 4ac} {4a^2}})(x + \frac b {2a} - \sqrt {\frac {b^2 - 4ac} {4a^2}}) &amp;\text {difference of squares} \\\\ &amp;\implies x = -\frac b {2a} \pm \frac {\sqrt
{b^2 - 4ac}} {2a} \\\\ &amp;\implies x = \frac {-b \pm \sqrt {b^2 - 4ac}} {2a}
\end{align*}

</p>
<a id="index-autofile-last"></a>
</section>

</main>

</div>

<footer>

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

</footer>


<nav class="botnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>

</body>
</html>
