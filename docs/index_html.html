<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Anthony" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="Personal notes on Mathematics and Computer Science" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Notes on Everything</title>
<link rel="stylesheet" type="text/css" href="lwarp.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
  subequations: "0",
  section: "",
  loader: {
    load: ['[tex]/tagformat', '[tex]/textmacros'],
  },
  startup: {
    ready() {
      // These would be replaced by import commands if you wanted to make
      // a proper extension.
      const Configuration = MathJax._.input.tex.Configuration.Configuration;
      const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
      const Macro = MathJax._.input.tex.Symbol.Macro;
      const TexError = MathJax._.input.tex.TexError.default;
      const ParseUtil = MathJax._.input.tex.ParseUtil.default;
      const expandable = MathJax._.util.Options.expandable;

       // Insert the replacement string into the TeX string, and check
       // that there haven't been too many maxro substitutions (prevents
       // infinite loops).
       const useArgument = (parser, text) => {
         parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
         parser.i = 0;
         if (++parser.macroCount > parser.configuration.options.maxMacros) {
           throw new TexError('MaxMacroSub1',
           'MathJax maximum macro substitution count exceeded; ' +
           'is there a recursive macro call?');
         }
       }

       // Create the command map for:
       //     \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
       new CommandMap('Lwarp-macros', {
         ifstar: 'IfstarFunction',
         ifnextchar: 'IfnextcharFunction',
         ifblank: 'IfblankFunction',
         ifstrequal: 'IfstrequalFunction',
         gsubstitute: 'GsubstituteFunction',
         seteqnumber: 'SeteqnumberFunction'
       }, {
         // This function implements an ifstar macro.
         IfstarFunction(parser, name) {
            const resultstar = parser.GetArgument(name);
            const resultnostar = parser.GetArgument(name);
            const star = parser.GetStar();                 // true if there is a *
            useArgument(parser, star ? resultstar : resultnostar);
         },

         // This function implements an ifnextchar macro.
         IfnextcharFunction(parser, name) {
           let whichchar = parser.GetArgument(name);
           if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
             // $ syntax highlighting
             whichchar = String.fromCodePoint(parseInt(whichchar));
           }
           const resultnextchar = parser.GetArgument(name);
           const resultnotnextchar = parser.GetArgument(name);
           const gotchar = (parser.GetNext() === whichchar);
           useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
         },

         // This function implements an ifblank macro.
         IfblankFunction(parser, name) {
           const blankarg = parser.GetArgument(name);
           const resultblank = parser.GetArgument(name);
           const resultnotblank = parser.GetArgument(name);
           const isblank = (blankarg.trim() == "");
           useArgument(parser, isblank ? resultblank : resultnotblank);
         },

         // This function implements an ifstrequal macro.
         IfstrequalFunction(parser, name) {
           const strequalfirst = parser.GetArgument(name);
           const strequalsecond = parser.GetArgument(name);
           const resultequal = parser.GetArgument(name);
           const resultnotequal = parser.GetArgument(name);
           const isequal = (strequalfirst == strequalsecond);
           useArgument(parser, isequal ? resultequal : resultnotequal);
         },

         // This function implements a gsub macro.
         GsubstituteFunction(parser, name) {
           const gsubfirst = parser.GetArgument(name);
           const gsubsecond = parser.GetArgument(name);
           const gsubthird = parser.GetArgument(name);
           let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
           useArgument(parser, gsubresult);
         },

         // This function modifies the equation numbers.
         SeteqnumberFunction(parser, name) {
             // Get the macro parameters
             const star = parser.GetStar();                  // true if there is a *
             const optBrackets = parser.GetBrackets(name);   // contents of optional brackets
             const newsubequations = parser.GetArgument(name); // the subequations argument
             const neweqsection = parser.GetArgument(name); // the eq section argument
             const neweqnumber = parser.GetArgument(name);   // the eq number argument
             MathJax.config.subequations=newsubequations ;   // a string with boolean meaning
             MathJax.config.section=neweqsection ;           // a string with numeric meaning
             parser.tags.counter = parser.tags.allCounter = neweqnumber ;
         }

       });

       // Create the Lwarp-macros package
       Configuration.create('Lwarp-macros', {
         handler: {macro: ['Lwarp-macros']}
       });

       MathJax.startup.defaultReady();

       // For forward references:
       MathJax.startup.input[0].preFilters.add(({math}) => {
         if (math.inputData.recompile){
             MathJax.config.subequations = math.inputData.recompile.subequations;
             MathJax.config.section = math.inputData.recompile.section;
         }
       });
       MathJax.startup.input[0].postFilters.add(({math}) => {
         if (math.inputData.recompile){
             math.inputData.recompile.subequations = MathJax.config.subequations;
             math.inputData.recompile.section = MathJax.config.section;
         }
       });

         // For \left, \right with unicode-math:
         const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
         const {Symbol} = MathJax._.input.tex.Symbol;
         const {MapHandler} = MathJax._.input.tex.MapHandler;
         const delimiter = MapHandler.getMap('delimiter');
         delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
         delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
         delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
         delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
         delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
         delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
         delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
         delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
         delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
         delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
         delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
         delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
         delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
         delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
         delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
         delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
         delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
         delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
         delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
         delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
         delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
         delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
         delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
         delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
         delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
         delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
         delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
         delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
         delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
         delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
         delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
         delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
         delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
         delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
         delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
         delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
         delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
         delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
         delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
   }     // ready
 },      // startup

 tex: {
   packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
   tags: "ams",
        tagformat: {
            number: function (n) {
                if(MathJax.config.subequations==0)
                    return(MathJax.config.section + n);
                else
                    return(MathJax.config.section + String.fromCharCode(96+n));
            },
        },
 }
}
</script>

<script
    id="MathJax-script"
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>
<!--|Using lwarp|index-0.html|-->


<div class="bodywithoutsidetoc">


<main class="bodycontainer">


<section class="textbody">

<a id="index-autofile-0"></a>

<!--MathJax customizations:-->
<div data-nosnippet
    style="display:none"
>

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

</div>

<a id="index-autopage-1"></a>
<div class="titlepage">

<h1>Notes on Everything</h1>


<div class="author">


<div class="oneauthor">

<p>
Anthony
</p>
</div>

</div>


<div class="titledate">

<p>
April 4, 2024
</p>
</div>

</div>

<p>
Notes on Mathematics and Computer Science.
</p>
<!--
...... chapter Subjects ......
-->
<h3 id="autosec-3">Subjects</h3>
<a id="index-autopage-3"></a>



<nav class="toc">

<p>
<a href="Sums.html#autosec-6" class="tocchapter" >
Sums</a>
</p>


<p>
<a href="Sums.html#autosec-7" class="tocsection" >
Manipulating Sums</a>
</p>


<p>
<a href="Algorithms.html#autosec-24" class="tocchapter" >
Algorithms</a>
</p>


<p>
<a href="Algorithms.html#autosec-25" class="tocsection" >
Greedy</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-51" class="tocsection" >
Divide and Conquer</a>
</p>


<p>
<a href="Combinatorics.html#autosec-61" class="tocchapter" >
Combinatorics</a>
</p>


<p>
<a href="Combinatorics.html#autosec-62" class="tocsection" >
Basics of Counting</a>
</p>


<p>
<a href="Foundations.html#autosec-70" class="tocchapter" >
Foundations</a>
</p>


<p>
<a href="Foundations.html#autosec-71" class="tocsection" >
Quadratics</a>
</p>
</nav>
<!--
...... chapter List of Figures ......
-->
<h3 id="autosec-4">List of Figures</h3>
<a id="index-autopage-4"></a>



<nav class="lof">

<p>
<a href="Algorithms.html#autoid-1" class="tocfigure" >
<span class="sectionnumber">1</span>&#x2003;Weighted, directed graph</a>
</p>


<p>
<a href="Algorithms.html#autoid-4" class="tocfigure" >
<span class="sectionnumber">2</span>&#x2003;Minimum spanning tree</a>
</p>
</nav>

</section>

</main>

</div>

</body>
</html>
<!--|Start file|Sums.html|-->

<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Anthony" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="Personal notes on Mathematics and Computer Science" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Notes on Everything — Sums</title>
<link rel="stylesheet" type="text/css" href="lwarp.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
  subequations: "0",
  section: "",
  loader: {
    load: ['[tex]/tagformat', '[tex]/textmacros'],
  },
  startup: {
    ready() {
      // These would be replaced by import commands if you wanted to make
      // a proper extension.
      const Configuration = MathJax._.input.tex.Configuration.Configuration;
      const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
      const Macro = MathJax._.input.tex.Symbol.Macro;
      const TexError = MathJax._.input.tex.TexError.default;
      const ParseUtil = MathJax._.input.tex.ParseUtil.default;
      const expandable = MathJax._.util.Options.expandable;

       // Insert the replacement string into the TeX string, and check
       // that there haven't been too many maxro substitutions (prevents
       // infinite loops).
       const useArgument = (parser, text) => {
         parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
         parser.i = 0;
         if (++parser.macroCount > parser.configuration.options.maxMacros) {
           throw new TexError('MaxMacroSub1',
           'MathJax maximum macro substitution count exceeded; ' +
           'is there a recursive macro call?');
         }
       }

       // Create the command map for:
       //     \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
       new CommandMap('Lwarp-macros', {
         ifstar: 'IfstarFunction',
         ifnextchar: 'IfnextcharFunction',
         ifblank: 'IfblankFunction',
         ifstrequal: 'IfstrequalFunction',
         gsubstitute: 'GsubstituteFunction',
         seteqnumber: 'SeteqnumberFunction'
       }, {
         // This function implements an ifstar macro.
         IfstarFunction(parser, name) {
            const resultstar = parser.GetArgument(name);
            const resultnostar = parser.GetArgument(name);
            const star = parser.GetStar();                 // true if there is a *
            useArgument(parser, star ? resultstar : resultnostar);
         },

          // This function implements an ifnextchar macro.
          IfnextcharFunction(parser, name) {
            let whichchar = parser.GetArgument(name);
            if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
              // $ syntax highlighting
              whichchar = String.fromCodePoint(parseInt(whichchar));
            }
            const resultnextchar = parser.GetArgument(name);
            const resultnotnextchar = parser.GetArgument(name);
            const gotchar = (parser.GetNext() === whichchar);
            useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
          },

          // This function implements an ifblank macro.
          IfblankFunction(parser, name) {
            const blankarg = parser.GetArgument(name);
            const resultblank = parser.GetArgument(name);
            const resultnotblank = parser.GetArgument(name);
            const isblank = (blankarg.trim() == "");
            useArgument(parser, isblank ? resultblank : resultnotblank);
          },

          // This function implements an ifstrequal macro.
          IfstrequalFunction(parser, name) {
            const strequalfirst = parser.GetArgument(name);
            const strequalsecond = parser.GetArgument(name);
            const resultequal = parser.GetArgument(name);
            const resultnotequal = parser.GetArgument(name);
            const isequal = (strequalfirst == strequalsecond);
            useArgument(parser, isequal ? resultequal : resultnotequal);
          },

          // This function implements a gsub macro.
          GsubstituteFunction(parser, name) {
            const gsubfirst = parser.GetArgument(name);
            const gsubsecond = parser.GetArgument(name);
            const gsubthird = parser.GetArgument(name);
            let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
            useArgument(parser, gsubresult);
          },

          // This function modifies the equation numbers.
          SeteqnumberFunction(parser, name) {
              // Get the macro parameters
              const star = parser.GetStar();                  // true if there is a *
              const optBrackets = parser.GetBrackets(name);   // contents of optional brackets
              const newsubequations = parser.GetArgument(name); // the subequations argument
              const neweqsection = parser.GetArgument(name); // the eq section argument
              const neweqnumber = parser.GetArgument(name);   // the eq number argument
              MathJax.config.subequations=newsubequations ;   // a string with boolean meaning
              MathJax.config.section=neweqsection ;           // a string with numeric meaning
              parser.tags.counter = parser.tags.allCounter = neweqnumber ;
          }

       });

       // Create the Lwarp-macros package
       Configuration.create('Lwarp-macros', {
         handler: {macro: ['Lwarp-macros']}
       });

       MathJax.startup.defaultReady();

       // For forward references:
       MathJax.startup.input[0].preFilters.add(({math}) => {
         if (math.inputData.recompile){
             MathJax.config.subequations = math.inputData.recompile.subequations;
             MathJax.config.section = math.inputData.recompile.section;
         }
       });
       MathJax.startup.input[0].postFilters.add(({math}) => {
         if (math.inputData.recompile){
             math.inputData.recompile.subequations = MathJax.config.subequations;
             math.inputData.recompile.section = MathJax.config.section;
         }
       });

         // For \left, \right with unicode-math:
         const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
         const {Symbol} = MathJax._.input.tex.Symbol;
         const {MapHandler} = MathJax._.input.tex.MapHandler;
         const delimiter = MapHandler.getMap('delimiter');
         delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
         delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
         delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
         delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
         delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
         delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
         delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
         delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
         delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
         delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
         delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
         delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
         delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
         delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
         delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
         delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
         delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
         delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
         delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
         delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
         delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
         delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
         delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
         delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
         delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
         delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
         delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
         delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
         delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
         delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
         delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
         delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
         delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
         delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
         delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
         delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
         delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
         delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
         delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
   }     // ready
 },      // startup

 tex: {
   packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
   tags: "ams",
        tagformat: {
            number: function (n) {
                if(MathJax.config.subequations==0)
                    return(MathJax.config.section + n);
                else
                    return(MathJax.config.section + String.fromCharCode(96+n));
            },
        },
 }
}
</script>

<script
    id="MathJax-script"
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="index-autopage-5"></a>
<nav class="topnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Notes on Everything</span>
</p>

<p>
Subjects
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="Sums.html#autosec-6" class="tocchapter" >
Sums</a>
</p>


<p>
<a href="Sums.html#autosec-7" class="tocsection" >
Manipulating Sums</a>
</p>


<p>
<a href="Sums.html#autosec-8" class="tocsubsection" >
Basic Rules</a>
</p>


<p>
<a href="Sums.html#autosec-10" class="tocsubsection" >
Iverson Notation</a>
</p>


<p>
<a href="Sums.html#autosec-13" class="tocsubsection" >
Perturbing the Sum</a>
</p>


<p>
<a href="Sums.html#autosec-16" class="tocsubsection" >
Multiple Sums</a>
</p>


<p>
<a href="Algorithms.html#autosec-24" class="tocchapter" >
Algorithms</a>
</p>


<p>
<a href="Algorithms.html#autosec-25" class="tocsection" >
Greedy</a>
</p>


<p>
<a href="Algorithms.html#autosec-26" class="tocsubsection" >
Dijkstra’s Shortest Path Algorithm</a>
</p>


<p>
<a href="Algorithms.html#autosec-34" class="tocsubsection" >
Prim’s MST Algorithm</a>
</p>


<p>
<a href="Algorithms.html#autosec-38" class="tocsubsection" >
Kruskal’s MST Algorithm</a>
</p>


<p>
<a href="Algorithms.html#autosec-45" class="tocsubsection" >
Huffman Codes</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-51" class="tocsection" >
Divide and Conquer</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-52" class="tocsubsection" >
Master Theorem</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-54" class="tocsubsection" >
MergeSort</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-56" class="tocsubsection" >
Counting Array Inversions</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-59" class="tocsubsection" >
Karatsuba Multiplication</a>
</p>


<p>
<a href="Combinatorics.html#autosec-61" class="tocchapter" >
Combinatorics</a>
</p>


<p>
<a href="Combinatorics.html#autosec-62" class="tocsection" >
Basics of Counting</a>
</p>


<p>
<a href="Combinatorics.html#autosec-63" class="tocsubsection" >
Product Rule</a>
</p>


<p>
<a href="Combinatorics.html#autosec-64" class="tocsubsection" >
Complement Rule</a>
</p>


<p>
<a href="Combinatorics.html#autosec-65" class="tocsubsection" >
Sum Rule</a>
</p>


<p>
<a href="Combinatorics.html#autosec-66" class="tocsubsection" >
Inclusion/Exclusion</a>
</p>


<p>
<a href="Combinatorics.html#autosec-67" class="tocsubsection" >
Permutations</a>
</p>


<p>
<a href="Foundations.html#autosec-70" class="tocchapter" >
Foundations</a>
</p>


<p>
<a href="Foundations.html#autosec-71" class="tocsection" >
Quadratics</a>
</p>


<p>
<a href="Foundations.html#autosec-72" class="tocsubsection" >
Finding Roots of a Quadratic Function</a>
</p>


<p>
<a href="Foundations.html#autosec-78" class="tocsubsection" >
Vieta’s Theorem</a>
</p>


<p>
<a href="Foundations.html#autosec-81" class="tocsubsection" >
The Quadratic Formula</a>
</p>


</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<h1>Notes on Everything</h1>

<!--MathJax customizations:-->
<div data-nosnippet
    style="display:none"
>

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

</div>

<!--
...... chapter Sums ......
-->
<h3 id="autosec-6">Sums</h3>
<a id="index-autopage-6"></a>
<a id="index-autofile-1"></a>
<!--
...... section Manipulating Sums ......
-->
<h4 id="autosec-7">Manipulating Sums</h4>
<a id="index-autopage-7"></a>


<p>
Techniques for manipulating summations can often lead to a closed form solution or simpler summation. This is especially helpful when dealing with multiple summations and loops in which the inner index depends on the outer.
</p>
<!--
...... subsection Basic Rules ......
-->
<h5 id="autosec-8">Basic Rules</h5>
<a id="index-autopage-8"></a>


<p>
Often times a complex summation can be simplified using a few simple rules:
</p>

<span class="hidden"> \(\seteqnumber{0}{}{0}\)</span>


<!--


                                                                                                                                                                               Distribution
                                                                         X              X
                                                                              cak = c         ak
                                                                        k∈K             k∈K

                                                                                                                                                                               Association
                                                                         X                    X           X
                                                                              (ak + bk ) =         ak +         bk
                                                                        k∈K                  k∈K          k∈K

                                                                                                                                                                            Commutativity
                                                                         X                     X
                                                                              (ak + bk ) =              ap(k)
                                                                        k∈K                  p(k)∈K 0



-->


<p>

\begin{align*}
&amp;\sum _{k \in K} c a_k = c \sum _{k \in K} a_k &amp;\text {Distribution} \\ &amp;\sum _{k \in K} (a_k + b_k) = \sum _{k \in K} a_k + \sum _{k \in K} b_k &amp;\text {Association} \\ &amp;\sum _{k \in K} (a_k + b_k) = \sum _{p(k) \in
K&apos;} a_{p(k)} &amp;\text {Commutativity}
\end{align*}

</p>

<p>
where \(p(k)\) is a <em>permutation</em> of the elements of \(k\) to some set with image \(p(k)\)
</p>

<p>
For example, suppose \(K = \{-1, 0, 1\}\) and \(p(k) = -k\), then \(p : K \mapsto K&apos;\) where \(K&apos; = \{1, 0, -1\}\). The end result is the terms of \(K\) are rearranged, and by <b>commutativity</b>, the summation is equal to the original ordering.
</p>
<!--
...... subsubsection Example ......
-->
<h6 id="autosec-9">Example</h6>
<a id="index-autopage-9"></a>


<p>
Using the rules above, we can simplify the following summation:
</p>

<span class="hidden"> \(\seteqnumber{0}{}{0}\)</span>


<!--


                                                                                  X
                                                                            S=           (a + bk)
                                                                                 0⩽k⩽n

                                                                                                                                                              \(a\) is constant
                                                                                               X
                                                                               = a(n + 1) +            bk
                                                                                              0⩽k⩽n

                                                                                                                                                                \(k \to n-k\)
                                                                                                   X
                                                                               = a(n + 1) +                 bn − bk
                                                                                              0⩽n−k⩽n

                                                                                                                                                                \(n-k \to k\)
                                                                                               X
                                                                               = a(n + 1) +            bn − bk
                                                                                              0⩽k⩽n




-->


<p>

\begin{align*}
\label {eq:sum_manip_example} S &amp;= \sum _{0 \leqslant k \leqslant n} (a + bk) \\ &amp;= a(n+1) + \sum _{0 \leqslant k \leqslant n} bk &amp;\text {$a$ is constant} \\ &amp;= a(n+1) + \sum _{0 \leqslant n-k \leqslant n} bn - bk
&amp;\text {$k \to n-k$} \\ &amp;= a(n+1) + \sum _{0 \leqslant k \leqslant n} bn - bk &amp;\text {$n-k \to k$} \\
\end{align*}

</p>

<p>
We employ another technique of adding \(S\) to itself and solving a simplified expression
</p>

<span class="hidden"> \(\seteqnumber{0}{}{0}\)</span>


<!--


                                                                     X                                 X
                                                             2S =         (a + bk) + a(n + 1) +               bn − bk
                                                                    0⩽k⩽n                           0⩽k⩽n

                                                                                                                                                     combining summations and simplifying
                                                                                X
                                                                  = a(n + 1)           (an + bn)
                                                                               0⩽k⩽n

                                                                  = (n + 1)(2a + bn)                                                                                \(an\), \(bn\) constant


-->


<p>

\begin{align*}
2S &amp;= \sum _{0 \leqslant k \leqslant n} (a + bk) + a(n+1) + \sum _{0 \leqslant k \leqslant n} bn - bk \\ &amp;= a(n+1) \sum _{0 \leqslant k \leqslant n} (an + bn) &amp;\text {combining summations and simplifying} \\ &amp;= (n+1)(2a +
bn) &amp;\text {$an$, $bn$ constant}
\end{align*}

</p>

<p>
Finally, dividing by 2 we get \(S = (a + \frac 1 2 bn)(n+1)\)
</p>
<!--
...... subsection Iverson Notation ......
-->
<h5 id="autosec-10">Iverson Notation</h5>
<a id="index-autopage-10"></a>


<p>
In order to make manipulation of indexes easier, we can use notation invented by Kenneth E. Iverson as an indicator function:
</p>

<span class="hidden"> \(\seteqnumber{0}{}{0}\)</span>

<!--


                                                                        1 if \(P\) is true
                                                                    (
                                                           [P ] =                                                               --><a id="eqn:iverson"></a><!--
                                                                        0 otherwise

-->

<p>

\begin{equation*}
\label {eqn:iverson} [P] = \begin{cases} 1 &amp; \text {if $P$ is true} \\ 0 &amp; \text {otherwise} \end {cases}
\end{equation*}

</p>
<!--
...... subsubsection Properties ......
-->
<h6 id="autosec-11">Properties</h6>
<a id="index-autopage-11"></a>


<p>
Iverson brackets can be manipulated in the same way as set operations:
</p>

<span class="hidden"> \(\seteqnumber{0}{}{0}\)</span>


<!--


                                                                                                                 [P ∧ Q] = [P ][Q]


                                                                                                           [P ∨ Q] = [P ] + [Q] − [P ][Q]


                                                                                                                  [¬P ] = 1 − [P ]


                                                                                                   [k ∈ A] + [k ∈ B] = [k ∈ A ∪ B] + [k ∈ A ∩ B]


                                                                                                           [k ∈ A ∩ B] = [k ∈ A][k ∈ B]


-->


<p>

\begin{gather*}
[P \land Q] = [P][Q] \\\\ [P \lor Q] = [P] + [Q] - [P][Q] \\\\ [\lnot P] = 1 - [P] \\\\ [k \in A] + [k \in B] = [k \in A \cup B] + [k \in A \cap B] \\\\ [k \in A \cap B] = [k \in A][k \in B]
\end{gather*}

</p>
<!--
...... subsubsection Example ......
-->
<h6 id="autosec-12">Example</h6>
<a id="index-autopage-12"></a>


<p>
Using Iverson brackets, the ”double-counting” summation identity can be derived directly from the above properties.
</p>

<span class="hidden"> \(\seteqnumber{0}{}{0}\)</span>

<!--


                                                                                                             [k ∈ K] + [k ∈ K 0 ] = [k ∈ K ∩ K 0 ] + [k ∈ K ∪ K 0 ]

-->

<p>

\begin{equation*}
[k \in K] + [k \in K&apos;] = [k \in K \cap K&apos;] + [k \in K \cup K&apos;]
\end{equation*}

</p>

<p>
which translates to summations with indices:
</p>

<span class="hidden"> \(\seteqnumber{0}{}{0}\)</span>

<!--

                                                                                                                X            X               X                X
                                                                                                                      ak +           ak =             ak +             ak
                                                                                                                k∈K          k∈K 0          k∈k∩K 0          k∈k∪K 0

-->

<p>

\begin{equation*}
\sum _{k \in K} a_k + \sum _{k \in K&apos;} a_k = \sum _{k \in k \cap K&apos;} a_k + \sum _{k \in k \cup K&apos;} a_k
\end{equation*}

</p>
<!--
...... subsection Perturbing the Sum ......
-->
<h5 id="autosec-13">Perturbing the Sum</h5>
<a id="index-autopage-13"></a>


<p>
Another technique is to manipulate the first and last terms. This reveal a way to solve the summation via the above manipulations.
</p>
<!--
...... subsubsection Example ......
-->
<h6 id="autosec-14">Example</h6>
<a id="index-autopage-14"></a>


<p>
For example, take the following summation representing a geometric series. A good approach is to write \(S_{n+1}\) in terms of \(S_n\) and simplify the right side of the equation.
</p>

<p>
Consider the following summation:
</p>

<p>
\[ S_n = \sum _{0 \leqslant k \leqslant n} ax^k \]
</p>

<p>
Adding the \(n+1\)st term and solving for \(S_n\):
</p>

<span class="hidden"> \(\seteqnumber{0}{}{0}\)</span>


<!--


                                                                                                                                X
                                                                                                           Sn + axn+1 = a +             axk
                                                                                                                              1⩽k⩽n+1
                                                                                                                                                    X
                                                                                                                        ⇐⇒ Sn + axn+1 = a +                 axk+1
                                                                                                                                                1⩽k+1⩽n+1
                                                                                                                                                  X
                                                                                                                        ⇐⇒ Sn + axn+1 = a +             axk+1
                                                                                                                                                0⩽k⩽n

                                                                                                                        ⇐⇒ Sn + axn+1 = a + xSn
                                                                                                                                   a − axn+1
                                                                                                                        ⇐⇒ Sn =
                                                                                                                                     1−x


-->


<p>

\begin{align*}
S_n + ax^{n+1} &amp;= a + \sum _{1 \leqslant k \leqslant n+1} ax^k \\ &amp;\iff S_n + ax^{n+1} = a + \sum _{1 \leqslant k+1 \leqslant n+1} ax^{k+1} \\ &amp;\iff S_n + ax^{n+1} = a + \sum _{0 \leqslant k \leqslant n} ax^{k+1} \\ &amp;\iff
S_n + ax^{n+1} = a + xS_n \\ &amp;\iff S_n = \frac {a - ax^{n+1}} {1 - x}
\end{align*}

</p>
<!--
...... subsubsection Example ......
-->
<h6 id="autosec-15">Example</h6>
<a id="index-autopage-15"></a>


<p>
Taking another example and using the results from the previous derivation, the following sum is solved almost in the exact same way:
</p>

<p>
\[ S_n = \sum _{0 \leqslant k \leqslant n} k2^k \]
</p>

<p>
Once again perturbing the sum:
</p>

<span class="hidden"> \(\seteqnumber{0}{}{0}\)</span>


<!--


                                                                                                                                       X
                                                                                                         Sn + (n + 1)2n+1 = 0 +                k2k+1
                                                                                                                                  1⩽k⩽n+1


                                                                                                                                  X                       X
                                                                                                                           =                k2k+1 +                2k+1
                                                                                                                               1⩽k+1⩽n+1               1⩽k+1⩽n+1


                                                                                                                                        X
                                                                                                                           = 2Sn +             2k+1
                                                                                                                                       0⩽k⩽n



-->


<p>

\begin{align*}
S_n + (n+1)2^{n+1} &amp;= 0 + \sum _{1 \leqslant k \leqslant n+1} k2^{k+1} \\\\ &amp;= \sum _{1 \leqslant k+1 \leqslant n+1} k2^{k+1} + \sum _{1 \leqslant k+1 \leqslant n+1} 2^{k+1} \\\\ &amp;= 2S_n + \sum _{0 \leqslant k \leqslant n}
2^{k+1}
\end{align*}

</p>

<p>
The second sum is a geometric series, and so after evaluating and simplifying:
</p>

<p>
\[ S_n = \frac {2 - 2^{n+2}} {1 - 2} - (n+1)2^{n+1} = (n-1)2^{n+1} + 2 \]
</p>
<!--
...... subsection Multiple Sums ......
-->
<h5 id="autosec-16">Multiple Sums</h5>
<a id="index-autopage-16"></a>


<p>
When a summation is indexed by two or more indices, it can be written with more than one sigma:
</p>

<p>
\[ \sum _{1 \leqslant j, k \leqslant n} a_j b_k = \sum _{1 \leqslant j \leqslant n} \sum _{1 \leqslant k \leqslant n} b_k \]
</p>

<p>
Summations of this form are evaulated ”right-to-left” or by taking the ”inner” summtation first. In the above example, the summation over \(k\) happens first.
</p>
<!--
...... subsubsection Interchanging Indices ......
-->
<h6 id="autosec-17">Interchanging Indices</h6>
<a id="index-autopage-17"></a>


<p>
When indices are independent, this is simply a matter of rearranging the sums. Complications arise when the inner index depends on the outer. The abstract way of denoting an exchange of indicies:
</p>

<p>
\[ \sum _j \sum _k a_{j,k} [P(j, k)] = \sum _{P(j,k)} a_{j,k} [P(j,k)] = \sum _k \sum _j a_{j,k} [P(j,k)] \]
</p>

<p>
is a generalization of the associativity rule.
</p>
<!--
...... subsubsection Example ......
-->
<h6 id="autosec-18">Example</h6>
<a id="index-autopage-18"></a>


<p>
This example shows how multiple summations can be split apart by applying the associative rule and using Iverson notation.
</p>

<p>
Since the indices are independent, the summations can occur in either order.
</p>

<span class="hidden"> \(\seteqnumber{0}{}{0}\)</span>


<!--


                                                                                                              X                 X
                                                                                                                      aj bk =         aj bk [1 ⩽ j ⩽ 3][1 ⩽ k ⩽ 3]
                                                                                                            1⩽j,k⩽3             j,k
                                                                                                                                X                      X
                                                                                                                           =          aj [1 ⩽ j ⩽ 3]       bk [1 ⩽ k ⩽ 3]
                                                                                                                                 j                     k
                                                                                                                                3
                                                                                                                                X          3
                                                                                                                                           X
                                                                                                                           =          aj         bk
                                                                                                                                j=1        k=1



-->


<p>

\begin{align*}
\sum _{1 \leqslant j,k \leqslant 3} a_j b_k &amp;= \sum _{j,k} a_j b_k [1 \leqslant j \leqslant 3][1 \leqslant k \leqslant 3] \\ &amp;= \sum _j a_j [1 \leqslant j \leqslant 3] \sum _k b_k [1 \leqslant k \leqslant 3] \\ &amp;= \sum
_{j=1}^3 a_j \sum _{k=1}^3 b_k
\end{align*}

</p>
<!--
...... subsubsection Harder Example ......
-->
<h6 id="autosec-19">Harder Example</h6>
<a id="index-autopage-19"></a>


<p>
In this example, \(j\) is related to the value of \(k\). Again, the problem can be reduced into manipulating the inequalities using Iverson notation. Using the following identity written in Iverson brackets:
</p>

<p>
\[ [1 \leqslant j \leqslant n][j \leqslant k \leqslant n] = [1 \leqslant j,k \leqslant n] = [1 \leqslant k \leqslant n][1 \leqslant j \leqslant k] \]
</p>
<div class="center">

<p>
<span
    id="lateximage-index-1"
    class="lateximagesource"
><!--
1   j   k   n
--><img
    src="index-images/image-1.svg"
    alt="(-tikz-&nbsp;diagram)"
    style=""
    class="lateximage"
></span>
</p>
</div>

<p>
This holds by combining the first two brackets by writing their intersection as one inequality and by splitting it apart again.
</p>

<p>
An equivalent double summation can be manipulated using the above identity:
</p>

<span class="hidden"> \(\seteqnumber{0}{}{0}\)</span>


<!--


                                                                                                                         X        X              X
                                                                                                                                      aj,k =             aj,k
                                                                                                                        1⩽j⩽n j⩽k⩽n            1⩽j,k⩽n


                                                                                                                                                X        X
                                                                                                                                          =                     aj,k
                                                                                                                                               1⩽k⩽n 1⩽j⩽k



                                                                                                                                               n X
                                                                                                                                               X k
                                                                                                                                          =              aj,k
                                                                                                                                               k=1 j=1



-->


<p>

\begin{align*}
\sum _{1 \leqslant j \leqslant n} \sum _{j \leqslant k \leqslant n} a_{j,k} &amp;= \sum _{1 \leqslant j,k \leqslant n} a_{j,k} \\\\ &amp;= \sum _{1 \leqslant k \leqslant n} \sum _{1 \leqslant j \leqslant k} a_{j,k} \\\\ &amp;= \sum
_{k=1}^n \sum _{j=1}^k a_{j,k}
\end{align*}

</p>

<p>
Hopefully, the second summation turns out to be easier to evaluate.
</p>

</section>

</main>

</div>

<footer>

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

</footer>


<nav class="botnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|Algorithms.html|-->

<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Anthony" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="Personal notes on Mathematics and Computer Science" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Notes on Everything — Algorithms</title>
<link rel="stylesheet" type="text/css" href="lwarp.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
  subequations: "0",
  section: "",
  loader: {
    load: ['[tex]/tagformat', '[tex]/textmacros'],
  },
  startup: {
    ready() {
      // These would be replaced by import commands if you wanted to make
      // a proper extension.
      const Configuration = MathJax._.input.tex.Configuration.Configuration;
      const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
      const Macro = MathJax._.input.tex.Symbol.Macro;
      const TexError = MathJax._.input.tex.TexError.default;
      const ParseUtil = MathJax._.input.tex.ParseUtil.default;
      const expandable = MathJax._.util.Options.expandable;

       // Insert the replacement string into the TeX string, and check
       // that there haven't been too many maxro substitutions (prevents
       // infinite loops).
       const useArgument = (parser, text) => {
         parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
         parser.i = 0;
         if (++parser.macroCount > parser.configuration.options.maxMacros) {
           throw new TexError('MaxMacroSub1',
           'MathJax maximum macro substitution count exceeded; ' +
           'is there a recursive macro call?');
         }
       }

       // Create the command map for:
       //     \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
       new CommandMap('Lwarp-macros', {
         ifstar: 'IfstarFunction',
         ifnextchar: 'IfnextcharFunction',
         ifblank: 'IfblankFunction',
         ifstrequal: 'IfstrequalFunction',
         gsubstitute: 'GsubstituteFunction',
         seteqnumber: 'SeteqnumberFunction'
       }, {
         // This function implements an ifstar macro.
         IfstarFunction(parser, name) {
            const resultstar = parser.GetArgument(name);
            const resultnostar = parser.GetArgument(name);
            const star = parser.GetStar();                 // true if there is a *
            useArgument(parser, star ? resultstar : resultnostar);
         },

          // This function implements an ifnextchar macro.
          IfnextcharFunction(parser, name) {
            let whichchar = parser.GetArgument(name);
            if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
              // $ syntax highlighting
              whichchar = String.fromCodePoint(parseInt(whichchar));
            }
            const resultnextchar = parser.GetArgument(name);
            const resultnotnextchar = parser.GetArgument(name);
            const gotchar = (parser.GetNext() === whichchar);
            useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
          },

          // This function implements an ifblank macro.
          IfblankFunction(parser, name) {
            const blankarg = parser.GetArgument(name);
            const resultblank = parser.GetArgument(name);
            const resultnotblank = parser.GetArgument(name);
            const isblank = (blankarg.trim() == "");
            useArgument(parser, isblank ? resultblank : resultnotblank);
          },

          // This function implements an ifstrequal macro.
          IfstrequalFunction(parser, name) {
            const strequalfirst = parser.GetArgument(name);
            const strequalsecond = parser.GetArgument(name);
            const resultequal = parser.GetArgument(name);
            const resultnotequal = parser.GetArgument(name);
            const isequal = (strequalfirst == strequalsecond);
            useArgument(parser, isequal ? resultequal : resultnotequal);
          },

          // This function implements a gsub macro.
          GsubstituteFunction(parser, name) {
            const gsubfirst = parser.GetArgument(name);
            const gsubsecond = parser.GetArgument(name);
            const gsubthird = parser.GetArgument(name);
            let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
            useArgument(parser, gsubresult);
          },

          // This function modifies the equation numbers.
          SeteqnumberFunction(parser, name) {
              // Get the macro parameters
              const star = parser.GetStar();                  // true if there is a *
              const optBrackets = parser.GetBrackets(name);   // contents of optional brackets
              const newsubequations = parser.GetArgument(name); // the subequations argument
              const neweqsection = parser.GetArgument(name); // the eq section argument
              const neweqnumber = parser.GetArgument(name);   // the eq number argument
              MathJax.config.subequations=newsubequations ;   // a string with boolean meaning
              MathJax.config.section=neweqsection ;           // a string with numeric meaning
              parser.tags.counter = parser.tags.allCounter = neweqnumber ;
          }

       });

       // Create the Lwarp-macros package
       Configuration.create('Lwarp-macros', {
         handler: {macro: ['Lwarp-macros']}
       });

       MathJax.startup.defaultReady();

       // For forward references:
       MathJax.startup.input[0].preFilters.add(({math}) => {
         if (math.inputData.recompile){
             MathJax.config.subequations = math.inputData.recompile.subequations;
             MathJax.config.section = math.inputData.recompile.section;
         }
       });
       MathJax.startup.input[0].postFilters.add(({math}) => {
         if (math.inputData.recompile){
             math.inputData.recompile.subequations = MathJax.config.subequations;
             math.inputData.recompile.section = MathJax.config.section;
         }
       });

         // For \left, \right with unicode-math:
         const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
         const {Symbol} = MathJax._.input.tex.Symbol;
         const {MapHandler} = MathJax._.input.tex.MapHandler;
         const delimiter = MapHandler.getMap('delimiter');
         delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
         delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
         delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
         delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
         delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
         delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
         delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
         delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
         delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
         delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
         delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
         delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
         delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
         delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
         delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
         delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
         delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
         delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
         delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
         delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
         delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
         delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
         delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
         delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
         delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
         delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
         delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
         delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
         delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
         delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
         delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
         delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
         delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
         delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
         delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
         delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
         delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
         delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
         delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
   }     // ready
 },      // startup

 tex: {
   packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
   tags: "ams",
        tagformat: {
            number: function (n) {
                if(MathJax.config.subequations==0)
                    return(MathJax.config.section + n);
                else
                    return(MathJax.config.section + String.fromCharCode(96+n));
            },
        },
 }
}
</script>

<script
    id="MathJax-script"
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="index-autopage-23"></a>
<nav class="topnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Notes on Everything</span>
</p>

<p>
Subjects
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="Sums.html#autosec-6" class="tocchapter" >
Sums</a>
</p>


<p>
<a href="Sums.html#autosec-7" class="tocsection" >
Manipulating Sums</a>
</p>


<p>
<a href="Sums.html#autosec-8" class="tocsubsection" >
Basic Rules</a>
</p>


<p>
<a href="Sums.html#autosec-10" class="tocsubsection" >
Iverson Notation</a>
</p>


<p>
<a href="Sums.html#autosec-13" class="tocsubsection" >
Perturbing the Sum</a>
</p>


<p>
<a href="Sums.html#autosec-16" class="tocsubsection" >
Multiple Sums</a>
</p>


<p>
<a href="Algorithms.html#autosec-24" class="tocchapter" >
Algorithms</a>
</p>


<p>
<a href="Algorithms.html#autosec-25" class="tocsection" >
Greedy</a>
</p>


<p>
<a href="Algorithms.html#autosec-26" class="tocsubsection" >
Dijkstra’s Shortest Path Algorithm</a>
</p>


<p>
<a href="Algorithms.html#autosec-34" class="tocsubsection" >
Prim’s MST Algorithm</a>
</p>


<p>
<a href="Algorithms.html#autosec-38" class="tocsubsection" >
Kruskal’s MST Algorithm</a>
</p>


<p>
<a href="Algorithms.html#autosec-45" class="tocsubsection" >
Huffman Codes</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-51" class="tocsection" >
Divide and Conquer</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-52" class="tocsubsection" >
Master Theorem</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-54" class="tocsubsection" >
MergeSort</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-56" class="tocsubsection" >
Counting Array Inversions</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-59" class="tocsubsection" >
Karatsuba Multiplication</a>
</p>


<p>
<a href="Combinatorics.html#autosec-61" class="tocchapter" >
Combinatorics</a>
</p>


<p>
<a href="Combinatorics.html#autosec-62" class="tocsection" >
Basics of Counting</a>
</p>


<p>
<a href="Combinatorics.html#autosec-63" class="tocsubsection" >
Product Rule</a>
</p>


<p>
<a href="Combinatorics.html#autosec-64" class="tocsubsection" >
Complement Rule</a>
</p>


<p>
<a href="Combinatorics.html#autosec-65" class="tocsubsection" >
Sum Rule</a>
</p>


<p>
<a href="Combinatorics.html#autosec-66" class="tocsubsection" >
Inclusion/Exclusion</a>
</p>


<p>
<a href="Combinatorics.html#autosec-67" class="tocsubsection" >
Permutations</a>
</p>


<p>
<a href="Foundations.html#autosec-70" class="tocchapter" >
Foundations</a>
</p>


<p>
<a href="Foundations.html#autosec-71" class="tocsection" >
Quadratics</a>
</p>


<p>
<a href="Foundations.html#autosec-72" class="tocsubsection" >
Finding Roots of a Quadratic Function</a>
</p>


<p>
<a href="Foundations.html#autosec-78" class="tocsubsection" >
Vieta’s Theorem</a>
</p>


<p>
<a href="Foundations.html#autosec-81" class="tocsubsection" >
The Quadratic Formula</a>
</p>


</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<h1>Notes on Everything</h1>

<!--MathJax customizations:-->
<div data-nosnippet
    style="display:none"
>

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

</div>

<!--
...... chapter Algorithms ......
-->
<h3 id="autosec-24">Algorithms</h3>
<a id="index-autopage-24"></a>
<a id="index-autofile-2"></a>
<!--
...... section Greedy ......
-->
<h4 id="autosec-25">Greedy</h4>
<a id="index-autopage-25"></a>


<p>
The greedy algorithm design paradigm produces straightforward and fast solutions to certain problems. Usually, however, greedy algorithms do not produce correct results, and great care must be taken to prove their correctness.
</p>

<p>
In general, the strategy is to choose a locally optimal solution in the hopes that it produces a globally optimal output. Proofs of correctness and optimality usually involve an exchange argument and/or induction.
</p>
<!--
...... subsection Dijkstra's Shortest Path Algorithm ......
-->
<h5 id="autosec-26">Dijkstra’s Shortest Path Algorithm</h5>
<a id="index-autopage-26"></a>


<p>
The canonical greedy algorithm. Dijkstra’s algorithm computes the shortest paths from a starting vertex by choose the least costly edge spanning a graph ”cut” or partition incident to the visited nodes. In other words, greedily choose the edge which minimizes the current
distance traveled.
</p>

<figure id="autoid-1" class="figure ">
<div class="center">

<p>
<span
    id="lateximage-index-2"
    class="lateximagesource"
><!--
        V
    1           6

S           2       T

    4           3
        W
--><img
    src="index-images/image-2.svg"
    alt="(-tikz-&nbsp;diagram)"
    style=""
    class="lateximage"
></span>
</p>

<div class="figurecaption">
<p>
Figure&nbsp;1:&nbsp;Weighted, directed graph
</p>
</div>

<a id="fig:dijkstra1"></a>

</div>

</figure>

<p>
The shortest path algorithm outputs the following when starting from \(S\):
</p>
<table>

<tr style="display:none"><th>.</th></tr>

<tr class="hline">
<td class="tdc tvertbarl tvertbarr" style="border-left: 1px solid black; border-right: 1px solid black">Vertex</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">Shortest Path</td>
</tr>

<tr class="hline">
<td class="tdc tvertbarl tvertbarr" style="border-left: 1px solid black; border-right: 1px solid black">S</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">0</td>
</tr>

<tr class="hline">
<td class="tdc tvertbarl tvertbarr" style="border-left: 1px solid black; border-right: 1px solid black">V</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">1</td>
</tr>

<tr class="hline">
<td class="tdc tvertbarl tvertbarr" style="border-left: 1px solid black; border-right: 1px solid black">W</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">3</td>
</tr>

<tr class="hline">
<td class="tdc tvertbarl tvertbarr" style="border-left: 1px solid black; border-right: 1px solid black">T</td>
<td class="tdc tvertbarr" style="border-right: 1px solid black">6</td>
</tr>

<tr class="hline" aria-hidden="true">
<td class="tdc"></td>
<td class="tdc"></td>
</tr>
</table>

<figure id="autoid-2" class="algorithm ruled">

<div class="figurecaption">
<p>
Algorithm&nbsp;1:&nbsp;Dijkstra’s Shortest-Path
</p>
</div>
<ul class="list" style="list-style-type:none">

<li>
<p>
<span class="listmarker"><b>Require:</b></span> \(G = (V, E)\) has nonnegative edge weights
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span>\(X = \{s\}\)
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span>len(s) = 0, len(v) = \(+\infty \) for every \(v \neq s\)
</p>

</li>
<li>

<p>
<span class="listmarker"></span>
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>while</b> There exists an edge \((v, w) \; v \in X, w \not \in X\) <b>do</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>         <span style="width:12pt; display:inline-block;"></span>\((v&apos;, w&apos;)\) = edge minimizing \(len(v) + l_{vw}\)
</p>

</li>
<li>

<p>
<span class="listmarker"></span>         <span style="width:12pt; display:inline-block;"></span>Add \(w&apos;\) to \(X\)
</p>

</li>
<li>

<p>
<span class="listmarker"></span>         <span style="width:12pt; display:inline-block;"></span>len(w’) = len(v’) + \(l_{v&apos;w&apos;}\)
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <b>return</b> len
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>end</b> <b>while</b>
</p>
</li>
</ul>

</figure>

<p>
The proof of Dijkstra’s shortest-path algorithm differs from that of Prim’s and Kruskal’s in that it proceeds by basic induction rather than presenting a proof by contradiction and exchange argument<sup>1</sup><a id="index-autopage-30"></a>.
</p>

<p>
First, a precise statement of the theorem:
</p>
<div role="note" class="footnotes">

<a id="index-autopage-31"></a>

<p>
<sup>1</sup>&nbsp;Consequently, I find this proof to be slightly more difficult
</p>


</div>



<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker">
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">1</span></span>. </span> <a id="thm:dijkstra"></a> For every directed graph \(G = (V, E)\), for every starting vertex \(s \in V\), Dijkstra’s
shortest-path algorithm outputs the distance of the shortest paths from \(s\) to every (reachable) \(v \in V\).
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="index-autopage-32"></a>

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof of Dijkstra’s Shortest-Path Algorithm.</span></span> <a id="prf:dijkstra"></a> Some initial setup. Let \(k\) be the number of a vertex added to the solution, and \(P(k)\) be the statement that
distance from the starting vertex \(s\) to the \(k\)th vertex, say \(v\), is the shortest such distance.
</p>

<p>
During this proof, we’ll denote the <em>true</em> shortest-path distance with \(dist(s, v), \; v \in V\) and the <em>computed</em> value to be \(len(v)\). Our job is to prove that these values are equal at every iteration.
</p>

<p>
Proceeding by induction, consider the graph consisting of only \(s\). In this case \(n = 1\), and by the definition of the algorithm, \(dist(s, s) = 0\). Now assume the correctness of Dijkstra’s for all \(N \geqslant n\) and consider a graph with \(n + 1\) vertices. By
the inductive hypothesis, all of \(P(1) \dots P(n)\) hold, and so we consider the moment the algorithm must choose to add vertex \(n + 1\) to the solution.
</p>

<p>
Label the edge the algorithm chooses \((v&apos;, w&apos;)\). The distance from \(s\) to \(w&apos;\) is given by:
</p>

<p>
\[ len(w&apos;) = len(v&apos;) + weight((v&apos;, w&apos;)) \]
</p>

<p>
By the inductive hypothesis, we know \(len(v&apos;) = dist(s, v&apos;)\). What remains to be shown is that adding edge \((v&apos;, w&apos;)\) in the above formula is the optimal choice at the \(n+1\)st iteration.
</p>

<p>
TODO: ? <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<!--
...... subsubsection Analysis ......
-->
<h6 id="autosec-33">Analysis</h6>
<a id="index-autopage-33"></a>


<p>
The cost of repeatedly selecting the minimum edge via brute force dominates the runtime of the algorithm. For \(G = (V, E)\), we traverse \(|V|\) nodes, each time performing \(O(|E|)\) work to select the minimum edge crossing the cut. Therefore, the naive version of
Dijkstra’s runs in \(O(|E||V|)\).
</p>

<p>
Using a [[Heap]] this algorithm can be sped up significantly, achieving \(O((|E| + |V|)\log |V|)\) runtime.
</p>
<!--
...... subsection Prim's MST Algorithm ......
-->
<h5 id="autosec-34">Prim’s MST Algorithm</h5>
<a id="index-autopage-34"></a>


<p>
Prim’s algorithm for computing a minimum-spanning tree. The algorithm functions almost identically to Dijkstra’s algorithm in that the minimum incident edge is always chosen for the solution.
</p>

<p>
<span
    id="lateximage-index-3"
    class="lateximagesource"
><!--
        1
    a       b
        3
4               2

    c       d
        5
--><img
    src="index-images/image-3.svg"
    alt="(-tikz-&nbsp;diagram)"
    style=""
    class="lateximage"
></span>
</p>

<figure id="autoid-3" class="algorithm ruled">

<div class="figurecaption">
<p>
Algorithm&nbsp;2:&nbsp;Prim’s MST Algorithm
</p>
</div>
<ul class="list" style="list-style-type:none">

<li>
<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span>\(X = \{s\}\)
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span>\(T = \emptyset \)
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>while</b> There is an edge \((v, w)\) s.t \(v \in X\), \(w \not \in X\) <b>do</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>     <span style="width:12pt; display:inline-block;"></span>\((v&apos;, w&apos;)\) = minimum cost edge
</p>

</li>
<li>

<p>
<span class="listmarker"></span>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>     <span style="width:12pt; display:inline-block;"></span>Add \(w&apos;\) to \(X\)
</p>

</li>
<li>

<p>
<span class="listmarker"></span>     <span style="width:12pt; display:inline-block;"></span>Add \((v&apos;, w&apos;)\) to \(T\)
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>end</b> <b>while</b><b>return</b> \(T\)
</p>
</li>
</ul>

</figure>
<!--
...... subsubsection Analysis ......
-->
<h6 id="autosec-37">Analysis</h6>
<a id="index-autopage-37"></a>


<p>
Once again the cost of repeatedly selecting the minimum edge dominates the runtime of the algorithm leading to \(O(|V||E|)\) worst-case runtime.
</p>

<p>
We can employ the same technique of using a Heap as in Dijkstra’s algorithm to achieve a runtime of \(O(|E|\log |V|)\).
</p>
<!--
...... subsection Kruskal's MST Algorithm ......
-->
<h5 id="autosec-38">Kruskal’s MST Algorithm</h5>
<a id="index-autopage-38"></a>


<p>
Kruskal’s algorithm adopts a different approach, instead opting to choose the minimum edge that would not introduce a cycle.
</p>

<p>
<span
    id="lateximage-index-4"
    class="lateximagesource"
><!--
        1
    a       b
        3
4               2

    c       d
        5
--><img
    src="index-images/image-4.svg"
    alt="(-tikz-&nbsp;diagram)"
    style=""
    class="lateximage"
></span>
</p>

<p>
Kruskal’s algorithm would execute the following steps:
</p>

<ul class="enumerate" style="list-style-type:none">

<li>
<p>
<span class="listmarker">1.</span> Choose \((a, b)\), since it is the minimum cost edge
</p>

</li>
<li>

<p>
<span class="listmarker">2.</span> Choose \((b, d)\), since no cycle is produced
</p>

</li>
<li>

<p>
<span class="listmarker">3.</span> Choose \((d, e)\), since \((a, c)\) would produce a cycle
</p>

</li>
<li>

<p>
<span class="listmarker">4.</span> The chosen edges form a spanning tree of minimum cost!
</p>
</li>
</ul>

<figure id="autoid-4" class="figure ">
<div class="center">

<p>
<span
    id="lateximage-index-5"
    class="lateximagesource"
><!--
        1
    a       b

4               2

    c       d
--><img
    src="index-images/image-5.svg"
    alt="(-tikz-&nbsp;diagram)"
    style=""
    class="lateximage"
></span>
</p>

<div class="figurecaption">
<p>
Figure&nbsp;2:&nbsp;Minimum spanning tree
</p>
</div>

<a id="fig:kruskal-mst"></a>

</div>

</figure>

<p>
In a real program, we sort the edges of the input graph \(G\) by weight as a pre-processing step to avoid quadratic searches for successive minima.
</p>

<figure id="autoid-5" class="algorithm ruled">

<div class="figurecaption">
<p>
Algorithm&nbsp;3:&nbsp;Kruskal’s Algorithm
</p>
</div>
<ul class="list" style="list-style-type:none">

<li>
<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span>\(T = \emptyset \)
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span>sort \(E\) by edge weight
</p>

</li>
<li>

<p>
<span class="listmarker"></span>
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>for</b> \((v, w) \in E\) <b>do</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>        <span style="width:12pt; display:inline-block;"></span><b>if</b> \((v, w)\) does not produce a cycle in \(T\) <b>then</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>           <span style="width:24pt; display:inline-block;"></span>add \((v, w)\) to \(T\)
</p>

</li>
<li>

<p>
<span class="listmarker"></span>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>        <span style="width:12pt; display:inline-block;"></span><b>end</b> <b>if</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>end</b> <b>for</b><b>return</b> \(T\)
</p>
</li>
</ul>

</figure>
<!--
...... subsubsection Analysis ......
-->
<h6 id="autosec-44">Analysis</h6>
<a id="index-autopage-44"></a>


<p>
Sorting the edges takes \(O(n\log n)\) time. Cycle detection in the inner loop dominates the runtime of naive Kruskal’s and therefore the overall runtime is subject to the implementation details. For a brute-force cycle detection approach, the inner loop runs \(O(|E||E +
V|) = O(|E||V|)\) time.
</p>

<p>
By using a Union-Find data structure, we can dramatically improve the runtime. In particular by implementing optimizations such as Path Compression and Union-by-Rank
</p>

<p>
> TODO: Do the detailed analysis later, (Inverse Ackermann)
</p>
<!--
...... subsection Huffman Codes ......
-->
<h5 id="autosec-45">Huffman Codes</h5>
<a id="index-autopage-45"></a>


<p>
Invented by David Huffman in the 50s as a way to compute the optimal prefix-free variable length encoding for a (mathematical) language \(\sum \). The algorithm constructs a tree from the ”bottom up”, repeatedly merging the least frequently occurring codes in order
to ensure the most frequently occurring have minimum possible depth.
</p>

<figure id="autoid-6" class="algorithm ruled">

<div class="figurecaption">
<p>
Algorithm&nbsp;4:&nbsp;Huffman Encoding
</p>
</div>
<ul class="list" style="list-style-type:none">

<li>
<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span>\(H = \emptyset \)
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>for</b> symbol \(\sigma \in \sum \) <b>do</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>       <span style="width:12pt; display:inline-block;"></span>\({T_\sigma } = (\sigma , P_\sigma )\)
</p>

</li>
<li>

<p>
<span class="listmarker"></span>       <span style="width:12pt; display:inline-block;"></span>\(H = H \cup T_\sigma \)
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>end</b> <b>for</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>while</b> There is more than one \(T_\sigma \in H\) <b>do</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>       <span style="width:12pt; display:inline-block;"></span>\(T_1\) = tree with minimum frequency
</p>

</li>
<li>

<p>
<span class="listmarker"></span>       <span style="width:12pt; display:inline-block;"></span>\(T_2\) = tree with 2nd smallest frequency
</p>

</li>
<li>

<p>
<span class="listmarker"></span>       <span style="width:12pt; display:inline-block;"></span>\(T_3\) = <span class="textsc">MergeTrees</span>(\(T_1, T_2\))
</p>

</li>
<li>

<p>
<span class="listmarker"></span>       <span style="width:12pt; display:inline-block;"></span>\(H = H \cup T_3\)
</p>

</li>
<li>

<p>
<span class="listmarker"></span>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>end</b> <b>while</b>
</p>
</li>
</ul>

</figure>

<p>
For example, given the frequencies:
</p>
<table>

<tr style="display:none"><th>.</th></tr>

<tr class="hline">
<td class="tdc tvertbarl tvertbarr" style="border-left: 1px solid black; border-right: 1px solid black">Symbol</td>
<td class="tdr tvertbarr" style="border-right: 1px solid black">Frequency</td>
</tr>

<tr class="hline">
<td class="tdc tvertbarl tvertbarr" style="border-left: 1px solid black; border-right: 1px solid black">a</td>
<td class="tdr tvertbarr" style="border-right: 1px solid black">0.60</td>
</tr>

<tr class="hline">
<td class="tdc tvertbarl tvertbarr" style="border-left: 1px solid black; border-right: 1px solid black">b</td>
<td class="tdr tvertbarr" style="border-right: 1px solid black">0.25</td>
</tr>

<tr class="hline">
<td class="tdc tvertbarl tvertbarr" style="border-left: 1px solid black; border-right: 1px solid black">c</td>
<td class="tdr tvertbarr" style="border-right: 1px solid black">0.10</td>
</tr>

<tr class="hline">
<td class="tdc tvertbarl tvertbarr" style="border-left: 1px solid black; border-right: 1px solid black">d</td>
<td class="tdr tvertbarr" style="border-right: 1px solid black">0.05</td>
</tr>

<tr class="hline" aria-hidden="true">
<td class="tdc"></td>
<td class="tdr"></td>
</tr>
</table>

<p>
Huffman’s greedy algorithm will produce the following encoding tree
</p>

<p>
<span
    id="lateximage-index-6"
    class="lateximagesource"
><!--
    0           1

a
            0               1

        b
                        0       1

                    c               d
--><img
    src="index-images/image-6.svg"
    alt="(-tikz-&nbsp;diagram)"
    style=""
    class="lateximage"
></span>
</p>

<p>
which ensures that symbol \(a\), the most frequently encountered will be the quickest to encode and decode since its depth in minimized in the output.
</p>
<!--
...... subsubsection Analysis ......
-->
<h6 id="autosec-49">Analysis</h6>
<a id="index-autopage-49"></a>


<p>
Preprocessing the nodes can be done quickly in \(O(n)\) time. The inner loop of the algorithm is bound by the time it takes to select a minimum, therefore, repeated brute-force searching for minima each iteration leads to \(O(n^2)\) runtime.
</p>

<p>
Once again, however, a [[Heap]] can be used to retrieve the minimum trees in constant time with \(O(\log n)\) re-balance operations. This results in a much better runtime of \(O(n \log n)\).
</p>

</section>

</main>

</div>

<footer>

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

</footer>


<nav class="botnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|Divide-Conquer.html|-->

<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Anthony" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="Personal notes on Mathematics and Computer Science" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Notes on Everything — Divide and Conquer</title>
<link rel="stylesheet" type="text/css" href="lwarp.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
  subequations: "0",
  section: "",
  loader: {
    load: ['[tex]/tagformat', '[tex]/textmacros'],
  },
  startup: {
    ready() {
      // These would be replaced by import commands if you wanted to make
      // a proper extension.
      const Configuration = MathJax._.input.tex.Configuration.Configuration;
      const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
      const Macro = MathJax._.input.tex.Symbol.Macro;
      const TexError = MathJax._.input.tex.TexError.default;
      const ParseUtil = MathJax._.input.tex.ParseUtil.default;
      const expandable = MathJax._.util.Options.expandable;

       // Insert the replacement string into the TeX string, and check
       // that there haven't been too many maxro substitutions (prevents
       // infinite loops).
       const useArgument = (parser, text) => {
         parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
         parser.i = 0;
         if (++parser.macroCount > parser.configuration.options.maxMacros) {
           throw new TexError('MaxMacroSub1',
           'MathJax maximum macro substitution count exceeded; ' +
           'is there a recursive macro call?');
         }
       }

       // Create the command map for:
       //     \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
       new CommandMap('Lwarp-macros', {
         ifstar: 'IfstarFunction',
         ifnextchar: 'IfnextcharFunction',
         ifblank: 'IfblankFunction',
         ifstrequal: 'IfstrequalFunction',
         gsubstitute: 'GsubstituteFunction',
         seteqnumber: 'SeteqnumberFunction'
       }, {
         // This function implements an ifstar macro.
         IfstarFunction(parser, name) {
            const resultstar = parser.GetArgument(name);
            const resultnostar = parser.GetArgument(name);
            const star = parser.GetStar();                 // true if there is a *
            useArgument(parser, star ? resultstar : resultnostar);
         },

          // This function implements an ifnextchar macro.
          IfnextcharFunction(parser, name) {
            let whichchar = parser.GetArgument(name);
            if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
              // $ syntax highlighting
              whichchar = String.fromCodePoint(parseInt(whichchar));
            }
            const resultnextchar = parser.GetArgument(name);
            const resultnotnextchar = parser.GetArgument(name);
            const gotchar = (parser.GetNext() === whichchar);
            useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
          },

          // This function implements an ifblank macro.
          IfblankFunction(parser, name) {
            const blankarg = parser.GetArgument(name);
            const resultblank = parser.GetArgument(name);
            const resultnotblank = parser.GetArgument(name);
            const isblank = (blankarg.trim() == "");
            useArgument(parser, isblank ? resultblank : resultnotblank);
          },

          // This function implements an ifstrequal macro.
          IfstrequalFunction(parser, name) {
            const strequalfirst = parser.GetArgument(name);
            const strequalsecond = parser.GetArgument(name);
            const resultequal = parser.GetArgument(name);
            const resultnotequal = parser.GetArgument(name);
            const isequal = (strequalfirst == strequalsecond);
            useArgument(parser, isequal ? resultequal : resultnotequal);
          },

          // This function implements a gsub macro.
          GsubstituteFunction(parser, name) {
            const gsubfirst = parser.GetArgument(name);
            const gsubsecond = parser.GetArgument(name);
            const gsubthird = parser.GetArgument(name);
            let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
            useArgument(parser, gsubresult);
          },

          // This function modifies the equation numbers.
          SeteqnumberFunction(parser, name) {
              // Get the macro parameters
              const star = parser.GetStar();                  // true if there is a *
              const optBrackets = parser.GetBrackets(name);   // contents of optional brackets
              const newsubequations = parser.GetArgument(name); // the subequations argument
              const neweqsection = parser.GetArgument(name); // the eq section argument
              const neweqnumber = parser.GetArgument(name);   // the eq number argument
              MathJax.config.subequations=newsubequations ;   // a string with boolean meaning
              MathJax.config.section=neweqsection ;           // a string with numeric meaning
              parser.tags.counter = parser.tags.allCounter = neweqnumber ;
          }

       });

       // Create the Lwarp-macros package
       Configuration.create('Lwarp-macros', {
         handler: {macro: ['Lwarp-macros']}
       });

       MathJax.startup.defaultReady();

       // For forward references:
       MathJax.startup.input[0].preFilters.add(({math}) => {
         if (math.inputData.recompile){
             MathJax.config.subequations = math.inputData.recompile.subequations;
             MathJax.config.section = math.inputData.recompile.section;
         }
       });
       MathJax.startup.input[0].postFilters.add(({math}) => {
         if (math.inputData.recompile){
             math.inputData.recompile.subequations = MathJax.config.subequations;
             math.inputData.recompile.section = MathJax.config.section;
         }
       });

         // For \left, \right with unicode-math:
         const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
         const {Symbol} = MathJax._.input.tex.Symbol;
         const {MapHandler} = MathJax._.input.tex.MapHandler;
         const delimiter = MapHandler.getMap('delimiter');
         delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
         delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
         delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
         delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
         delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
         delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
         delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
         delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
         delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
         delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
         delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
         delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
         delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
         delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
         delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
         delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
         delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
         delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
         delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
         delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
         delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
         delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
         delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
         delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
         delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
         delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
         delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
         delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
         delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
         delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
         delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
         delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
         delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
         delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
         delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
         delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
         delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
         delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
         delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
   }     // ready
 },      // startup

 tex: {
   packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
   tags: "ams",
        tagformat: {
            number: function (n) {
                if(MathJax.config.subequations==0)
                    return(MathJax.config.section + n);
                else
                    return(MathJax.config.section + String.fromCharCode(96+n));
            },
        },
 }
}
</script>

<script
    id="MathJax-script"
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="index-autopage-50"></a>
<nav class="topnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Notes on Everything</span>
</p>

<p>
Subjects
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="Sums.html#autosec-6" class="tocchapter" >
Sums</a>
</p>


<p>
<a href="Sums.html#autosec-7" class="tocsection" >
Manipulating Sums</a>
</p>


<p>
<a href="Sums.html#autosec-8" class="tocsubsection" >
Basic Rules</a>
</p>


<p>
<a href="Sums.html#autosec-10" class="tocsubsection" >
Iverson Notation</a>
</p>


<p>
<a href="Sums.html#autosec-13" class="tocsubsection" >
Perturbing the Sum</a>
</p>


<p>
<a href="Sums.html#autosec-16" class="tocsubsection" >
Multiple Sums</a>
</p>


<p>
<a href="Algorithms.html#autosec-24" class="tocchapter" >
Algorithms</a>
</p>


<p>
<a href="Algorithms.html#autosec-25" class="tocsection" >
Greedy</a>
</p>


<p>
<a href="Algorithms.html#autosec-26" class="tocsubsection" >
Dijkstra’s Shortest Path Algorithm</a>
</p>


<p>
<a href="Algorithms.html#autosec-34" class="tocsubsection" >
Prim’s MST Algorithm</a>
</p>


<p>
<a href="Algorithms.html#autosec-38" class="tocsubsection" >
Kruskal’s MST Algorithm</a>
</p>


<p>
<a href="Algorithms.html#autosec-45" class="tocsubsection" >
Huffman Codes</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-51" class="tocsection" >
Divide and Conquer</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-52" class="tocsubsection" >
Master Theorem</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-54" class="tocsubsection" >
MergeSort</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-56" class="tocsubsection" >
Counting Array Inversions</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-59" class="tocsubsection" >
Karatsuba Multiplication</a>
</p>


<p>
<a href="Combinatorics.html#autosec-61" class="tocchapter" >
Combinatorics</a>
</p>


<p>
<a href="Combinatorics.html#autosec-62" class="tocsection" >
Basics of Counting</a>
</p>


<p>
<a href="Combinatorics.html#autosec-63" class="tocsubsection" >
Product Rule</a>
</p>


<p>
<a href="Combinatorics.html#autosec-64" class="tocsubsection" >
Complement Rule</a>
</p>


<p>
<a href="Combinatorics.html#autosec-65" class="tocsubsection" >
Sum Rule</a>
</p>


<p>
<a href="Combinatorics.html#autosec-66" class="tocsubsection" >
Inclusion/Exclusion</a>
</p>


<p>
<a href="Combinatorics.html#autosec-67" class="tocsubsection" >
Permutations</a>
</p>


<p>
<a href="Foundations.html#autosec-70" class="tocchapter" >
Foundations</a>
</p>


<p>
<a href="Foundations.html#autosec-71" class="tocsection" >
Quadratics</a>
</p>


<p>
<a href="Foundations.html#autosec-72" class="tocsubsection" >
Finding Roots of a Quadratic Function</a>
</p>


<p>
<a href="Foundations.html#autosec-78" class="tocsubsection" >
Vieta’s Theorem</a>
</p>


<p>
<a href="Foundations.html#autosec-81" class="tocsubsection" >
The Quadratic Formula</a>
</p>


</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<h1>Notes on Everything</h1>

<!--MathJax customizations:-->
<div data-nosnippet
    style="display:none"
>

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

</div>

<!--
...... section Divide and Conquer ......
-->
<h4 id="autosec-51">Divide and Conquer</h4>
<a id="index-autopage-51"></a>
<a id="index-autofile-3"></a>

<p>
Divide and conquer algorithms are characterized by a procedure which breaks a problem into distinct subproblems (divide) and produces the solution to the overall problem by combining the results of the subproblems (conquer).
</p>

<p>
This paradigm differs from Dynamic Programming in that the subproblems produced by the divide step are usually independent.
</p>
<!--
...... subsection Master Theorem ......
-->
<h5 id="autosec-52">Master Theorem</h5>
<a id="index-autopage-52"></a>


<p>
The master theorem is a concise summary of the runtime of certain specific recurrences which come about naturally in divide-and-conquer algorithms. This is mainly a shortcut to avoid the verbose computation of determining the value of a geometric series.
</p>

<p>
Let \(T(n)\) be a recurrence with upper bound defined as follows:
</p>

<p>
\[ T(n) \leqslant a \cdot T(\frac n b) + O(n^d) \]
</p>

<p>
Then we have,
</p>

<p>
\[ T(n) = \begin {cases} O(n^d \log n) &amp; \text {if $a = b^d$} \\ O(n^d) &amp; \text {if $a &lt; b^d$} \\ O(n^{\log _b a}) &amp; \text {if $a &gt; b^d$} \\ \end {cases} \]
</p>

<p>
Where
</p>
<ul class="itemize" style="list-style-type:none">

<li>
<p>
<span class="listmarker">•</span> \(a\) Is the number of recursive calls,
</p>

</li>
<li>

<p>
<span class="listmarker">•</span> \(b\) Is the decrease in the size of a subproblem in a recursive call, and
</p>

</li>
<li>

<p>
<span class="listmarker">•</span> \(d\) Is the order of the work performed for each subproblem
</p>
</li>
</ul>

<p>
The runtimes follow naturally from reasoning about the upper bound in each case.
</p>
<!--
...... subsubsection Proof ......
-->
<h6 id="autosec-53">Proof</h6>
<a id="index-autopage-53"></a>


<p>
TODO
</p>
<!--
...... subsection MergeSort ......
-->
<h5 id="autosec-54">MergeSort</h5>
<a id="index-autopage-54"></a>


<p>
Probably the most famous divide and conquer algorithm. The core idea behind MergeSort is to repeatedly bisect an array until reaching a trivial sorting problem of one element and then recursively merge each subarray, placing the element in ascending order in the final
output.
</p>

<figure id="autoid-7" class="algorithm ruled">

<div class="figurecaption">
<p>
Algorithm&nbsp;5:&nbsp;MergeSort
</p>
</div>
<ul class="list" style="list-style-type:none">

<li>
<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>procedure</b> <span class="textsc">Merge</span>(\(A, B\))
</p>

</li>
<li>

<p>
<span class="listmarker"></span>        <span style="width:12pt; display:inline-block;"></span>\(i = 0, j = 0\)
</p>

</li>
<li>

<p>
<span class="listmarker"></span>        <span style="width:12pt; display:inline-block;"></span>\(C = []\)
</p>

</li>
<li>

<p>
<span class="listmarker"></span>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>        <span style="width:12pt; display:inline-block;"></span><b>for</b> \(k = 0\) To \(n-1\) <b>do</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>           <span style="width:24pt; display:inline-block;"></span><b>if</b> \(A[i] &lt; B[j]\) <b>then</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>              <span style="width:36pt; display:inline-block;"></span>\(C[k] = A[i]\)
</p>

</li>
<li>

<p>
<span class="listmarker"></span>              <span style="width:36pt; display:inline-block;"></span>\(i = i + 1\)
</p>

</li>
<li>

<p>
<span class="listmarker"></span>           <span style="width:24pt; display:inline-block;"></span><b>else</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>              <span style="width:36pt; display:inline-block;"></span>\(C[k] = B[j]\)
</p>

</li>
<li>

<p>
<span class="listmarker"></span>              <span style="width:36pt; display:inline-block;"></span>\(j = j + 1\)
</p>

</li>
<li>

<p>
<span class="listmarker"></span>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>           <span style="width:24pt; display:inline-block;"></span><b>end</b> <b>if</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>        <span style="width:12pt; display:inline-block;"></span><b>end</b> <b>for</b><b>return</b> \(C\)
</p>

</li>
<li>

<p>
<span class="listmarker"></span>
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>end</b> <b>procedure</b>
</p>
</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>procedure</b> <span class="textsc">MergeSort</span>(\(A\))
</p>

</li>
<li>

<p>
<span class="listmarker"></span>        <span style="width:12pt; display:inline-block;"></span><b>if</b> \(len(A) \leqslant 1\) <b>then</b> <b>return</b> \(A\)
</p>

</li>
<li>

<p>
<span class="listmarker"></span>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>        <span style="width:12pt; display:inline-block;"></span><b>end</b> <b>if</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>        <span style="width:12pt; display:inline-block;"></span>\(L =\) <span class="textsc">MergeSort</span>(left half of \(A\))
</p>

</li>
<li>

<p>
<span class="listmarker"></span>        <span style="width:12pt; display:inline-block;"></span>\(R =\) <span class="textsc">MergeSort</span>(right half of \(A\))
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <b>return</b> <span class="textsc">Merge</span>(\(L, R\))
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>end</b> <b>procedure</b>
</p>
</li>
</ul>

</figure>
<!--
...... subsubsection Analysis ......
-->
<h6 id="autosec-55">Analysis</h6>
<a id="index-autopage-55"></a>


<p>
From the pseudocode, we see there are 2 recursive calls per iteration, each dividing the input in half. Additionally, the ‘Merge‘ routine performs linear work per call, leading to the following recurrence:
</p>

<p>
\[ T(n) \leqslant 2 \cdot T(\frac n 2) + O(n) \]
</p>

<p>
Applying the master theorem with \(a = 2 = 2^1 = b^d\), we arrive at a runtime of \(O(n\log n)\).
</p>
<!--
...... subsection Counting Array Inversions ......
-->
<h5 id="autosec-56">Counting Array Inversions</h5>
<a id="index-autopage-56"></a>


<p>
Array inversions are the number of ”out of place” element with respect to the sorted list. For example,
</p>
<pre class="verbatim">
  A = [3, 1, 2]

</pre>

<p>
has 2 inversions. The trivial brute-force solution involves comparing every element against the rest of the \(n-1\) items, leading to a quadratic runtime.
</p>

<p>
The divide-and-conquer approach employs the generally useful idea of counting the inversions in the left and right subhalves as well as those than span the middle of the array. The following strategy sorts each subarray, counting the split inversions during the combine step.
</p>

<figure id="autoid-8" class="algorithm ruled">

<div class="figurecaption">
<p>
Algorithm&nbsp;6:&nbsp;Count Inversions
</p>
</div>
<ul class="list" style="list-style-type:none">

<li>
<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>procedure</b> <span class="textsc">CountSplitInv</span>(\(A, B\))
</p>

</li>
<li>

<p>
<span class="listmarker"></span>        <span style="width:12pt; display:inline-block;"></span>i = j = 0
</p>

</li>
<li>

<p>
<span class="listmarker"></span>        <span style="width:12pt; display:inline-block;"></span>inv = 0
</p>

</li>
<li>

<p>
<span class="listmarker"></span>        <span style="width:12pt; display:inline-block;"></span>Out = []
</p>

</li>
<li>

<p>
<span class="listmarker"></span>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>        <span style="width:12pt; display:inline-block;"></span><b>for</b> \(k\) To \(n-1\) <b>do</b> <span class="floatright">&#x25B7; No Inversion</span>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>            <span style="width:24pt; display:inline-block;"></span><b>if</b> A[i] < B[j] <b>then</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>               <span style="width:36pt; display:inline-block;"></span>Out[k] = B[j]
</p>

</li>
<li>

<p>
<span class="listmarker"></span>               <span style="width:36pt; display:inline-block;"></span>i = i + 1
</p>

</li>
<li>

<p>
<span class="listmarker"></span>            <span style="width:24pt; display:inline-block;"></span><b>else</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>               <span style="width:36pt; display:inline-block;"></span>Out[k] = A[j]
</p>

</li>
<li>

<p>
<span class="listmarker"></span>               <span style="width:36pt; display:inline-block;"></span>j = j + 1
</p>

</li>
<li>

<p>
<span class="listmarker"></span>               <span style="width:36pt; display:inline-block;"></span>inv = inv + (n - i)
</p>

</li>
<li>

<p>
<span class="listmarker"></span>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>            <span style="width:24pt; display:inline-block;"></span><b>end</b> <b>if</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>        <span style="width:12pt; display:inline-block;"></span><b>end</b> <b>for</b><b>return</b> (Out, inv)
</p>

</li>
<li>

<p>
<span class="listmarker"></span>
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>end</b> <b>procedure</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>procedure</b> <span class="textsc">CountInv</span>(\(A\))
</p>

</li>
<li>

<p>
<span class="listmarker"></span>        <span style="width:12pt; display:inline-block;"></span><b>if</b> \(n \leqslant 1\) <b>then</b> <b>return</b> (A, 0)
</p>

</li>
<li>

<p>
<span class="listmarker"></span>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>        <span style="width:12pt; display:inline-block;"></span><b>end</b> <b>if</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>        <span style="width:12pt; display:inline-block;"></span>(L, leftInv) = <span class="textsc">CountInv</span>(left half of \(A\))
</p>

</li>
<li>

<p>
<span class="listmarker"></span>        <span style="width:12pt; display:inline-block;"></span>(R, rightInv) = <span class="textsc">CountInv</span>(right half of \(A\))
</p>

</li>
<li>

<p>
<span class="listmarker"></span>        <span style="width:12pt; display:inline-block;"></span>(Merged, splitInv) = <span class="textsc">CountSplitInv</span>(L, R)
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <b>return</b> (Merged, leftInv + rightInv + splitInv)
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>end</b> <b>procedure</b>
</p>
</li>
</ul>

</figure>
<!--
...... subsubsection Analysis ......
-->
<h6 id="autosec-58">Analysis</h6>
<a id="index-autopage-58"></a>


<p>
Similar to <b>MergeSort</b>, we see two recursive calls and linear work per recursive iteration:
</p>

<p>
\[ T(n) \leqslant 2 \cdot T(\frac n 2) + O(n) \]
</p>

<p>
And therefore <b>CountInv</b> has a runtime of \(O(n \log n)\) as well.
</p>
<!--
...... subsection Karatsuba Multiplication ......
-->
<h5 id="autosec-59">Karatsuba Multiplication</h5>
<a id="index-autopage-59"></a>


<p>
Anatoly Karatsuba invented this algorithm as a faster way to multiply very large integers. This happens to be the multiplication algorithm used by Python. The idea behind the algorithm is to recursively split apart each integer into halves until they are small enough to
be multiplied in constant time with the normal ‘*‘ operator.
</p>

<p>
The combine step involves some manipulation of the quadratic identity.
</p>

<figure id="autoid-9" class="algorithm ruled">

<div class="figurecaption">
<p>
Algorithm&nbsp;7:&nbsp;Karatsuba
</p>
</div>
<ul class="list" style="list-style-type:none">

<li>
<p>
<span class="listmarker"><b>Require:</b></span> \(x\) and \(y\) have the same number of digits
</p>
</li>
</ul>

</figure>

</section>

</main>

</div>

<footer>

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

</footer>


<nav class="botnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|Combinatorics.html|-->

<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Anthony" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="Personal notes on Mathematics and Computer Science" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Notes on Everything — Combinatorics</title>
<link rel="stylesheet" type="text/css" href="lwarp.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
  subequations: "0",
  section: "",
  loader: {
    load: ['[tex]/tagformat', '[tex]/textmacros'],
  },
  startup: {
    ready() {
      // These would be replaced by import commands if you wanted to make
      // a proper extension.
      const Configuration = MathJax._.input.tex.Configuration.Configuration;
      const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
      const Macro = MathJax._.input.tex.Symbol.Macro;
      const TexError = MathJax._.input.tex.TexError.default;
      const ParseUtil = MathJax._.input.tex.ParseUtil.default;
      const expandable = MathJax._.util.Options.expandable;

       // Insert the replacement string into the TeX string, and check
       // that there haven't been too many maxro substitutions (prevents
       // infinite loops).
       const useArgument = (parser, text) => {
         parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
         parser.i = 0;
         if (++parser.macroCount > parser.configuration.options.maxMacros) {
           throw new TexError('MaxMacroSub1',
           'MathJax maximum macro substitution count exceeded; ' +
           'is there a recursive macro call?');
         }
       }

       // Create the command map for:
       //     \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
       new CommandMap('Lwarp-macros', {
         ifstar: 'IfstarFunction',
         ifnextchar: 'IfnextcharFunction',
         ifblank: 'IfblankFunction',
         ifstrequal: 'IfstrequalFunction',
         gsubstitute: 'GsubstituteFunction',
         seteqnumber: 'SeteqnumberFunction'
       }, {
         // This function implements an ifstar macro.
         IfstarFunction(parser, name) {
            const resultstar = parser.GetArgument(name);
            const resultnostar = parser.GetArgument(name);
            const star = parser.GetStar();                 // true if there is a *
            useArgument(parser, star ? resultstar : resultnostar);
         },

          // This function implements an ifnextchar macro.
          IfnextcharFunction(parser, name) {
            let whichchar = parser.GetArgument(name);
            if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
              // $ syntax highlighting
              whichchar = String.fromCodePoint(parseInt(whichchar));
            }
            const resultnextchar = parser.GetArgument(name);
            const resultnotnextchar = parser.GetArgument(name);
            const gotchar = (parser.GetNext() === whichchar);
            useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
          },

          // This function implements an ifblank macro.
          IfblankFunction(parser, name) {
            const blankarg = parser.GetArgument(name);
            const resultblank = parser.GetArgument(name);
            const resultnotblank = parser.GetArgument(name);
            const isblank = (blankarg.trim() == "");
            useArgument(parser, isblank ? resultblank : resultnotblank);
          },

          // This function implements an ifstrequal macro.
          IfstrequalFunction(parser, name) {
            const strequalfirst = parser.GetArgument(name);
            const strequalsecond = parser.GetArgument(name);
            const resultequal = parser.GetArgument(name);
            const resultnotequal = parser.GetArgument(name);
            const isequal = (strequalfirst == strequalsecond);
            useArgument(parser, isequal ? resultequal : resultnotequal);
          },

          // This function implements a gsub macro.
          GsubstituteFunction(parser, name) {
            const gsubfirst = parser.GetArgument(name);
            const gsubsecond = parser.GetArgument(name);
            const gsubthird = parser.GetArgument(name);
            let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
            useArgument(parser, gsubresult);
          },

          // This function modifies the equation numbers.
          SeteqnumberFunction(parser, name) {
              // Get the macro parameters
              const star = parser.GetStar();                  // true if there is a *
              const optBrackets = parser.GetBrackets(name);   // contents of optional brackets
              const newsubequations = parser.GetArgument(name); // the subequations argument
              const neweqsection = parser.GetArgument(name); // the eq section argument
              const neweqnumber = parser.GetArgument(name);   // the eq number argument
              MathJax.config.subequations=newsubequations ;   // a string with boolean meaning
              MathJax.config.section=neweqsection ;           // a string with numeric meaning
              parser.tags.counter = parser.tags.allCounter = neweqnumber ;
          }

       });

       // Create the Lwarp-macros package
       Configuration.create('Lwarp-macros', {
         handler: {macro: ['Lwarp-macros']}
       });

       MathJax.startup.defaultReady();

       // For forward references:
       MathJax.startup.input[0].preFilters.add(({math}) => {
         if (math.inputData.recompile){
             MathJax.config.subequations = math.inputData.recompile.subequations;
             MathJax.config.section = math.inputData.recompile.section;
         }
       });
       MathJax.startup.input[0].postFilters.add(({math}) => {
         if (math.inputData.recompile){
             math.inputData.recompile.subequations = MathJax.config.subequations;
             math.inputData.recompile.section = MathJax.config.section;
         }
       });

         // For \left, \right with unicode-math:
         const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
         const {Symbol} = MathJax._.input.tex.Symbol;
         const {MapHandler} = MathJax._.input.tex.MapHandler;
         const delimiter = MapHandler.getMap('delimiter');
         delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
         delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
         delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
         delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
         delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
         delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
         delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
         delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
         delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
         delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
         delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
         delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
         delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
         delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
         delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
         delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
         delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
         delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
         delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
         delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
         delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
         delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
         delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
         delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
         delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
         delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
         delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
         delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
         delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
         delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
         delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
         delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
         delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
         delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
         delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
         delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
         delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
         delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
         delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
   }     // ready
 },      // startup

 tex: {
   packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
   tags: "ams",
        tagformat: {
            number: function (n) {
                if(MathJax.config.subequations==0)
                    return(MathJax.config.section + n);
                else
                    return(MathJax.config.section + String.fromCharCode(96+n));
            },
        },
 }
}
</script>

<script
    id="MathJax-script"
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="index-autopage-60"></a>
<nav class="topnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Notes on Everything</span>
</p>

<p>
Subjects
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="Sums.html#autosec-6" class="tocchapter" >
Sums</a>
</p>


<p>
<a href="Sums.html#autosec-7" class="tocsection" >
Manipulating Sums</a>
</p>


<p>
<a href="Sums.html#autosec-8" class="tocsubsection" >
Basic Rules</a>
</p>


<p>
<a href="Sums.html#autosec-10" class="tocsubsection" >
Iverson Notation</a>
</p>


<p>
<a href="Sums.html#autosec-13" class="tocsubsection" >
Perturbing the Sum</a>
</p>


<p>
<a href="Sums.html#autosec-16" class="tocsubsection" >
Multiple Sums</a>
</p>


<p>
<a href="Algorithms.html#autosec-24" class="tocchapter" >
Algorithms</a>
</p>


<p>
<a href="Algorithms.html#autosec-25" class="tocsection" >
Greedy</a>
</p>


<p>
<a href="Algorithms.html#autosec-26" class="tocsubsection" >
Dijkstra’s Shortest Path Algorithm</a>
</p>


<p>
<a href="Algorithms.html#autosec-34" class="tocsubsection" >
Prim’s MST Algorithm</a>
</p>


<p>
<a href="Algorithms.html#autosec-38" class="tocsubsection" >
Kruskal’s MST Algorithm</a>
</p>


<p>
<a href="Algorithms.html#autosec-45" class="tocsubsection" >
Huffman Codes</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-51" class="tocsection" >
Divide and Conquer</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-52" class="tocsubsection" >
Master Theorem</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-54" class="tocsubsection" >
MergeSort</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-56" class="tocsubsection" >
Counting Array Inversions</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-59" class="tocsubsection" >
Karatsuba Multiplication</a>
</p>


<p>
<a href="Combinatorics.html#autosec-61" class="tocchapter" >
Combinatorics</a>
</p>


<p>
<a href="Combinatorics.html#autosec-62" class="tocsection" >
Basics of Counting</a>
</p>


<p>
<a href="Combinatorics.html#autosec-63" class="tocsubsection" >
Product Rule</a>
</p>


<p>
<a href="Combinatorics.html#autosec-64" class="tocsubsection" >
Complement Rule</a>
</p>


<p>
<a href="Combinatorics.html#autosec-65" class="tocsubsection" >
Sum Rule</a>
</p>


<p>
<a href="Combinatorics.html#autosec-66" class="tocsubsection" >
Inclusion/Exclusion</a>
</p>


<p>
<a href="Combinatorics.html#autosec-67" class="tocsubsection" >
Permutations</a>
</p>


<p>
<a href="Foundations.html#autosec-70" class="tocchapter" >
Foundations</a>
</p>


<p>
<a href="Foundations.html#autosec-71" class="tocsection" >
Quadratics</a>
</p>


<p>
<a href="Foundations.html#autosec-72" class="tocsubsection" >
Finding Roots of a Quadratic Function</a>
</p>


<p>
<a href="Foundations.html#autosec-78" class="tocsubsection" >
Vieta’s Theorem</a>
</p>


<p>
<a href="Foundations.html#autosec-81" class="tocsubsection" >
The Quadratic Formula</a>
</p>


</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<h1>Notes on Everything</h1>

<!--MathJax customizations:-->
<div data-nosnippet
    style="display:none"
>

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

</div>

<!--
...... chapter Combinatorics ......
-->
<h3 id="autosec-61">Combinatorics</h3>
<a id="index-autopage-61"></a>
<a id="index-autofile-4"></a>
<!--
...... section Basics of Counting ......
-->
<h4 id="autosec-62">Basics of Counting</h4>
<a id="index-autopage-62"></a>


<p>
These are the basic ”rules” of counting. In general, counting using these rules involves modeling the problem as a correct sequence of choices and applying the appropriate strategy to the sequence.
</p>
<!--
...... subsection Product Rule ......
-->
<h5 id="autosec-63">Product Rule</h5>
<a id="index-autopage-63"></a>


<p>
The Product rule is applied to combinatorial problems that can be modeled as a ”process” of making mutually exclusive choices. For such problems the total number of ways to perform the process is given by multiplying the number of options at each step.
</p>

<span class="hidden"> \(\seteqnumber{0}{}{0}\)</span>

<!--


                                                                                                                   number of ways = N1 · N2 · · · · · Nk                                                                                                       (1)

-->

<p>

\begin{equation}
\text {number of ways} = N_1 \cdot N_2 \cdot \dots \cdot N_k
\end{equation}

</p>

<p>
where \(N_i\) is the number of ways of performing the \(i\)th step of the process.
</p>
<!--
...... subsection Complement Rule ......
-->
<h5 id="autosec-64">Complement Rule</h5>
<a id="index-autopage-64"></a>


<p>
The Complement rule is helpful when expressing the size of a subset. Suppose \(A \subseteq U\), then
</p>

<p>
\[ |A| = |U| - |U - A| \]
</p>

<p>
In other words, the size of \(A\) is the same as the size of \(U\) when taking away the elements of \(U\) which are also in \(A\) (leaving behind only those elements which belong to \(A\)).
</p>

<p>
(I remember this ”algebraically”: \(U - (U - A) = U - U + A = A\))
</p>
<!--
...... subsection Sum Rule ......
-->
<h5 id="autosec-65">Sum Rule</h5>
<a id="index-autopage-65"></a>


<p>
This is a specicial form of the Inclusion/Exclusion rule applicable for sets of elements who are mutually disjoint.
</p>
<!--
...... subsection Inclusion/Exclusion ......
-->
<h5 id="autosec-66">Inclusion/Exclusion</h5>
<a id="index-autopage-66"></a>


<p>
The Inclusion/Exclusion rule is a generalization of the Sum rule, and can be used when sets are not-disjoint. The intuition here is to subtract the ”double- counted” elements from the union of two sets.
</p>

<p>
\[ |A \cup B| = |A| + |B| - |A \cap B| \]
</p>

<p>
For example, let \(A = \{1, 2, 3\}, \; B = \{2, 3\}\). Since \(A\) and \(B\) are not disjoint, we only want to count the elements in their union once:
</p>

<span class="hidden"> \(\seteqnumber{0}{}{1}\)</span>


<!--


                                                                                                                         A = {1, 2, 3}
                                                                                                                         B = {2, 3}
                                                                                                                         A ∪ B = {1, 2, 3, 2, 3}
                                                                                                                         A ∩ B = {2, 3}
                                                                                                                         (A ∪ B) − (A ∩ B) = {1, 2, 3}


-->


<p>

\begin{align*}
&amp;A = \{1, 2, 3\} \\ &amp;B = \{2, 3\} \\ &amp;A \cup B = \{1, 2, 3, 2, 3\} \\ &amp;A \cap B = \{2, 3\} \\ &amp;(A \cup B) - (A \cap B) = \{1, 2, 3\}
\end{align*}

</p>

<p>
When \(A\) and \(B\) are disjoint, their intersection is \(0\), and so the formula holds.
</p>
<!--
...... subsection Permutations ......
-->
<h5 id="autosec-67">Permutations</h5>
<a id="index-autopage-67"></a>


<p>
We can think of a permutation of a sequence \(n\) as a particular ordering of its elements. We consider each ordering to be a unique object. Another way to think of a permutation is a function that sends an item located at index \(i\) to index \(j\) in the output.
</p>

<p>
for example, consider the string \(S = \text {abc}\). Then the permutations of \(S\) are:
</p>

<p>
\[ \{ abc, acb, bac, bca, cab, cba \} \]
</p>

<p>
The process of arranging the elements of \(S\) is called <b>permuting</b>.
</p>

<p>
The number of permutations a given string has can be modeled as a sequence of choices for the positions of each of its characters. For a string of length \(n\) there are initially \(n\) choices. After the first character is chosen, there are \(n-1\) choices, and so on. Using the
Product Rule:
</p>

<p>
\[ n(n-1)(n-2) \dots 1 = n! \]
</p>
<!--
...... subsubsection K-Permutations ......
-->
<h6 id="autosec-68">K-Permutations</h6>
<a id="index-autopage-68"></a>


<p>
A \(K\)-Permutation follows the same basic idea of a permutation. The goal here is to count the number of subsets of size \(K\) a given set.
</p>

<p>
(Permutations can be thought of as \(k\)-permutations where \(k=n\))
</p>

<p>
Let \(S = \text {abc}, \; k = 2\). Then the \(2\)-permutations of \(S\) are:
</p>

<p>
\[ \{ ab, ba, ac, ca, bc, cb \} \]
</p>

<p>
The formula for a \(k\)-permutation uses the product rule again, this time making choices on a sequence of length \(n-k+1\):
</p>

<p>
\[ (n)(n-1)(n-2)\dots (n-k+1) = \frac {n!} {(n-k)!} \]
</p>

</section>

</main>

</div>

<footer>

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

</footer>


<nav class="botnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>

</body>
</html>
<!--|Start file|Foundations.html|-->

<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Anthony" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="Personal notes on Mathematics and Computer Science" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Notes on Everything — Foundations</title>
<link rel="stylesheet" type="text/css" href="lwarp.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
  subequations: "0",
  section: "",
  loader: {
    load: ['[tex]/tagformat', '[tex]/textmacros'],
  },
  startup: {
    ready() {
      // These would be replaced by import commands if you wanted to make
      // a proper extension.
      const Configuration = MathJax._.input.tex.Configuration.Configuration;
      const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
      const Macro = MathJax._.input.tex.Symbol.Macro;
      const TexError = MathJax._.input.tex.TexError.default;
      const ParseUtil = MathJax._.input.tex.ParseUtil.default;
      const expandable = MathJax._.util.Options.expandable;

       // Insert the replacement string into the TeX string, and check
       // that there haven't been too many maxro substitutions (prevents
       // infinite loops).
       const useArgument = (parser, text) => {
         parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
         parser.i = 0;
         if (++parser.macroCount > parser.configuration.options.maxMacros) {
           throw new TexError('MaxMacroSub1',
           'MathJax maximum macro substitution count exceeded; ' +
           'is there a recursive macro call?');
         }
       }

       // Create the command map for:
       //     \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
       new CommandMap('Lwarp-macros', {
         ifstar: 'IfstarFunction',
         ifnextchar: 'IfnextcharFunction',
         ifblank: 'IfblankFunction',
         ifstrequal: 'IfstrequalFunction',
         gsubstitute: 'GsubstituteFunction',
         seteqnumber: 'SeteqnumberFunction'
       }, {
         // This function implements an ifstar macro.
         IfstarFunction(parser, name) {
            const resultstar = parser.GetArgument(name);
            const resultnostar = parser.GetArgument(name);
            const star = parser.GetStar();                 // true if there is a *
            useArgument(parser, star ? resultstar : resultnostar);
         },

          // This function implements an ifnextchar macro.
          IfnextcharFunction(parser, name) {
            let whichchar = parser.GetArgument(name);
            if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
              // $ syntax highlighting
              whichchar = String.fromCodePoint(parseInt(whichchar));
            }
            const resultnextchar = parser.GetArgument(name);
            const resultnotnextchar = parser.GetArgument(name);
            const gotchar = (parser.GetNext() === whichchar);
            useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
          },

          // This function implements an ifblank macro.
          IfblankFunction(parser, name) {
            const blankarg = parser.GetArgument(name);
            const resultblank = parser.GetArgument(name);
            const resultnotblank = parser.GetArgument(name);
            const isblank = (blankarg.trim() == "");
            useArgument(parser, isblank ? resultblank : resultnotblank);
          },

          // This function implements an ifstrequal macro.
          IfstrequalFunction(parser, name) {
            const strequalfirst = parser.GetArgument(name);
            const strequalsecond = parser.GetArgument(name);
            const resultequal = parser.GetArgument(name);
            const resultnotequal = parser.GetArgument(name);
            const isequal = (strequalfirst == strequalsecond);
            useArgument(parser, isequal ? resultequal : resultnotequal);
          },

          // This function implements a gsub macro.
          GsubstituteFunction(parser, name) {
            const gsubfirst = parser.GetArgument(name);
            const gsubsecond = parser.GetArgument(name);
            const gsubthird = parser.GetArgument(name);
            let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
            useArgument(parser, gsubresult);
          },

          // This function modifies the equation numbers.
          SeteqnumberFunction(parser, name) {
              // Get the macro parameters
              const star = parser.GetStar();                  // true if there is a *
              const optBrackets = parser.GetBrackets(name);   // contents of optional brackets
              const newsubequations = parser.GetArgument(name); // the subequations argument
              const neweqsection = parser.GetArgument(name); // the eq section argument
              const neweqnumber = parser.GetArgument(name);   // the eq number argument
              MathJax.config.subequations=newsubequations ;   // a string with boolean meaning
              MathJax.config.section=neweqsection ;           // a string with numeric meaning
              parser.tags.counter = parser.tags.allCounter = neweqnumber ;
          }

       });

       // Create the Lwarp-macros package
       Configuration.create('Lwarp-macros', {
         handler: {macro: ['Lwarp-macros']}
       });

       MathJax.startup.defaultReady();

       // For forward references:
       MathJax.startup.input[0].preFilters.add(({math}) => {
         if (math.inputData.recompile){
             MathJax.config.subequations = math.inputData.recompile.subequations;
             MathJax.config.section = math.inputData.recompile.section;
         }
       });
       MathJax.startup.input[0].postFilters.add(({math}) => {
         if (math.inputData.recompile){
             math.inputData.recompile.subequations = MathJax.config.subequations;
             math.inputData.recompile.section = MathJax.config.section;
         }
       });

         // For \left, \right with unicode-math:
         const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
         const {Symbol} = MathJax._.input.tex.Symbol;
         const {MapHandler} = MathJax._.input.tex.MapHandler;
         const delimiter = MapHandler.getMap('delimiter');
         delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
         delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
         delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
         delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
         delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
         delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
         delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
         delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
         delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
         delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
         delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
         delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
         delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
         delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
         delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
         delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
         delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
         delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
         delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
         delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
         delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
         delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
         delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
         delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
         delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
         delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
         delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
         delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
         delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
         delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
         delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
         delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
         delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
         delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
         delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
         delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
         delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
         delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
         delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
   }     // ready
 },      // startup

 tex: {
   packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
   tags: "ams",
        tagformat: {
            number: function (n) {
                if(MathJax.config.subequations==0)
                    return(MathJax.config.section + n);
                else
                    return(MathJax.config.section + String.fromCharCode(96+n));
            },
        },
 }
}
</script>

<script
    id="MathJax-script"
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="index-autopage-69"></a>
<nav class="topnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Notes on Everything</span>
</p>

<p>
Subjects
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="Sums.html#autosec-6" class="tocchapter" >
Sums</a>
</p>


<p>
<a href="Sums.html#autosec-7" class="tocsection" >
Manipulating Sums</a>
</p>


<p>
<a href="Sums.html#autosec-8" class="tocsubsection" >
Basic Rules</a>
</p>


<p>
<a href="Sums.html#autosec-10" class="tocsubsection" >
Iverson Notation</a>
</p>


<p>
<a href="Sums.html#autosec-13" class="tocsubsection" >
Perturbing the Sum</a>
</p>


<p>
<a href="Sums.html#autosec-16" class="tocsubsection" >
Multiple Sums</a>
</p>


<p>
<a href="Algorithms.html#autosec-24" class="tocchapter" >
Algorithms</a>
</p>


<p>
<a href="Algorithms.html#autosec-25" class="tocsection" >
Greedy</a>
</p>


<p>
<a href="Algorithms.html#autosec-26" class="tocsubsection" >
Dijkstra’s Shortest Path Algorithm</a>
</p>


<p>
<a href="Algorithms.html#autosec-34" class="tocsubsection" >
Prim’s MST Algorithm</a>
</p>


<p>
<a href="Algorithms.html#autosec-38" class="tocsubsection" >
Kruskal’s MST Algorithm</a>
</p>


<p>
<a href="Algorithms.html#autosec-45" class="tocsubsection" >
Huffman Codes</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-51" class="tocsection" >
Divide and Conquer</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-52" class="tocsubsection" >
Master Theorem</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-54" class="tocsubsection" >
MergeSort</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-56" class="tocsubsection" >
Counting Array Inversions</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-59" class="tocsubsection" >
Karatsuba Multiplication</a>
</p>


<p>
<a href="Combinatorics.html#autosec-61" class="tocchapter" >
Combinatorics</a>
</p>


<p>
<a href="Combinatorics.html#autosec-62" class="tocsection" >
Basics of Counting</a>
</p>


<p>
<a href="Combinatorics.html#autosec-63" class="tocsubsection" >
Product Rule</a>
</p>


<p>
<a href="Combinatorics.html#autosec-64" class="tocsubsection" >
Complement Rule</a>
</p>


<p>
<a href="Combinatorics.html#autosec-65" class="tocsubsection" >
Sum Rule</a>
</p>


<p>
<a href="Combinatorics.html#autosec-66" class="tocsubsection" >
Inclusion/Exclusion</a>
</p>


<p>
<a href="Combinatorics.html#autosec-67" class="tocsubsection" >
Permutations</a>
</p>


<p>
<a href="Foundations.html#autosec-70" class="tocchapter" >
Foundations</a>
</p>


<p>
<a href="Foundations.html#autosec-71" class="tocsection" >
Quadratics</a>
</p>


<p>
<a href="Foundations.html#autosec-72" class="tocsubsection" >
Finding Roots of a Quadratic Function</a>
</p>


<p>
<a href="Foundations.html#autosec-78" class="tocsubsection" >
Vieta’s Theorem</a>
</p>


<p>
<a href="Foundations.html#autosec-81" class="tocsubsection" >
The Quadratic Formula</a>
</p>


</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<h1>Notes on Everything</h1>

<!--MathJax customizations:-->
<div data-nosnippet
    style="display:none"
>

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

</div>

<!--
...... chapter Foundations ......
-->
<h3 id="autosec-70">Foundations</h3>
<a id="index-autopage-70"></a>
<a id="index-autofile-5"></a>

<p>
This section explains a lot of what highschool teachers ought to have during math class. Oh well.
</p>
<!--
...... section Quadratics ......
-->
<h4 id="autosec-71">Quadratics</h4>
<a id="index-autopage-71"></a>


<p>
Polynomials of the form \(ax^2 + bx + c\) are called <b>quadratic</b>. They can also be described as polynomials of degree 2, or <b>second order</b>. A huge number of problems in physics and engineering can be modeled after a quadratic equation, and they occur
frequently enough to warrant some special techniques.
</p>

<p>
\[ \boxed {ax^2 + bx + c} \]
</p>

<p>
where \(a \neq 0\)
</p>
<!--
...... subsection Finding Roots of a Quadratic Function ......
-->
<h5 id="autosec-72">Finding Roots of a Quadratic Function</h5>
<a id="index-autopage-72"></a>


<p>
A <b>root</b> of a polynomial function \(f\) is a number, say, \(\alpha \), such that \(f(\alpha ) = 0\). Finding roots of a quadratic function is equivalent to solving \(f(x) = ax^2 + bx + c = 0\).
</p>

<p>
Several techniques for finding roots exist:
</p>
<!--
...... subsubsection Factoring ......
-->
<h6 id="autosec-73">Factoring</h6>
<a id="index-autopage-73"></a>


<p>
Factoring here is used in the same context as listing the factors of an integer, such as in <em>prime factorization</em>. Factoring allows the polynomial to be written in such as a way as to make the values for which it takes on the value zero to be obvious.
</p>

<p>
Every polynomial can be written as a product of its factors. Quadratics have a simple form:
</p>

<p>
\[ P(x) = (x - \alpha )(x - \beta ) \]
</p>

<p>
where \(\alpha \) and \(\beta \) are roots of polynomial \(P\).
</p>

<p>
For example,
</p>

<p>
\[ x^2 - 4 = (x - 2)(x + 2) = 0 \]
</p>

<p>
This can easily be factored by noticing the expression is the difference of two squares. This equation has solutions at \(x \pm 2\).
</p>
<!--
...... subsubsection Completing the Square ......
-->
<h6 id="autosec-74">Completing the Square</h6>
<a id="index-autopage-74"></a>


<p>
A good indication to try this technique is when a quadratic function has a 1 as its first coefficient.
</p>

<p>
\[ x^2 + bx + c \]
</p>

<p>
This is referred to as a <b>reduced quadratic</b> form.
</p>

<p>
Completing the square is often taught as a formula to be memorized without any context or justification as to why it works. It helps to consider both what we mean geometrically and then derive the formula with algebra.
</p>
<!--
...... paragraph Geometric ......
-->


<p>
<span class="paragraph" id="autosec-75">Geometric</span>
<a id="index-autopage-75"></a>

</p>

<p>
TODO
</p>
<!--
...... paragraph Algebraic ......
-->


<p>
<span class="paragraph" id="autosec-76">Algebraic</span>
<a id="index-autopage-76"></a>

</p>

<p>
The clever idea behind coming up with the formula lies in thinking about what term would need to be added to \(x^2 + bx\) in order to make it a perfect square. Another way of thinking about this is how we could start with the square of a binomial, \((x + k)^2\) and
figure out what \(k\) and \(c\) need to be in order to be equivalent to the lefthand side<sup>2</sup>:
</p>

<p>
\[ x^2 + bx = (x + k)^2 - c \]
</p>

<p>
Naively computing \((x + b)^2\) might reveal a hint, since we’d end up with the square of a binomial by design. let \(k = b\):
</p>

<p>
\[ (x + b)^2 = x^2 + 2bx + b^2 \]
</p>

<p>
This is closer, but we got \(2bx\) instead of \(bx\) like we wanted. To get \(bx\), we could let \(k = \frac b 2\). Now see what happens:
</p>

<p>
\[ (x + \frac b 2)^2 = x^2 + 2 (\frac b 2) x + (\frac b 2)^2 \]
</p>

<p>
Nearly there! All that’s left to do is subtract \(c = (\frac b 2)^2\) from the equation. This gives us:
</p>

<p>
\[ \boxed {x^2 + bx = (x + \frac b 2)^2 - (\frac b 2)^2} \]
</p>

<p>
A typical follow-up to completing the square is solving for \(x\) via a shortcut used when an expression is the <em>difference of two squares</em>.
</p>
<div role="note" class="footnotes">

<a id="index-autopage-77"></a>
<p>
<sup>2</sup>&nbsp;Working backwards like this is the way that clicked for me when nothing else did
</p>


</div>
<!--
...... subsection Vieta's Theorem ......
-->
<h5 id="autosec-78">Vieta’s Theorem</h5>
<a id="index-autopage-78"></a>


<p>
Vieta’s theorem describes the roots of a quadratic polynomial in terms of its coefficients. This is especially helpful in eliminating candidates for roots if a more straightforward approach fails.
</p>

<p>
If a quadratic expression \(x^2 + px + q\) has distinct roots \(\alpha , \beta \), then
</p>

<span class="hidden"> \(\seteqnumber{0}{}{1}\)</span>


<!--


                                                                                         α+β                                                                                            = −p           (2)
                                                                                         αβ                                                                                             = −q           (3)


-->


<p>

\begin{align}
&amp;\alpha + \beta &amp;= -p \\ &amp;\alpha \beta &amp;= -q
\end{align}

</p>
<div class="amsthmproof">

<a id="index-autopage-79"></a>

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> (Theorem): <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

<p>
Vieta’s theorem also has a corollary:
</p>

<p>
If a quadratic expression \(x^2 + px + q\) has distinct roots \(\alpha , \beta \),
</p>

<p>
\[ (x - \alpha )(x - \beta ) = x^2 - (\alpha + \beta ) + \alpha \beta \]
</p>
<div class="amsthmproof">

<a id="index-autopage-80"></a>

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<!--
...... subsection The Quadratic Formula ......
-->
<h5 id="autosec-81">The Quadratic Formula</h5>
<a id="index-autopage-81"></a>


<p>
The famous quadratic formula has a surprisingly simple derivation based on the formula for completing the square. Simply solving a ”completed square” for \(x\) yields the formula.
</p>

<p>
Begin by factoring out the leading coefficient \(a\):
</p>

<span class="hidden"> \(\seteqnumber{0}{}{3}\)</span>


<!--


                                                                                  b     c
                                                             ax2 + bx + c = x2 + ( )x +
                                                                                  a     a

                                                                                    b 2     b    c
                                                                          = (x +      ) − ( )x −                                                                                      completing the square
                                                                                   2a      2a    a


                                                                                    b 2   b2 − 4ac
                                                                          = (x +      ) −                                                                                                        by algebra
                                                                                   2a        4a2

                                                                                        s                         s
                                                                                  b         b2 − 4ac        b         b2 − 4ac
                                                                          = (x +    +                )(x +    −                )                                                       difference of squares
                                                                                 2a            4a2         2a            4a2

                                                                                                √
                                                                                        b           b2 − 4ac
                                                                           =⇒ x = −       ±
                                                                                       2a             2a

                                                                                            √
                                                                                     −b ±     b2 − 4ac
                                                                           =⇒ x =
                                                                                             2a


-->


<p>

\begin{align*}
\label {eqn:quadratic_formula} ax^2 + bx + c &amp;= x^2 + (\frac b a)x + \frac c a \\\\ &amp;= (x + \frac b {2a})^2 - (\frac b {2a})x - \frac c a &amp;\text {completing the square} \\\\ &amp;= (x + \frac b {2a})^2 - \frac {b^2 - 4ac}
{4a^2} &amp;\text {by algebra} \\\\ &amp;= (x + \frac b {2a} + \sqrt {\frac {b^2 - 4ac} {4a^2}})(x + \frac b {2a} - \sqrt {\frac {b^2 - 4ac} {4a^2}}) &amp;\text {difference of squares} \\\\ &amp;\implies x = -\frac b {2a} \pm \frac {\sqrt
{b^2 - 4ac}} {2a} \\\\ &amp;\implies x = \frac {-b \pm \sqrt {b^2 - 4ac}} {2a}
\end{align*}

</p>
<a id="index-autofile-last"></a>
</section>

</main>

</div>

<footer>

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

</footer>


<nav class="botnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>

</body>
</html>
