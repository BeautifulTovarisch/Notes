
<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Anthony" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="Personal notes on Mathematics and Computer Science" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Notes on Everything — Finite Calculus</title>
<link rel="stylesheet" type="text/css" href="lwarp.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
  subequations: "0",
  section: "",
  loader: {
    load: ['[tex]/tagformat', '[tex]/textmacros'],
  },
  startup: {
    ready() {
      // These would be replaced by import commands if you wanted to make
      // a proper extension.
      const Configuration = MathJax._.input.tex.Configuration.Configuration;
      const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
      const Macro = MathJax._.input.tex.Symbol.Macro;
      const TexError = MathJax._.input.tex.TexError.default;
      const ParseUtil = MathJax._.input.tex.ParseUtil.default;
      const expandable = MathJax._.util.Options.expandable;

       // Insert the replacement string into the TeX string, and check
       // that there haven't been too many maxro substitutions (prevents
       // infinite loops).
       const useArgument = (parser, text) => {
         parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
         parser.i = 0;
         if (++parser.macroCount > parser.configuration.options.maxMacros) {
           throw new TexError('MaxMacroSub1',
           'MathJax maximum macro substitution count exceeded; ' +
           'is there a recursive macro call?');
         }
       }

       // Create the command map for:
       //     \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
       new CommandMap('Lwarp-macros', {
         ifstar: 'IfstarFunction',
         ifnextchar: 'IfnextcharFunction',
         ifblank: 'IfblankFunction',
         ifstrequal: 'IfstrequalFunction',
         gsubstitute: 'GsubstituteFunction',
         seteqnumber: 'SeteqnumberFunction'
       }, {
         // This function implements an ifstar macro.
         IfstarFunction(parser, name) {
            const resultstar = parser.GetArgument(name);
            const resultnostar = parser.GetArgument(name);
            const star = parser.GetStar();                 // true if there is a *
            useArgument(parser, star ? resultstar : resultnostar);
         },

          // This function implements an ifnextchar macro.
          IfnextcharFunction(parser, name) {
            let whichchar = parser.GetArgument(name);
            if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
              // $ syntax highlighting
              whichchar = String.fromCodePoint(parseInt(whichchar));
            }
            const resultnextchar = parser.GetArgument(name);
            const resultnotnextchar = parser.GetArgument(name);
            const gotchar = (parser.GetNext() === whichchar);
            useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
          },

          // This function implements an ifblank macro.
          IfblankFunction(parser, name) {
            const blankarg = parser.GetArgument(name);
            const resultblank = parser.GetArgument(name);
            const resultnotblank = parser.GetArgument(name);
            const isblank = (blankarg.trim() == "");
            useArgument(parser, isblank ? resultblank : resultnotblank);
          },

          // This function implements an ifstrequal macro.
          IfstrequalFunction(parser, name) {
            const strequalfirst = parser.GetArgument(name);
            const strequalsecond = parser.GetArgument(name);
            const resultequal = parser.GetArgument(name);
            const resultnotequal = parser.GetArgument(name);
            const isequal = (strequalfirst == strequalsecond);
            useArgument(parser, isequal ? resultequal : resultnotequal);
          },

          // This function implements a gsub macro.
          GsubstituteFunction(parser, name) {
            const gsubfirst = parser.GetArgument(name);
            const gsubsecond = parser.GetArgument(name);
            const gsubthird = parser.GetArgument(name);
            let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
            useArgument(parser, gsubresult);
          },

          // This function modifies the equation numbers.
          SeteqnumberFunction(parser, name) {
              // Get the macro parameters
              const star = parser.GetStar();                  // true if there is a *
              const optBrackets = parser.GetBrackets(name);   // contents of optional brackets
              const newsubequations = parser.GetArgument(name); // the subequations argument
              const neweqsection = parser.GetArgument(name); // the eq section argument
              const neweqnumber = parser.GetArgument(name);   // the eq number argument
              MathJax.config.subequations=newsubequations ;   // a string with boolean meaning
              MathJax.config.section=neweqsection ;           // a string with numeric meaning
              parser.tags.counter = parser.tags.allCounter = neweqnumber ;
          }

       });

       // Create the Lwarp-macros package
       Configuration.create('Lwarp-macros', {
         handler: {macro: ['Lwarp-macros']}
       });

       MathJax.startup.defaultReady();

       // For forward references:
       MathJax.startup.input[0].preFilters.add(({math}) => {
         if (math.inputData.recompile){
             MathJax.config.subequations = math.inputData.recompile.subequations;
             MathJax.config.section = math.inputData.recompile.section;
         }
       });
       MathJax.startup.input[0].postFilters.add(({math}) => {
         if (math.inputData.recompile){
             math.inputData.recompile.subequations = MathJax.config.subequations;
             math.inputData.recompile.section = MathJax.config.section;
         }
       });

         // For \left, \right with unicode-math:
         const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
         const {Symbol} = MathJax._.input.tex.Symbol;
         const {MapHandler} = MathJax._.input.tex.MapHandler;
         const delimiter = MapHandler.getMap('delimiter');
         delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
         delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
         delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
         delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
         delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
         delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
         delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
         delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
         delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
         delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
         delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
         delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
         delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
         delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
         delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
         delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
         delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
         delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
         delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
         delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
         delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
         delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
         delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
         delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
         delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
         delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
         delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
         delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
         delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
         delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
         delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
         delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
         delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
         delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
         delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
         delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
         delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
         delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
         delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
   }     // ready
 },      // startup

 tex: {
   packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
   tags: "ams",
        tagformat: {
            number: function (n) {
                if(MathJax.config.subequations==0)
                    return(MathJax.config.section + n);
                else
                    return(MathJax.config.section + String.fromCharCode(96+n));
            },
        },
 }
}
</script>

<script
    id="MathJax-script"
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="index-autopage-23"></a>
<nav class="topnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Notes on Everything</span>
</p>

<p>
Subjects
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="Sums.html#autosec-6" class="tocchapter" >
Sums</a>
</p>


<p>
<a href="Sums.html#autosec-7" class="tocsection" >
Manipulating Sums</a>
</p>


<p>
<a href="Sums.html#autosec-8" class="tocsubsection" >
Basic Rules</a>
</p>


<p>
<a href="Sums.html#autosec-10" class="tocsubsection" >
Iverson Notation</a>
</p>


<p>
<a href="Sums.html#autosec-13" class="tocsubsection" >
Perturbing the Sum</a>
</p>


<p>
<a href="Sums.html#autosec-16" class="tocsubsection" >
Multiple Sums</a>
</p>


<p>
<a href="Finite-Calculus.html#autosec-24" class="tocsection" >
Finite Calculus</a>
</p>


<p>
<a href="Finite-Calculus.html#autosec-25" class="tocsubsection" >
The Difference Operator</a>
</p>


<p>
<a href="Finite-Calculus.html#autosec-26" class="tocsubsection" >
Rising and Falling Factorials</a>
</p>


<p>
<a href="Algorithms.html#autosec-30" class="tocchapter" >
Algorithms</a>
</p>


<p>
<a href="Algorithms.html#autosec-31" class="tocsection" >
Graphs</a>
</p>


<p>
<a href="Algorithms.html#autosec-32" class="tocsubsection" >
Cuts</a>
</p>


<p>
<a href="Algorithms.html#autosec-42" class="tocsubsection" >
Depth-First Search</a>
</p>


<p>
<a href="Algorithms.html#autosec-44" class="tocsubsection" >
Breadth-First Search</a>
</p>


<p>
<a href="Algorithms.html#autosec-46" class="tocsubsection" >
Topological Ordering</a>
</p>


<p>
<a href="Algorithms.html#autosec-47" class="tocsubsection" >
Strongly Connected Components</a>
</p>


<p>
<a href="Greedy.html#autosec-49" class="tocsection" >
Greedy</a>
</p>


<p>
<a href="Greedy.html#autosec-50" class="tocsubsection" >
Dijkstra’s Shortest Path Algorithm</a>
</p>


<p>
<a href="Greedy.html#autosec-61" class="tocsubsection" >
Prim’s MST Algorithm</a>
</p>


<p>
<a href="Greedy.html#autosec-67" class="tocsubsection" >
Kruskal’s MST Algorithm</a>
</p>


<p>
<a href="Greedy.html#autosec-74" class="tocsubsection" >
Huffman Codes</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-81" class="tocsection" >
Divide and Conquer</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-82" class="tocsubsection" >
Master Theorem</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-84" class="tocsubsection" >
MergeSort</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-86" class="tocsubsection" >
Counting Array Inversions</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-89" class="tocsubsection" >
Karatsuba Multiplication</a>
</p>


<p>
<a href="Combinatorics.html#autosec-91" class="tocchapter" >
Combinatorics</a>
</p>


<p>
<a href="Combinatorics.html#autosec-92" class="tocsection" >
Basics of Counting</a>
</p>


<p>
<a href="Combinatorics.html#autosec-93" class="tocsubsection" >
Product Rule</a>
</p>


<p>
<a href="Combinatorics.html#autosec-96" class="tocsubsection" >
Complement Rule</a>
</p>


<p>
<a href="Combinatorics.html#autosec-100" class="tocsubsection" >
Inclusion/Exclusion</a>
</p>


<p>
<a href="Combinatorics.html#autosec-103" class="tocsubsection" >
Permutations</a>
</p>


<p>
<a href="Probability.html#autosec-106" class="tocchapter" >
Probability</a>
</p>


<p>
<a href="Probability.html#autosec-107" class="tocsection" >
Basics</a>
</p>


<p>
<a href="Probability.html#autosec-108" class="tocsubsection" >
Terminology</a>
</p>


<p>
<a href="Probability.html#autosec-110" class="tocsubsection" >
Naive Definition of Probability</a>
</p>


<p>
<a href="Probability.html#autosec-112" class="tocsubsection" >
Non-Naive Definition of Probability</a>
</p>


<p>
<a href="Foundations.html#autosec-117" class="tocchapter" >
Foundations</a>
</p>


<p>
<a href="Foundations.html#autosec-118" class="tocsection" >
Set Theory</a>
</p>


<p>
<a href="Foundations.html#autosec-122" class="tocsubsection" >
Basic Definitions</a>
</p>


<p>
<a href="Foundations.html#autosec-123" class="tocsubsection" >
Laws</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-149" class="tocsection" >
Factoring Tricks</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-150" class="tocsubsection" >
Basic Identities</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-151" class="tocsubsection" >
Splitting Apart a Monomial</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-152" class="tocsubsection" >
Adding Zero</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-153" class="tocsubsection" >
\((a^n - b^n) \)</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-155" class="tocsubsection" >
\((a^n + b^n) \)</a>
</p>


<p>
<a href="Quadratics.html#autosec-159" class="tocsection" >
Quadratics</a>
</p>


<p>
<a href="Quadratics.html#autosec-160" class="tocsubsection" >
Finding Roots of a Quadratic Function</a>
</p>


<p>
<a href="Quadratics.html#autosec-166" class="tocsubsection" >
Vieta’s Theorem</a>
</p>


<p>
<a href="Quadratics.html#autosec-169" class="tocsubsection" >
The Quadratic Formula</a>
</p>


</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<h1>Notes on Everything</h1>

<!--MathJax customizations:-->
<div data-nosnippet
    style="display:none"
>

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

</div>

<!--
...... section Finite Calculus ......
-->
<h4 id="autosec-24">Finite Calculus</h4>
<a id="index-autopage-24"></a>
<a id="index-autofile-2"></a>

<p>
Finite Calculus establishes analogs between the techniques of infinite Calculus (Analysis etc.) in order to develop sophisticated ways of dealing with sums. Specifically, we’re after methods that remind us of dealing with integrals and derivatives since there are nice formulas
and tricks for handling those most of the time.
</p>

<p>
Another important theme of Finite Calculus is discovering functions that act as discrete versions of their continuous counterparts. If we can find a finite analog of a function, we’ll have an easier time reasoning about a closed form solution.
</p>
<!--
...... subsection The Difference Operator ......
-->
<h5 id="autosec-25">The Difference Operator</h5>
<a id="index-autopage-25"></a>


<p>
One of the first facts established in Calculus is the limit definition of the derivative of a function:
</p>

<p>
\[ \frac d {dx} f(x) = \lim _{h \to 0} \frac {f(x + h) - f(x)} h \]
</p>

<p>
The righthand side is the limit of the <b>difference quotient</b> of \(f(x)\) as \(h\) approaches 0. In the finite world, there is a similar operation:
</p>

<span class="hidden"> \(\seteqnumber{0}{}{0}\)</span>

<!--


                                                                                                                            ∆f (x) = f (x + 1) − f (x)

-->

<p>

\begin{equation*}
\Delta f(x) = f(x + 1) - f(x)
\end{equation*}

</p>

<p>
This is known as the <b>difference operator</b>. Since we’re dealing with a discrete function and not a continous one, we have to restrict \(h\) to being an integer. The closest integer \(h\) can be without being 0 is 1. This gives a nice tie-in to the limit definition.
</p>

<p>
Crucially, \(\Delta f(x)\) is called an <em>operator</em>, because it operates on \(f(x)\) and produces another function, similar to differentiation. Introducing this operator allows for the development of more sophisticated tools a little later.
</p>
<!--
...... subsection Rising and Falling Factorials ......
-->
<h5 id="autosec-26">Rising and Falling Factorials</h5>
<a id="index-autopage-26"></a>


<p>
Unfortunately, the convenient power rule of differential Calculus:
</p>

<p>
\[ \frac d {dx} x^m = mx^{m-1} \]
</p>

<p>
fails miserably in the finite world:
</p>

<p>
\[ \Delta (x^3) = (x + 1)^3 - x^3 = 3x^2 + 3x + 1 \neq 3x^2 \]
</p>

<p>
At least for polynomials. There are, however, interesting functions for which the difference operator is a near-perfect match-up to differentiation, although this fact is not obvious right away. Some definitions first:
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><a id="index-autopage-27"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">1</span></span>. </span> Falling Factorial
</p>

<p>
Let \(m\) be an integer and \(x\) be any real number. Define the falling factorial of \(x\) as:
</p>

<p>
\[ x^{\underline {m}} = x(x-1)(x-2)\dots (x-m+1) \]
</p>

<p>


</p>

</li>

</ul>

</div>

<p>
and
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><a id="index-autopage-28"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">2</span></span>. </span> Rising Factorial
</p>

<p>
Let \(m\) be an integer and \(x\) be any real number. Define the rising factorial of \(x\) as:
</p>

<p>
\[ x^{\overline {m}} = x(x+1)(x+2)\dots (x+m-1) \]
</p>

<p>


</p>

</li>

</ul>

</div>

<p>
\(m\) denotes the number of terms in the factorial product, and the line above or below \(m\) determines whether the terms are increasing or decreasing. There’s a hint here that the difference operator might be important. Taking a peek at the first two consecutive terms
in the product, they have the form:
</p>

<p>
\[ (x)(x+1) \; \text {or} \; x(x-1) \]
</p>

<p>
It’s still too early to tell what’s going on, but this deserves some suspicion.
</p>

<p>
This strange notation takes some getting used to, but is ultimately a very neat way of compressing a lot of information into notation that can be manipulated.
</p>

<p>
Here’s an explanation for why there are \(m\) terms:
</p>

<span class="hidden"> \(\seteqnumber{0}{}{0}\)</span>


<!--


                                                                                                                     xm = x(x − 1)(x − 2) . . . (x − m + 1)
                                                                                                                          |             {z                }
                                                                                                                                x−(x−m+1)+1=m terms



-->


<p>

\begin{align*}
x^{\underline {m}} = \underbrace {x(x-1)(x-2)\dots (x-m+1)}_{x - (x - m + 1) + 1 = m \; \text {terms}}
\end{align*}

</p>

<span class="hidden"> \(\seteqnumber{0}{}{0}\)</span>


<!--


                                                                                                                     xm = x(x + 1)(x + 2) . . . (x + m − 1)
                                                                                                                          |             {z                }
                                                                                                                                (x+m−1)−x+1=m terms



-->


<p>

\begin{align*}
x^{\overline {m}} = \underbrace {x(x+1)(x+2)\dots (x+m-1)}_{(x + m - 1) - x + 1 = m \; \text {terms}}
\end{align*}

</p>

<p>
This comes from counting how many integers there are in a given range. As an example, there are \((5 - 2) + 1 = 4\) integers between 2 and 5.
</p>

<p>
Here’s a visual aid as a quick refresher:
</p>

<p>
But what does this have to do with the difference operator? The answer may lie in blindly applying the operator and seeing what happens. Nothing ventured!
</p>

<span class="hidden"> \(\seteqnumber{0}{}{0}\)</span>


<!--


                                                                                            ∆(xm ) = (x + 1)m − xm


                                                                                                   = (x + 1)(x)(x − 1) . . . (x − m + 2) − x(x − 1)(x − 2) . . . (x − m + 2)(x − m + 1)


                                                                                                   = x(x − 1)(x − 2) . . . (x − m + 2)(x + 1 − (x − m + 1))


                                                                                                   = m[x(x − 1)(x − 2) . . . (x − m + 2)]


-->


<p>

\begin{align*}
\Delta (x^{\underline {m}}) &amp;= (x + 1)^{\underline {m}} - x^{\underline {m}} \\ \\ &amp;= (x+1)(x)(x-1)\dots (x-m+2) - x(x-1)(x-2)\dots (x-m+2)(x-m+1) \\ \\ &amp;= x(x-1)(x-2)\dots (x-m+2)(x + 1 - (x - m + 1)) \\ \\ &amp;=
m[x(x-1)(x-2)\dots (x-m+2)]
\end{align*}

</p>

<p>
Some clever factoring got us an \(m\) times something vaguely familiar. Let’s try counting how many terms there are:
</p>

<p>
\[ x - (x - m + 2) + 1 = m - 1 \; \text {terms} \]
</p>

<p>
This rings a bell! We have a product of \(m - 1\) decreasing terms. Don’t we have a way of cramming that into a compact expression? Putting it all together:
</p>

<p>
\[ \Delta (x^{\underline {m}}) = mx^{\underline {m-1}} \]
</p>

<p>
which bears a striking similarity to the power rule.
</p>

</section>

</main>

</div>

<footer>

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

</footer>


<nav class="botnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>

</body>
</html>
