
<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Anthony" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="Personal notes on Mathematics and Computer Science" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Notes on Everything — Algorithms</title>
<link rel="stylesheet" type="text/css" href="lwarp.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
  subequations: "0",
  section: "",
  loader: {
    load: ['[tex]/tagformat', '[tex]/textmacros'],
  },
  startup: {
    ready() {
      // These would be replaced by import commands if you wanted to make
      // a proper extension.
      const Configuration = MathJax._.input.tex.Configuration.Configuration;
      const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
      const Macro = MathJax._.input.tex.Symbol.Macro;
      const TexError = MathJax._.input.tex.TexError.default;
      const ParseUtil = MathJax._.input.tex.ParseUtil.default;
      const expandable = MathJax._.util.Options.expandable;

       // Insert the replacement string into the TeX string, and check
       // that there haven't been too many maxro substitutions (prevents
       // infinite loops).
       const useArgument = (parser, text) => {
         parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
         parser.i = 0;
         if (++parser.macroCount > parser.configuration.options.maxMacros) {
           throw new TexError('MaxMacroSub1',
           'MathJax maximum macro substitution count exceeded; ' +
           'is there a recursive macro call?');
         }
       }

       // Create the command map for:
       //     \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
       new CommandMap('Lwarp-macros', {
         ifstar: 'IfstarFunction',
         ifnextchar: 'IfnextcharFunction',
         ifblank: 'IfblankFunction',
         ifstrequal: 'IfstrequalFunction',
         gsubstitute: 'GsubstituteFunction',
         seteqnumber: 'SeteqnumberFunction'
       }, {
         // This function implements an ifstar macro.
         IfstarFunction(parser, name) {
            const resultstar = parser.GetArgument(name);
            const resultnostar = parser.GetArgument(name);
            const star = parser.GetStar();                 // true if there is a *
            useArgument(parser, star ? resultstar : resultnostar);
         },

          // This function implements an ifnextchar macro.
          IfnextcharFunction(parser, name) {
            let whichchar = parser.GetArgument(name);
            if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
              // $ syntax highlighting
              whichchar = String.fromCodePoint(parseInt(whichchar));
            }
            const resultnextchar = parser.GetArgument(name);
            const resultnotnextchar = parser.GetArgument(name);
            const gotchar = (parser.GetNext() === whichchar);
            useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
          },

          // This function implements an ifblank macro.
          IfblankFunction(parser, name) {
            const blankarg = parser.GetArgument(name);
            const resultblank = parser.GetArgument(name);
            const resultnotblank = parser.GetArgument(name);
            const isblank = (blankarg.trim() == "");
            useArgument(parser, isblank ? resultblank : resultnotblank);
          },

          // This function implements an ifstrequal macro.
          IfstrequalFunction(parser, name) {
            const strequalfirst = parser.GetArgument(name);
            const strequalsecond = parser.GetArgument(name);
            const resultequal = parser.GetArgument(name);
            const resultnotequal = parser.GetArgument(name);
            const isequal = (strequalfirst == strequalsecond);
            useArgument(parser, isequal ? resultequal : resultnotequal);
          },

          // This function implements a gsub macro.
          GsubstituteFunction(parser, name) {
            const gsubfirst = parser.GetArgument(name);
            const gsubsecond = parser.GetArgument(name);
            const gsubthird = parser.GetArgument(name);
            let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
            useArgument(parser, gsubresult);
          },

          // This function modifies the equation numbers.
          SeteqnumberFunction(parser, name) {
              // Get the macro parameters
              const star = parser.GetStar();                  // true if there is a *
              const optBrackets = parser.GetBrackets(name);   // contents of optional brackets
              const newsubequations = parser.GetArgument(name); // the subequations argument
              const neweqsection = parser.GetArgument(name); // the eq section argument
              const neweqnumber = parser.GetArgument(name);   // the eq number argument
              MathJax.config.subequations=newsubequations ;   // a string with boolean meaning
              MathJax.config.section=neweqsection ;           // a string with numeric meaning
              parser.tags.counter = parser.tags.allCounter = neweqnumber ;
          }

       });

       // Create the Lwarp-macros package
       Configuration.create('Lwarp-macros', {
         handler: {macro: ['Lwarp-macros']}
       });

       MathJax.startup.defaultReady();

       // For forward references:
       MathJax.startup.input[0].preFilters.add(({math}) => {
         if (math.inputData.recompile){
             MathJax.config.subequations = math.inputData.recompile.subequations;
             MathJax.config.section = math.inputData.recompile.section;
         }
       });
       MathJax.startup.input[0].postFilters.add(({math}) => {
         if (math.inputData.recompile){
             math.inputData.recompile.subequations = MathJax.config.subequations;
             math.inputData.recompile.section = MathJax.config.section;
         }
       });

         // For \left, \right with unicode-math:
         const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
         const {Symbol} = MathJax._.input.tex.Symbol;
         const {MapHandler} = MathJax._.input.tex.MapHandler;
         const delimiter = MapHandler.getMap('delimiter');
         delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
         delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
         delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
         delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
         delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
         delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
         delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
         delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
         delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
         delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
         delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
         delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
         delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
         delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
         delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
         delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
         delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
         delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
         delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
         delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
         delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
         delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
         delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
         delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
         delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
         delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
         delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
         delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
         delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
         delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
         delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
         delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
         delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
         delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
         delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
         delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
         delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
         delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
         delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
   }     // ready
 },      // startup

 tex: {
   packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
   tags: "ams",
        tagformat: {
            number: function (n) {
                if(MathJax.config.subequations==0)
                    return(MathJax.config.section + n);
                else
                    return(MathJax.config.section + String.fromCharCode(96+n));
            },
        },
 }
}
</script>

<script
    id="MathJax-script"
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="index-autopage-23"></a>
<nav class="topnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Notes on Everything</span>
</p>

<p>
Subjects
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="Sums.html#autosec-6" class="tocchapter" >
Sums</a>
</p>


<p>
<a href="Sums.html#autosec-7" class="tocsection" >
Manipulating Sums</a>
</p>


<p>
<a href="Sums.html#autosec-8" class="tocsubsection" >
Basic Rules</a>
</p>


<p>
<a href="Sums.html#autosec-10" class="tocsubsection" >
Iverson Notation</a>
</p>


<p>
<a href="Sums.html#autosec-13" class="tocsubsection" >
Perturbing the Sum</a>
</p>


<p>
<a href="Sums.html#autosec-16" class="tocsubsection" >
Multiple Sums</a>
</p>


<p>
<a href="Algorithms.html#autosec-24" class="tocchapter" >
Algorithms</a>
</p>


<p>
<a href="Algorithms.html#autosec-25" class="tocsection" >
Graphs</a>
</p>


<p>
<a href="Algorithms.html#autosec-26" class="tocsubsection" >
Cuts</a>
</p>


<p>
<a href="Algorithms.html#autosec-36" class="tocsubsection" >
Depth-First Search</a>
</p>


<p>
<a href="Algorithms.html#autosec-38" class="tocsubsection" >
Breadth-First Search</a>
</p>


<p>
<a href="Algorithms.html#autosec-40" class="tocsubsection" >
Topological Ordering</a>
</p>


<p>
<a href="Algorithms.html#autosec-41" class="tocsubsection" >
Strongly Connected Components</a>
</p>


<p>
<a href="Greedy.html#autosec-43" class="tocsection" >
Greedy</a>
</p>


<p>
<a href="Greedy.html#autosec-44" class="tocsubsection" >
Dijkstra’s Shortest Path Algorithm</a>
</p>


<p>
<a href="Greedy.html#autosec-55" class="tocsubsection" >
Prim’s MST Algorithm</a>
</p>


<p>
<a href="Greedy.html#autosec-61" class="tocsubsection" >
Kruskal’s MST Algorithm</a>
</p>


<p>
<a href="Greedy.html#autosec-68" class="tocsubsection" >
Huffman Codes</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-75" class="tocsection" >
Divide and Conquer</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-76" class="tocsubsection" >
Master Theorem</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-78" class="tocsubsection" >
MergeSort</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-80" class="tocsubsection" >
Counting Array Inversions</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-83" class="tocsubsection" >
Karatsuba Multiplication</a>
</p>


<p>
<a href="Combinatorics.html#autosec-85" class="tocchapter" >
Combinatorics</a>
</p>


<p>
<a href="Combinatorics.html#autosec-86" class="tocsection" >
Basics of Counting</a>
</p>


<p>
<a href="Combinatorics.html#autosec-87" class="tocsubsection" >
Product Rule</a>
</p>


<p>
<a href="Combinatorics.html#autosec-88" class="tocsubsection" >
Complement Rule</a>
</p>


<p>
<a href="Combinatorics.html#autosec-89" class="tocsubsection" >
Sum Rule</a>
</p>


<p>
<a href="Combinatorics.html#autosec-90" class="tocsubsection" >
Inclusion/Exclusion</a>
</p>


<p>
<a href="Combinatorics.html#autosec-91" class="tocsubsection" >
Permutations</a>
</p>


<p>
<a href="Foundations.html#autosec-94" class="tocchapter" >
Foundations</a>
</p>


<p>
<a href="Foundations.html#autosec-95" class="tocsection" >
Set Theory</a>
</p>


<p>
<a href="Foundations.html#autosec-99" class="tocsubsection" >
Basic Definitions</a>
</p>


<p>
<a href="Foundations.html#autosec-100" class="tocsubsection" >
Laws</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-126" class="tocsection" >
Factoring Tricks</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-127" class="tocsubsection" >
Basic Identities</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-128" class="tocsubsection" >
Splitting Apart a Monomial</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-129" class="tocsubsection" >
Adding Zero</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-130" class="tocsubsection" >
\((a^n - b^n) \)</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-132" class="tocsubsection" >
\((a^n + b^n) \)</a>
</p>


<p>
<a href="Quadratics.html#autosec-136" class="tocsection" >
Quadratics</a>
</p>


<p>
<a href="Quadratics.html#autosec-137" class="tocsubsection" >
Finding Roots of a Quadratic Function</a>
</p>


<p>
<a href="Quadratics.html#autosec-143" class="tocsubsection" >
Vieta’s Theorem</a>
</p>


<p>
<a href="Quadratics.html#autosec-146" class="tocsubsection" >
The Quadratic Formula</a>
</p>


</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<h1>Notes on Everything</h1>

<!--MathJax customizations:-->
<div data-nosnippet
    style="display:none"
>

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

</div>

<!--
...... chapter Algorithms ......
-->
<h3 id="autosec-24">Algorithms</h3>
<a id="index-autopage-24"></a>
<a id="index-autofile-2"></a>
<!--
...... section Graphs ......
-->
<h4 id="autosec-25">Graphs</h4>
<a id="index-autopage-25"></a>


<a id="sec:graphs"></a>

<p>
An extraordinary number of problems can be modeled by graphs. Despite being relatively simple, graph algorithms form the basis for more advanced solutions to problems concering connectivity, precedence, optimality, and much more. The solution to a graph problem is
usually built on top of the methodology used to explore the nodes in a graph, or <b><em>graph traversal</em></b> algorithm.
</p>
<!--
...... subsection Cuts ......
-->
<h5 id="autosec-26">Cuts</h5>
<a id="index-autopage-26"></a>


<a id="sec:graphs:cuts"></a>

<p>
A graph cut is a way of partitioning the nodes of a graph into two non-empty sets. Cuts and their properties are very useful to model various kinds of graph problems, and algorithms frequently exploit properties of a cut to obtain some desired solution. For example,
certain computer vision problems can be solved using graph-cut optimization algorithms.
</p>

<p>
Considering the edges ”crossing” the cut also reveals information about a graph itself, and is the basis for a large number of graph algorithms.
</p>

<p>
Fun fact:
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><a id="index-autopage-27"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">1</span></span>. </span> A graph \(G = (V,E)\) with \(n \geqslant 2\) vertices has exactly \(2^n - 2\) graph cuts.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="index-autopage-28"></a>

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> This proof is rather short, but hints at a strong connection between graphs and combinatorics. The main idea behind the proof is to recognize that there are two choices for a given node
to be placed into a set. Call the two sets a node can be placed into \(A\) and \(B\). We’ll start by counting the total ways to assign nodes to either set. Invoking the product rule \(n\) times, with two choices per invocation:
</p>

<p>
\[ \underbrace {2 \cdot 2 \cdot \dots \cdot 2}_\text {$n$ choices} = 2^n \]
</p>

<p>
However, the definition of a cut forbids either set from being empty. To make up for this, we need to subtract the invalid cases from the total. Since this problem only makes senses for graphs with at least two nodes, the only way a set can be empty is if we shove all the
nodes into one or the other. This can only be done two ways; either they all go into \(A\), leaving \(B\) empty, or the reverse. Therefore, the grand total comes out to:
</p>

<p>
\[ 2^n - 2 \]
</p>

<p>
<span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<!--
...... subsubsection Properties of a Graph Cut ......
-->
<h6 id="autosec-29">Properties of a Graph Cut</h6>
<a id="index-autopage-29"></a>


<p>
Some basic properties of a graph cut serve an important role in proving graph algorithms to be correct. A notable example is Prim’s algorithm, which relies on the <b>Cut Property</b> for its proof. Here’s three important properties and their proofs
</p>
<!--
...... paragraph Empty Cut ......
-->


<p>
<span class="paragraph" id="autosec-30">Empty Cut</span>
<a id="index-autopage-30"></a>

</p>

<p>
This lemma is an interesting way to rephrase what it means for a graph to be connected. Actually, the empty cut lemma is usually given as the contrapositive statement, that a graph is not connected if there is even a single cut where no edges are crossing. In other words,
if there is some partitioning of nodes such that the sets can’t reach other (since there are no crossing edges), then this means we’ve found (at least) two subgraphs that have no connection between them which is the definition of a disconnected graph. A picture greatly
clarifies the situation:
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><a id="index-autopage-31"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">1</span></span>. </span> <a id="lem:emptycut"></a> A graph \(G = (V, E)\) is disconnected if and only if there is some cut \(C\) in which there are no
crossing edges.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="index-autopage-32"></a>

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> Starting with the righthand side, if there are no edges crossing the cut, all we have to do is select a vertex from either of the sets and see that there’s no path from one to the other. But
if there are <em>any</em> two vertices that can’t reach one another in a graph, it’s disconnected by definition.
</p>

<p>
If \(G\) is disconnected, then there must be at least two groups of nodes that <em>are</em> connected. This holds even in the extreme case of a graph with no edges. Finding a cut with no crossing edges is a matter of identifying two of these disconnected groups and
placing them in opposite sets in the cut. Seen another way, since \(G\) is disconnected, it must have at least two connected components. We can compute those and create the necessary partition. Now for the formalities:
</p>

<p>
Suppose \(G\) is disconnected. Then there exist vertices \(u, v \in V\) such that there is no path from \(u\) to \(v\). Construct a graph cut as follows, in one of the sets in the partition, place all of those nodes reachable from \(u\). Let this set be called \(A\) and its
construction be given by
</p>

<p>
\[ A = \{u&apos; \in V \mid \exists \; \text {a path from $u$ to $u&apos;$ in $G$} \} \]
</p>

<p>
Similarly, construct the other set in the partition, \(B\) as those nodes that can be reached by \(v\)
</p>

<p>
\[ B = \{v&apos; \in V \mid \exists \; \text {a path from $v$ to $v&apos;$ in $G$} \} \]
</p>

<p>
These sets are disjoint, and there cannot be any edge from a vertex in \(A\) to one in \(B\). Therefore, we have exhibited a cut with no crossing edges and the forward direction is shown.
</p>

<p>
To see the reverse implication, assume that there exists a cut with no edges between the elements of either set forming the partition of nodes. Select an arbitrary node from either, say \(u, v\) and notice by construction there is no path from \(u\) to \(v\). But then by
definition there exist vertices in \(G\) such that no path exists between them, and so \(G\) cannot be connected. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<!--
...... paragraph Double-Crossing Lemma ......
-->


<p>
<span class="paragraph" id="autosec-33">Double-Crossing Lemma</span>
<a id="index-autopage-33"></a>

</p>

<p>
This lemma claims that if some edge in a cycle crosses a graph cut, then there must be at least two edges of that cycle crossing it. If this isn’t intuitive, another way to think about it is to imagine that some nodes involved in a cycle are in one set of the partition and the
rest are in the other. Since we have a cycle, we know we can start at one vertex and travel the edges until returning to the start. This means that each set has one ”way out” and one ”way in”. If this were not the case, then we wouldn’t be able to get back to the beginning
of the cycle, which would mean we didn’t actually have one to begin with!
</p>

<p>
This seemingly random bit of knowledge presents itself in a very elegant way in trying to prove the output of certain algorithms is a bona fide tree. A cycle is not allowed in a tree, and so if we can be certain that only one edge among all of the ones crossing the cut is ever
chosen, we eliminate any possibility of ever forming a cycle. This is similar to some arguments which systematically remove the edges of a cycle in a connected graph until none exists, just from the opposite perspective.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><a id="index-autopage-34"></a>
<span class="amsthmnameplain">Lemma</span><span class="amsthmnumberplain"> <span class="textup">2</span></span>. </span> <a id="lem:doublecross"></a> Suppose a cycle \(C \in E\) has an edge crossing the cut \((A, B)\). Then there must be at least
two edges of \(C\) crossing the cut.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="index-autopage-35"></a>

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> To prove the Double-Crossing Lemma, all we have to show is that it is not possible for a cycle which has an edge crossing a cut to have fewer than 2 such edges. To see this imagine if
there were only one edge, and attempt to navigate the cycle back to the starting point. Clearly it’s impossible, since there’s no way back to the beginning.
</p>

<p>
This reasoning is straightforward, and a more formal proof barely serves any purpose in providing additional clarity. Nevertheless:
</p>

<p>
Suppose \(C \in E\) has an edge crossing the cut labeled \((A, B)\) and further suppose by way of contradiction that \(C\) has fewer than 2 edges crossing the cut. By assumption, \(C\) has at least one edge, so it will suffice to consider the case in which \(C\) has
exactly one crossing edge.
</p>

<p>
Choose an arbitrary vertex, say \(u\), involved in \(C\). By definition, there is a path:
</p>

<p>
\[ u-e_1-v_1-e_2-\dots -v_{n-1}-e_{n-1}-u \]
</p>

<p>
such that \(e_1 \neq e_{n-1}\). Consider the edge \(e_j\) in \(C\) crossing the cut which has endpoints \(v_i, v_j \; i \neq j\). Then \(v_j\) is in the opposite set of \(u\). By definition of a cycle, there must be some path from \(v_j\) to \(u\). This is impossible,
since such an edge would need contain vertices \(v_k, v_l\) with \(v_k\) in the same set as \(v_j\) and \(v_l\) in the same set as \(u\), meaning it would have to cross the cut. This contradicts the claim that \(C\) had only single edge crossing the cut, and thus the
proof is complete. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<!--
...... subsection Depth-First Search ......
-->
<h5 id="autosec-36">Depth-First Search</h5>
<a id="index-autopage-36"></a>


<p>
Depth-first search is arguably the simpler of the two main traversal algorithms. The key idea is to explore a graph as ”deeply” as possible, following the trail of nodes as far as possible before backtracking out to the starting point. DFS ignores neighbors until after there
are no additional nodes to explore or after reaching an already visited node.
</p>

<figure id="autoid-1" class="algorithm ruled">

<div class="figurecaption">
<p>
Algorithm&nbsp;1:&nbsp;Depth-First Search
</p>
</div>
<ul class="list" style="list-style-type:none">

<li>
<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span>visited = \(\emptyset \)
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>procedure</b> <span class="textsc">DFS</span>(\(v\))
</p>

</li>
<li>

<p>
<span class="listmarker"></span>         <span style="width:12pt; display:inline-block;"></span>add \(v\) to visited
</p>

</li>
<li>

<p>
<span class="listmarker"></span>         <span style="width:12pt; display:inline-block;"></span><b>for</b> \(u \in V\) such that \((v, u) \in E\) <b>do</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>            <span style="width:24pt; display:inline-block;"></span><b>if</b> \(u \not \in \) visited <b>then</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>               <span style="width:36pt; display:inline-block;"></span>DFS(\(u\))
</p>

</li>
<li>

<p>
<span class="listmarker"></span>            <span style="width:24pt; display:inline-block;"></span><b>end</b> <b>if</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>         <span style="width:12pt; display:inline-block;"></span><b>end</b> <b>for</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>end</b> <b>procedure</b>
</p>
</li>
</ul>

</figure>
<!--
...... subsubsection Analysis ......
-->
<h6 id="autosec-37">Analysis</h6>
<a id="index-autopage-37"></a>


<p>
Depth-first search explores each reachable node from starting vertex \(v\) and traverses edge incident on \(v\). Additionally, the check for whether a node has been visited before (using a hash) runs in expected \(O(1)\) time.
</p>

<p>
Due to visiting every node, the runtime of DFS is \(O(|V| + |E|)\).
</p>
<!--
...... subsection Breadth-First Search ......
-->
<h5 id="autosec-38">Breadth-First Search</h5>
<a id="index-autopage-38"></a>


<p>
Breadth-first search (BFS) proceeds to process the ”levels” of a graph, proceeding only when every neighbor of the current node has been explored. Typical implementations enqueue the neighbors of a vertex in order to enforce a BFS discipline.
</p>

<figure id="autoid-2" class="algorithm ruled">

<div class="figurecaption">
<p>
Algorithm&nbsp;2:&nbsp;Breadth-First Search
</p>
</div>
<ul class="list" style="list-style-type:none">

<li>
<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span>\(Q = \{v\}\)
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span>visited = \(\emptyset \)
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>while</b> \(Q\) is not empty <b>do</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>        <span style="width:12pt; display:inline-block;"></span>\(u =\) dequeue(\(Q\))
</p>

</li>
<li>

<p>
<span class="listmarker"></span>        <span style="width:12pt; display:inline-block;"></span><b>for</b> \(w \in V\) such that \((u, w) \in E\) <b>do</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>           <span style="width:24pt; display:inline-block;"></span><b>if</b> \(w \not \in \) visited <b>then</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>              <span style="width:36pt; display:inline-block;"></span>add \(w\) to visited
</p>

</li>
<li>

<p>
<span class="listmarker"></span>              <span style="width:36pt; display:inline-block;"></span>enqueue(\(Q, w\))
</p>

</li>
<li>

<p>
<span class="listmarker"></span>           <span style="width:24pt; display:inline-block;"></span><b>end</b> <b>if</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>        <span style="width:12pt; display:inline-block;"></span><b>end</b> <b>for</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>end</b> <b>while</b>
</p>
</li>
</ul>

</figure>
<!--
...... subsubsection Analysis ......
-->
<h6 id="autosec-39">Analysis</h6>
<a id="index-autopage-39"></a>


<p>
Similar to DFS, the runtime of BFS is \(O(|V| + |E|)\) assuming an implementation of a queue which allows constant time add and remove operations.
</p>
<!--
...... subsection Topological Ordering ......
-->
<h5 id="autosec-40">Topological Ordering</h5>
<a id="index-autopage-40"></a>


<p>
A Topological ordering in a directed graph is the order in which DFS explores vertices (formally called reverse post-order). The topological sort algorithm computes a valid topological ordering of a directed graph \(G\), if one exists.
</p>

<p>
Such orderings are typically used to determine whether a precedence graph is logically consistent, and if so, compute a correct sequence of operations.
</p>

<figure id="autoid-3" class="algorithm ruled">

<div class="figurecaption">
<p>
Algorithm&nbsp;3:&nbsp;TopoSort
</p>
</div>
<ul class="list" style="list-style-type:none">

<li>
<p>
<span class="listmarker"><b>Require:</b></span> \(G\) is a directed acyclic graph
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span>visited = \(\emptyset \)
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span>processing = \(\emptyset \)
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span>ordering = Stack
</p>

</li>
<li>

<p>
<span class="listmarker"></span>
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>procedure</b> <span class="textsc">DFS</span>(\(v\))
</p>

</li>
<li>

<p>
<span class="listmarker"></span>         <span style="width:12pt; display:inline-block;"></span>mark \(v\) as visited
</p>

</li>
<li>

<p>
<span class="listmarker"></span>         <span style="width:12pt; display:inline-block;"></span>processing(v) = True
</p>

</li>
<li>

<p>
<span class="listmarker"></span>         <span style="width:12pt; display:inline-block;"></span><b>for</b> \(u\) such that \((v, u) \in E\) <b>do</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>            <span style="width:24pt; display:inline-block;"></span><b>if</b> \(u \not \in visited\) <b>then</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>               <span style="width:36pt; display:inline-block;"></span>DFS(\(u\))
</p>

</li>
<li>

<p>
<span class="listmarker"></span>            <span style="width:24pt; display:inline-block;"></span><b>else</b> <b>if</b> \(u\) is a node currently being processed <b>then</b> <b>return</b> ”no topological ordering”
</p>

</li>
<li>

<p>
<span class="listmarker"></span>            <span style="width:24pt; display:inline-block;"></span><b>end</b> <b>if</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>         <span style="width:12pt; display:inline-block;"></span><b>end</b> <b>for</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>         <span style="width:12pt; display:inline-block;"></span>processing(v) = False
</p>

</li>
<li>

<p>
<span class="listmarker"></span>         <span style="width:12pt; display:inline-block;"></span>ordering.push(v)
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>end</b> <b>procedure</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>for</b> \(v \in V\) <b>do</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>         <span style="width:12pt; display:inline-block;"></span><b>if</b> \(v \not \in visited\) <b>then</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>            <span style="width:24pt; display:inline-block;"></span>DFS(\(v\))
</p>

</li>
<li>

<p>
<span class="listmarker"></span>         <span style="width:12pt; display:inline-block;"></span><b>end</b> <b>if</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>end</b> <b>for</b><b>return</b> ordering
</p>
</li>
</ul>

</figure>
<!--
...... subsection Strongly Connected Components ......
-->
<h5 id="autosec-41">Strongly Connected Components</h5>
<a id="index-autopage-41"></a>


<p>
We define ”strongly-connected” as a relation between two vertices \(u, v \in V\) such that \((u, v) \in R\) if there exists a path from \(u\) to \(v\) and a path from \(v\) to \(u\). Strongly connected components represent an equivalence class of the vertices of that
component.
</p>

<p>
Kosaraju’s algorithm computes the strongly connected components of \(G = (V, E)\) via two passes. The first past computes a ”topological ordering” of the reverse of \(G\), \(G_{\text {rev}}\), which provides the ordering necessary to provide to an additional pass of
DFS.
</p>

<p>
> Note that there cannot be a valid topological ordering in the strictest sense due to the fact that there must be a cycle in a directed graph in order for two vertices to be strongly connected.
</p>

<figure id="autoid-4" class="algorithm ruled">

<div class="figurecaption">
<p>
Algorithm&nbsp;4:&nbsp;Kosaraju-Sharir
</p>
</div>
<ul class="list" style="list-style-type:none">

<li>
<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span>scc = \(\emptyset \)
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span>count = 0
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span>visited = \(\emptyset \)
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span>ordering = <span class="textsc">TopoSort</span>(\(G_{\text {rev}}\))
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>function</b> <span class="textsc">DFS-SCC</span>(\(G, v\))
</p>

</li>
<li>

<p>
<span class="listmarker"></span>         <span style="width:12pt; display:inline-block;"></span>mark \(v\) as visited
</p>

</li>
<li>

<p>
<span class="listmarker"></span>         <span style="width:12pt; display:inline-block;"></span>scc(\(v\)) = count
</p>

</li>
<li>

<p>
<span class="listmarker"></span>         <span style="width:12pt; display:inline-block;"></span><b>for</b> \(u \in V\) such that \((v, u) \in E\) <b>do</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>            <span style="width:24pt; display:inline-block;"></span><b>if</b> \(u \not \in \) visited <b>then</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>               <span style="width:36pt; display:inline-block;"></span>DFS-SCC(\(G, u\))
</p>

</li>
<li>

<p>
<span class="listmarker"></span>            <span style="width:24pt; display:inline-block;"></span><b>end</b> <b>if</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>         <span style="width:12pt; display:inline-block;"></span><b>end</b> <b>for</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>end</b> <b>function</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>for</b> \(v\) in ordering <b>do</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span>         <span style="width:12pt; display:inline-block;"></span>DFS-SCC(\(G, v\))
</p>

</li>
<li>

<p>
<span class="listmarker"></span>         <span style="width:12pt; display:inline-block;"></span>count = count + 1
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span><b>end</b> <b>for</b>
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <span style="width:0pt; display:inline-block;"></span>
</p>

</li>
<li>

<p>
<span class="listmarker"></span> <b>return</b> scc
</p>
</li>
</ul>

</figure>

</section>

</main>

</div>

<footer>

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

</footer>


<nav class="botnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>

</body>
</html>
