
<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Anthony" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="Personal notes on Mathematics and Computer Science" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Notes on Everything — Foundations</title>
<link rel="stylesheet" type="text/css" href="lwarp.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
  subequations: "0",
  section: "",
  loader: {
    load: ['[tex]/tagformat', '[tex]/textmacros'],
  },
  startup: {
    ready() {
      // These would be replaced by import commands if you wanted to make
      // a proper extension.
      const Configuration = MathJax._.input.tex.Configuration.Configuration;
      const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
      const Macro = MathJax._.input.tex.Symbol.Macro;
      const TexError = MathJax._.input.tex.TexError.default;
      const ParseUtil = MathJax._.input.tex.ParseUtil.default;
      const expandable = MathJax._.util.Options.expandable;

       // Insert the replacement string into the TeX string, and check
       // that there haven't been too many maxro substitutions (prevents
       // infinite loops).
       const useArgument = (parser, text) => {
         parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
         parser.i = 0;
         if (++parser.macroCount > parser.configuration.options.maxMacros) {
           throw new TexError('MaxMacroSub1',
           'MathJax maximum macro substitution count exceeded; ' +
           'is there a recursive macro call?');
         }
       }

       // Create the command map for:
       //     \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
       new CommandMap('Lwarp-macros', {
         ifstar: 'IfstarFunction',
         ifnextchar: 'IfnextcharFunction',
         ifblank: 'IfblankFunction',
         ifstrequal: 'IfstrequalFunction',
         gsubstitute: 'GsubstituteFunction',
         seteqnumber: 'SeteqnumberFunction'
       }, {
         // This function implements an ifstar macro.
         IfstarFunction(parser, name) {
            const resultstar = parser.GetArgument(name);
            const resultnostar = parser.GetArgument(name);
            const star = parser.GetStar();                 // true if there is a *
            useArgument(parser, star ? resultstar : resultnostar);
         },

          // This function implements an ifnextchar macro.
          IfnextcharFunction(parser, name) {
            let whichchar = parser.GetArgument(name);
            if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
              // $ syntax highlighting
              whichchar = String.fromCodePoint(parseInt(whichchar));
            }
            const resultnextchar = parser.GetArgument(name);
            const resultnotnextchar = parser.GetArgument(name);
            const gotchar = (parser.GetNext() === whichchar);
            useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
          },

          // This function implements an ifblank macro.
          IfblankFunction(parser, name) {
            const blankarg = parser.GetArgument(name);
            const resultblank = parser.GetArgument(name);
            const resultnotblank = parser.GetArgument(name);
            const isblank = (blankarg.trim() == "");
            useArgument(parser, isblank ? resultblank : resultnotblank);
          },

          // This function implements an ifstrequal macro.
          IfstrequalFunction(parser, name) {
            const strequalfirst = parser.GetArgument(name);
            const strequalsecond = parser.GetArgument(name);
            const resultequal = parser.GetArgument(name);
            const resultnotequal = parser.GetArgument(name);
            const isequal = (strequalfirst == strequalsecond);
            useArgument(parser, isequal ? resultequal : resultnotequal);
          },

          // This function implements a gsub macro.
          GsubstituteFunction(parser, name) {
            const gsubfirst = parser.GetArgument(name);
            const gsubsecond = parser.GetArgument(name);
            const gsubthird = parser.GetArgument(name);
            let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
            useArgument(parser, gsubresult);
          },

          // This function modifies the equation numbers.
          SeteqnumberFunction(parser, name) {
              // Get the macro parameters
              const star = parser.GetStar();                  // true if there is a *
              const optBrackets = parser.GetBrackets(name);   // contents of optional brackets
              const newsubequations = parser.GetArgument(name); // the subequations argument
              const neweqsection = parser.GetArgument(name); // the eq section argument
              const neweqnumber = parser.GetArgument(name);   // the eq number argument
              MathJax.config.subequations=newsubequations ;   // a string with boolean meaning
              MathJax.config.section=neweqsection ;           // a string with numeric meaning
              parser.tags.counter = parser.tags.allCounter = neweqnumber ;
          }

       });

       // Create the Lwarp-macros package
       Configuration.create('Lwarp-macros', {
         handler: {macro: ['Lwarp-macros']}
       });

       MathJax.startup.defaultReady();

       // For forward references:
       MathJax.startup.input[0].preFilters.add(({math}) => {
         if (math.inputData.recompile){
             MathJax.config.subequations = math.inputData.recompile.subequations;
             MathJax.config.section = math.inputData.recompile.section;
         }
       });
       MathJax.startup.input[0].postFilters.add(({math}) => {
         if (math.inputData.recompile){
             math.inputData.recompile.subequations = MathJax.config.subequations;
             math.inputData.recompile.section = MathJax.config.section;
         }
       });

         // For \left, \right with unicode-math:
         const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
         const {Symbol} = MathJax._.input.tex.Symbol;
         const {MapHandler} = MathJax._.input.tex.MapHandler;
         const delimiter = MapHandler.getMap('delimiter');
         delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
         delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
         delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
         delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
         delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
         delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
         delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
         delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
         delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
         delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
         delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
         delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
         delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
         delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
         delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
         delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
         delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
         delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
         delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
         delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
         delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
         delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
         delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
         delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
         delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
         delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
         delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
         delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
         delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
         delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
         delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
         delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
         delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
         delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
         delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
         delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
         delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
         delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
         delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
   }     // ready
 },      // startup

 tex: {
   packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
   tags: "ams",
        tagformat: {
            number: function (n) {
                if(MathJax.config.subequations==0)
                    return(MathJax.config.section + n);
                else
                    return(MathJax.config.section + String.fromCharCode(96+n));
            },
        },
 }
}
</script>

<script
    id="MathJax-script"
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="index-autopage-116"></a>
<nav class="topnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Notes on Everything</span>
</p>

<p>
Subjects
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="Sums.html#autosec-6" class="tocchapter" >
Sums</a>
</p>


<p>
<a href="Sums.html#autosec-7" class="tocsection" >
Manipulating Sums</a>
</p>


<p>
<a href="Sums.html#autosec-8" class="tocsubsection" >
Basic Rules</a>
</p>


<p>
<a href="Sums.html#autosec-10" class="tocsubsection" >
Iverson Notation</a>
</p>


<p>
<a href="Sums.html#autosec-13" class="tocsubsection" >
Perturbing the Sum</a>
</p>


<p>
<a href="Sums.html#autosec-16" class="tocsubsection" >
Multiple Sums</a>
</p>


<p>
<a href="Finite-Calculus.html#autosec-24" class="tocsection" >
Finite Calculus</a>
</p>


<p>
<a href="Finite-Calculus.html#autosec-25" class="tocsubsection" >
The Difference Operator</a>
</p>


<p>
<a href="Finite-Calculus.html#autosec-26" class="tocsubsection" >
Rising and Falling Factorials</a>
</p>


<p>
<a href="Algorithms.html#autosec-30" class="tocchapter" >
Algorithms</a>
</p>


<p>
<a href="Algorithms.html#autosec-31" class="tocsection" >
Graphs</a>
</p>


<p>
<a href="Algorithms.html#autosec-32" class="tocsubsection" >
Cuts</a>
</p>


<p>
<a href="Algorithms.html#autosec-42" class="tocsubsection" >
Depth-First Search</a>
</p>


<p>
<a href="Algorithms.html#autosec-44" class="tocsubsection" >
Breadth-First Search</a>
</p>


<p>
<a href="Algorithms.html#autosec-46" class="tocsubsection" >
Topological Ordering</a>
</p>


<p>
<a href="Algorithms.html#autosec-47" class="tocsubsection" >
Strongly Connected Components</a>
</p>


<p>
<a href="Greedy.html#autosec-49" class="tocsection" >
Greedy</a>
</p>


<p>
<a href="Greedy.html#autosec-50" class="tocsubsection" >
Dijkstra’s Shortest Path Algorithm</a>
</p>


<p>
<a href="Greedy.html#autosec-61" class="tocsubsection" >
Prim’s MST Algorithm</a>
</p>


<p>
<a href="Greedy.html#autosec-67" class="tocsubsection" >
Kruskal’s MST Algorithm</a>
</p>


<p>
<a href="Greedy.html#autosec-74" class="tocsubsection" >
Huffman Codes</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-81" class="tocsection" >
Divide and Conquer</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-82" class="tocsubsection" >
Master Theorem</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-84" class="tocsubsection" >
MergeSort</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-86" class="tocsubsection" >
Counting Array Inversions</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-89" class="tocsubsection" >
Karatsuba Multiplication</a>
</p>


<p>
<a href="Combinatorics.html#autosec-91" class="tocchapter" >
Combinatorics</a>
</p>


<p>
<a href="Combinatorics.html#autosec-92" class="tocsection" >
Basics of Counting</a>
</p>


<p>
<a href="Combinatorics.html#autosec-93" class="tocsubsection" >
Product Rule</a>
</p>


<p>
<a href="Combinatorics.html#autosec-96" class="tocsubsection" >
Complement Rule</a>
</p>


<p>
<a href="Combinatorics.html#autosec-100" class="tocsubsection" >
Inclusion/Exclusion</a>
</p>


<p>
<a href="Combinatorics.html#autosec-103" class="tocsubsection" >
Permutations</a>
</p>


<p>
<a href="Probability.html#autosec-106" class="tocchapter" >
Probability</a>
</p>


<p>
<a href="Probability.html#autosec-107" class="tocsection" >
Basics</a>
</p>


<p>
<a href="Probability.html#autosec-108" class="tocsubsection" >
Terminology</a>
</p>


<p>
<a href="Probability.html#autosec-110" class="tocsubsection" >
Naive Definition of Probability</a>
</p>


<p>
<a href="Probability.html#autosec-112" class="tocsubsection" >
Non-Naive Definition of Probability</a>
</p>


<p>
<a href="Foundations.html#autosec-117" class="tocchapter" >
Foundations</a>
</p>


<p>
<a href="Foundations.html#autosec-118" class="tocsection" >
Set Theory</a>
</p>


<p>
<a href="Foundations.html#autosec-122" class="tocsubsection" >
Basic Definitions</a>
</p>


<p>
<a href="Foundations.html#autosec-123" class="tocsubsection" >
Laws</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-149" class="tocsection" >
Factoring Tricks</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-150" class="tocsubsection" >
Basic Identities</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-151" class="tocsubsection" >
Splitting Apart a Monomial</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-152" class="tocsubsection" >
Adding Zero</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-153" class="tocsubsection" >
\((a^n - b^n) \)</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-155" class="tocsubsection" >
\((a^n + b^n) \)</a>
</p>


<p>
<a href="Quadratics.html#autosec-159" class="tocsection" >
Quadratics</a>
</p>


<p>
<a href="Quadratics.html#autosec-160" class="tocsubsection" >
Finding Roots of a Quadratic Function</a>
</p>


<p>
<a href="Quadratics.html#autosec-166" class="tocsubsection" >
Vieta’s Theorem</a>
</p>


<p>
<a href="Quadratics.html#autosec-169" class="tocsubsection" >
The Quadratic Formula</a>
</p>


</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<h1>Notes on Everything</h1>

<!--MathJax customizations:-->
<div data-nosnippet
    style="display:none"
>

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

</div>

<!--
...... chapter Foundations ......
-->
<h3 id="autosec-117">Foundations</h3>
<a id="index-autopage-117"></a>
<a id="index-autofile-8"></a>

<p>
This section explains a lot of what highschool teachers ought to have during math class. Oh well.
</p>
<!--
...... section Set Theory ......
-->
<h4 id="autosec-118">Set Theory</h4>
<a id="index-autopage-118"></a>


<p>
Sets represent unordered, arbitrary collections. Most of modern mathematics is founded on the basics of set theory, and they show up in any serious treatment of a mathematical subject. These notes contain some simple proofs about sets. I hope I have provided an
unbearable amount of detail in the explanations.
</p>

<p>
Despite usually being among the first proofs students learn, some of the longer set proofs can be somewhat tricky, and involve multiple proof techniques.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><a id="index-autopage-119"></a>
<span class="amsthmnameplain">Definition</span><span class="amsthmnumberplain"> <span class="textup">6</span></span>. </span> These two axioms form the basis for nearly all set identities and proofs.
</p>

<ul class="enumerate" style="list-style-type:none">


<li>
<p>
<span class="listmarker">1.</span> There exists a set with no elements called the null set (\(\emptyset \))
</p>


</li>
<li>


<p>
<span class="listmarker">2.</span> If every element \(x \in X\) is also in \(Y\) and vice-versa, then \(X = Y\)
</p>
</li>
</ul>

</li>

</ul>

</div>

<p>
A clever proof by contradiction establishes the fact that \(\emptyset \) is unique (in other words, there is exactly one \(\emptyset \)). The main idea behind this proof is to use axiom two in order to prove that any two sets with no elements are actually subsets of one
another and by definition the same set.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><a id="index-autopage-120"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">6</span></span>. </span> There is exactly one empty set.
</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="index-autopage-121"></a>

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> Suppose not, there there are at least two sets, \(\emptyset _1\) and \(\emptyset _2\) such that \(\emptyset _1 \neq \emptyset _2\). By definition of empty, there is no element
\(x\) in either of the sets. However, this means that exactly the same elements are in \(\emptyset _1\) and \(\emptyset _2\), and axiom 2 establishes they must be equal. Therefore we have arrived at a contradiction, and so there can only be a single, unique empty set.
<span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<!--
...... subsection Basic Definitions ......
-->
<h5 id="autosec-122">Basic Definitions</h5>
<a id="index-autopage-122"></a>


<p>
The following set operations are ubiquitous in set proofs.
</p>

<span class="hidden"> \(\seteqnumber{0}{}{2}\)</span>


<!--


                                                                    X = {x | x 6∈ X}                                                                              Complement


                                                                X − Y = {x | x ∈ X, x 6∈ Y }                                                                        Difference


                                                                 P(A) = {A0 | A0 ⊆ A}                                                                               Power Set


                                                                X × Y = {(x, y) | x ∈ X, y ∈ Y }                                                             Cartesian Product


-->


<p>

\begin{align*}
\overline {X} &amp;= \{ x \mid x \not \in X \} &amp;\text {Complement} \\\\ X - Y &amp;= \{ x \mid x \in X, x \not \in Y \} &amp;\text {Difference} \\\\ \mathcal {P}(A) &amp;= \{ A&apos; \mid A&apos; \subseteq A \} &amp;\text {Power Set}
\\\\ X \times Y &amp;= \{ (x, y) \mid x \in X, y \in Y \} &amp;\text {Cartesian Product}
\end{align*}

</p>
<!--
...... subsection Laws ......
-->
<h5 id="autosec-123">Laws</h5>
<a id="index-autopage-123"></a>


<p>
Set laws are identities proven by thinking through the membership of arbitrary elements in a set and applying some basic logical operators. These come up all the time, so it’s worth having a small list jotted down somewhere.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><a id="index-autopage-124"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">7</span></span>. </span> The set union operator \(\cup \) is associative, that is
</p>

<p>
\[ A \cup (B \cup C) = (A \cup B) \cup C \]
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="index-autopage-125"></a>

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> Suppose \(x \in A \cup (B \cup C)\). Then by definition of set union, \(x\) is either in \(A\) or \(B \cup C\) (or both). Breaking down these cases:
</p>

<p>
If \(x \in A\). Then \(x\) is in \(A \cup B\), and so it is in the right-hand side.
</p>

<p>
Alternatively, if \(x \in (B \cup C\), this breaks down into another two cases, \(x \in B\) or \(x \in C\). If \(x \in C\), then it’s automatically in the union of \(C\) and anything else, and if \(x \in B\), then \(x \in (A \cup B)\) and so must be in \((A \cup B)
\cup C\).
</p>

<p>
Since we’ve proven the two expressions are subsets of one another, they must be the same set by axiom two, and the proof is complete. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><a id="index-autopage-126"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">8</span></span>. </span>
</p>

<p>
\[ A \cap B \subseteq B \]
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="index-autopage-127"></a>

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> Intuitively, this is saying that if an element is in \(A\) <em>and</em> \(B\), then it must be in \(B\). This is just the definition of set intersection. Formally:
</p>

<p>
Suppose \(x \in A \cap B\), then \(x \in A\) and \(x \in B\). But then \(x\) must be an element in \(B\) by definition. Because \(x\) was arbitrarily chosen, every element in \(A \cap B\) must be in \(B\), and therefore the definition of subset is satisfied. <span
class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><a id="index-autopage-128"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">9</span></span>. </span> The union operation is distributive over a set expression.
</p>

<p>
\[ X \cup (Y \cap Z) = (X \cup Y) \cap (X \cup Z) \]
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="index-autopage-129"></a>

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> Starting with the right-hand side, we see that \(X\) is involved in two unions, meaning that every element in \(X\) automatically shows up in the intersection. This is consistent with the
left-hand side, since an element being in \(X\) can be thought of as ”short-circuting” the union expression; we don’t even need to consider the other operations to know an element is present in whatever comes next.
</p>

<p>
On the other hand, if an element is not in \(X\), then it had better be in both \(Y\) <em>and</em> \(Z\). This is similar to the rules of logic, in which a known false combined with a proposition reduces to just the proposition. In other words, since we know the element is
not in \(X\), we can imagine the form on the right as:
</p>

<span class="hidden"> \(\seteqnumber{0}{}{2}\)</span>


<!--



                                                                                                                      (x ∈ X ∨ x ∈ Y ) ∧ (x ∈ X ∨ x ∈ Z)
                                                                                                                        ⇐⇒ (F ∨ x ∈ Y ) ∧ (F ∨ x ∈ Z)
                                                                                                                        ⇐⇒ (x ∈ Y ) ∧ (x ∈ Z)



-->


<p>


\begin{align*}
&amp;(x \in X \lor x \in Y) \land (x \in X \lor x \in Z) \\ &amp;\iff (F \lor x \in Y) \land (F \lor x \in Z) \\ &amp;\iff (x \in Y) \land (x \in Z)
\end{align*}


</p>

<p>
which is precisely what the left-hand side is saying. More formally:
</p>

<p>
Suppose \(x \in X\). Then \(x \in (X \cup Y)\) and \(x \in (X \cup Z)\) by union of two sets, and so \(x\) is in the right-hand expression. By similar argument, if \(x \in (Y \cap Z)\), then \(x \in (X \cup Y)\) and \(x \in (X \cup Z)\), and so the forward
direction holds.
</p>

<p>
Now suppose \(x \in (X \cup Y) \cap (X \cup Z)\). Then \(x \in X\) or \(x\) is in both \(Y\) and \(Z\) by definition of set union. But then \(x \in X \cup (Y \cap Z)\) and since both expressions are subsets of one another, the identity holds. <span
class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><a id="index-autopage-130"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">10</span></span>. </span> A Cartesian Product distributes over a set union.
</p>

<p>
\[ A \times (B \cup C) = (A \times B) \cup (A \times C) \]
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="index-autopage-131"></a>

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> The main idea here is to think about all the ordered pairs that would end up on the left-hand side. Taking every element in \(A\) and forming a tuple with all the elements in either
\(B\) or \(C\), we get
</p>

<p>
\[ (a_1, b_1), (a_1, c_1), (a_2, b_1), \dots (a_n, b_m), (a_n, c_k) \]
</p>

<p>
but these are the same ordered pairs as if we had taken each product by itself and combined the results together:
</p>

<p>
\[ (a_1, b_1), (a_1, b_2), \dots (a_n, b_m) \cup (a_1, c_1) \dots (a_n, c_k) \]
</p>

<p>
For the actual proof, we consider an arbitrary ordered pair in each of the expressions and once again prove both sides are subsets of one another.
</p>

<p>
Take \((x, y) \in A \times (B \cup C)\), then by definition of set union and Cartesian product, \(x \in A\) and either \(y \in B\) or \(y \in C\).
</p>

<p>
Suppose \(y \in B\), then \((x, y) \in (A \times B)\) and so it is in the union on the right. Now let \(y \in C\), and see by similar argument it is also in the union. Now assume \((x, y) \in (A \times B) \cup (A \times C)\). Then once againt, \(x \in A\) and
\(y \in B\) or \(y \in C\). This completes the proof as in either case, \((x, y) \in A \times (B \cup C)\) and so the sets are equal. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><a id="index-autopage-132"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">11</span></span>. </span>
</p>

<p>
\[ A \setminus B \subseteq \overline {B} \]
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="index-autopage-133"></a>

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> Any element left over after \(A \setminus B\) couldn’t have been in \(B\) by the definition of set subtraction. In other words, every such element would have to be in \(\overline
{B}\), otherwise it wouldn’t have survived the operation. This yields a fairly straightforward proof.
</p>

<p>
Let \(x \in A \setminus B\). Then by definition of the set difference operator, \(x \in \overline {B}\) and so because \(x\) was arbitrarily chosen, the identity must hold for any element of \(A \setminus B\) and the subset relation is shown. <span
class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><a id="index-autopage-134"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">12</span></span>. </span>
</p>

<p>
\[ A \cap \overline {B} = A \setminus B \]
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="index-autopage-135"></a>

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> As in the previous proof, we know that any element that is left over after a set subtraction must have been in the first set <em>and</em> not the second. But this is verbatim what the
left side of the equation claims, so all that’s left to do is show the bi-directional relation once more.
</p>

<p>
Let \(x\) be an element in \(A \cap \overline {B}\). Then by definition, \(x \in A\) and \(x \not \in B\) which means that \(x \in \overline {B}\). Then by set difference, \(x\) must be in \(A \setminus B\).
</p>

<p>
Now assume \(x \in A \setminus B\). Once again, \(x \in A\) and \(x \not \in B\), and set equality is shown in both directions. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><a id="index-autopage-136"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">13</span></span>. </span>
</p>

<p>
\[ A \cup (A \cap B) = A \]
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="index-autopage-137"></a>

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> There are a couple of decent ways of thinking about this identity. The most straightforward way might be to say that this boils down to declaring all the elements in \(A\), do in fact,
belong to \(A\). This line of thought comes from the fact that any element in \(A \cap B\) must be in \(A\), and so the expression reduces to \(A \cup A\), which of course is \(A\) itself.
</p>

<p>
Another clever way of thinking about this is to consider the problem in terms of boolean logic, in which a similar identity is presented:
</p>

<p>
\[ A \cup (A \cap B) \iff T \lor (T \land P) \iff T \]
</p>

<p>
here, the value of \(P\) is irrelevant, because the \(T\) immediately renders the entire expression true regardless. Analogously, if we know \(x \in A\), then we don’t have to consider again whether \(x \in A\), since the intersection with \(B\) could only ever produce
elements that were in \(A\) anyway.
</p>

<p>
Let \(x \in A \cup (A \cap B)\). Then \(x \in A\) or \(x \in (A \cap B\). In either case, \(x \in A\). Now suppose \(x \in A\). It immediately follows that \(x\) is in the union by virtue of being in \(A\), and the proof is complete.
</p>

<p>
Something interesting about this theorem is that we could instead try to apply the previously shown distributive property as a first step:
</p>

<p>
\[ A \cup (A \cap B) = (A \cup A) \cap (A \cup B) = A \cap (A \cup B) \]
</p>

<p>
Since we’ve proven the original identity and that this one is equivalent, we get another identity (basically) for free! <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><a id="index-autopage-138"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">14</span></span>. </span> DeMorgan’s Law for Sets
</p>

<p>
\[ \overline {A \cup B} = \overline {A} \cap \overline {B} \]
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="index-autopage-139"></a>

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> Another direct analog to boolean logic. Essentially this works in exactly the same way as applying DeMorgan’s law to logical operators. In plain English, this can be described as simply
saying if an element is not in \(A\) or \(B\), it can’t be in \(A\) and it also can’t be in \(B\).
</p>

<p>
Let \(x \in \overline {A \cup B}\), then by definition of set complement, \(x\) is not in the union of \(A\) and \(B\), which means \(x \not \in A\) and \(x \not \in B\). This implies that \(x \in \overline {A}\) and \(x \in \overline {B}\) and is therefore in
the intersection of the two.
</p>

<p>
Conversely, if \(x \in \overline {A} \cap \overline {B}\), it is neither in \(A\) nor \(B\), so it does not exist in their union and must therefore be in the complement of the union, \(\overline {A \cup B}\), and the proof is complete. <span
class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><a id="index-autopage-140"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">15</span></span>. </span>
</p>

<p>
\[ (A \setminus B) \cap B = \emptyset \]
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="index-autopage-141"></a>

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> This theorem can be thought of as the logical negation of \(A \cup (A \cap B)\) if we treat the \(\emptyset \) as a contradiction (logically always false). This makes sense, since if we
delete all the elements found in \(B\) from \(A\), and afterwards ask the question how many elements are now in both \(B\) and \(A\), we will always find exactly zero (we just got rid of any!).
</p>

<p>
For ”fun” and variety, this proof can proceed by contradiction. It also makes subtle use of the very first proof in that once we show the left-hand side is empty, we have proven that is must be equal to the unique empty set, and so the proof of the converse statement can be
skipped straight away.
</p>

<p>
Suppose not, that there is some element \(x\) in \(A \setminus B \cap B\). Then it must be the case that \(x \in A \setminus B\) and \(x \in B\) by definition of intersection. However, if \(x \in A \setminus B\), then \(x\) cannot be in \(B\). This contradicts the
original assumption that there was some element in the set, and so there can be no such element. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><a id="index-autopage-142"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">16</span></span>. </span> This theorem is actually <b>false</b>, but sets up the next theorem nicely and demonstrates a disproof.
</p>

<p>
\[ (A \setminus B) \cup B = A \]
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="index-autopage-143"></a>

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Counterexample.</span></span> As the next theorem shows, this is only true of \(B\) is a subset of \(A\). This can be shown with a simple counterexample:
</p>

<p>
Let \(A = \{1\}, \; B = \{2\}\). Then \(A \setminus B = \{1\}\), but this set and \(B\) have a union of \(\{1, 2\} \neq A\).
</p>

<p>
The reason this fails when \(B\) is not a subset of \(A\) is because when the set difference occurs, only those elements in \(B\) are taken away from \(A\). If any elements of \(B\) are not in \(A\), they’ll be tacked on as ”extra” in the union.
</p>

<p>
The next theorem provides the corrected claim. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><a id="index-autopage-144"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">17</span></span>. </span>
</p>

<p>
\[ B \subseteq A \iff (A \setminus B) \cup B = A \]
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="index-autopage-145"></a>

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> In contrast to the previous false claim, the condition that \(B\) is a subset of \(A\) ensures that the elements we take away during the set difference are exactly the same as the ones
added back during the set union. This follows from the definition of subset, which says that <em>every</em> element in \(B\) must also be in \(A\). This guarantees the operations cancel each other out.
</p>

<p>
The first part of this proof shows the forward direction in the usual way, while the second proceeds by contradiction since it ties in nicely with the reasoning of the previous disproof.
</p>

<p>
To see the forward claim, let \(B \subseteq A\) and let \(x\) be an element in \((A \setminus B) \cup B\). By definition of union and set difference, either \(x \in A\) and \(x \not \in B\) or \(x \in B\). In the first case, \(x \in A\) shows the identity immediately.
Now assume \(x \in B\). Once again, we know \(x \in A\) by definition of subset and so the first part of the claim is proven.
</p>

<p>
Now assume \((A \setminus B) \cup B = A\) and assume for the sake of obtaining a contradiction that \(B\) is not a subset of \(A\). Then there is some element, say, \(y \in B\) that is not in \(A\). But then \(y \in (A \setminus B) \cup B\), contradicting the
assumption that this set was equal to \(A\). Therefore, \(B\) must be a subset of \(A\), and the claim holds in both directions. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><a id="index-autopage-146"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">18</span></span>. </span>
</p>

<p>
\[ A \cap (B \setminus (A \cap B)) = \emptyset \]
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="index-autopage-147"></a>

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> There’s a lot of notation here, but translating to English helps. This claims that there are no elements both in \(A\) and in \(B\) after taking away those in \(A\) and \(B\) from \(B\).
This gets us a little closer to what’s going on, but we can break the problem down slowly and focus on the ”inner” expression first.
</p>

<p>
\[ B \setminus (A \cap B) \]
</p>

<p>
This expression remove anything in both \(B\) and \(A\) from \(B\). Crucially, this means any trace of \(A\) vanishes from \(B\), and so we’re left with exactly no elements in common between the two sets by the time we take the intersection. Of course, this shows that
there can never be any element in this set!
</p>

<p>
Doing this proof directly isn’t terribly difficult, but it is pretty tedious given the slighty subtle cases. Instead, we can try to find a contradiction.
</p>

<p>
Suppose by way of contradiction there there is some element in the left-hand expression, call it \(x\). Then \(x \in A\) and \(x \in B \setminus (A \cap B)\). Because \(x \in B \setminus (A \cap B)\), it must also be in \(B\), and not in \(A \cap B\). However,
this contradicts the fact that \(x\) must be in both \(A\) and \(B\) in order to be present in the intersection. Therefore, we have shown there can be no such element, and the proof is finished. <span class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>

</div>

</section>

</main>

</div>

<footer>

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

</footer>


<nav class="botnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>

</body>
</html>
