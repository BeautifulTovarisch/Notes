
<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Anthony" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="Personal notes on Mathematics and Computer Science" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Notes on Everything — Sums</title>
<link rel="stylesheet" type="text/css" href="lwarp.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
  subequations: "0",
  section: "",
  loader: {
    load: ['[tex]/tagformat', '[tex]/textmacros'],
  },
  startup: {
    ready() {
      // These would be replaced by import commands if you wanted to make
      // a proper extension.
      const Configuration = MathJax._.input.tex.Configuration.Configuration;
      const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
      const Macro = MathJax._.input.tex.Symbol.Macro;
      const TexError = MathJax._.input.tex.TexError.default;
      const ParseUtil = MathJax._.input.tex.ParseUtil.default;
      const expandable = MathJax._.util.Options.expandable;

       // Insert the replacement string into the TeX string, and check
       // that there haven't been too many maxro substitutions (prevents
       // infinite loops).
       const useArgument = (parser, text) => {
         parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
         parser.i = 0;
         if (++parser.macroCount > parser.configuration.options.maxMacros) {
           throw new TexError('MaxMacroSub1',
           'MathJax maximum macro substitution count exceeded; ' +
           'is there a recursive macro call?');
         }
       }

       // Create the command map for:
       //     \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
       new CommandMap('Lwarp-macros', {
         ifstar: 'IfstarFunction',
         ifnextchar: 'IfnextcharFunction',
         ifblank: 'IfblankFunction',
         ifstrequal: 'IfstrequalFunction',
         gsubstitute: 'GsubstituteFunction',
         seteqnumber: 'SeteqnumberFunction'
       }, {
         // This function implements an ifstar macro.
         IfstarFunction(parser, name) {
            const resultstar = parser.GetArgument(name);
            const resultnostar = parser.GetArgument(name);
            const star = parser.GetStar();                 // true if there is a *
            useArgument(parser, star ? resultstar : resultnostar);
         },

          // This function implements an ifnextchar macro.
          IfnextcharFunction(parser, name) {
            let whichchar = parser.GetArgument(name);
            if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
              // $ syntax highlighting
              whichchar = String.fromCodePoint(parseInt(whichchar));
            }
            const resultnextchar = parser.GetArgument(name);
            const resultnotnextchar = parser.GetArgument(name);
            const gotchar = (parser.GetNext() === whichchar);
            useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
          },

          // This function implements an ifblank macro.
          IfblankFunction(parser, name) {
            const blankarg = parser.GetArgument(name);
            const resultblank = parser.GetArgument(name);
            const resultnotblank = parser.GetArgument(name);
            const isblank = (blankarg.trim() == "");
            useArgument(parser, isblank ? resultblank : resultnotblank);
          },

          // This function implements an ifstrequal macro.
          IfstrequalFunction(parser, name) {
            const strequalfirst = parser.GetArgument(name);
            const strequalsecond = parser.GetArgument(name);
            const resultequal = parser.GetArgument(name);
            const resultnotequal = parser.GetArgument(name);
            const isequal = (strequalfirst == strequalsecond);
            useArgument(parser, isequal ? resultequal : resultnotequal);
          },

          // This function implements a gsub macro.
          GsubstituteFunction(parser, name) {
            const gsubfirst = parser.GetArgument(name);
            const gsubsecond = parser.GetArgument(name);
            const gsubthird = parser.GetArgument(name);
            let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
            useArgument(parser, gsubresult);
          },

          // This function modifies the equation numbers.
          SeteqnumberFunction(parser, name) {
              // Get the macro parameters
              const star = parser.GetStar();                  // true if there is a *
              const optBrackets = parser.GetBrackets(name);   // contents of optional brackets
              const newsubequations = parser.GetArgument(name); // the subequations argument
              const neweqsection = parser.GetArgument(name); // the eq section argument
              const neweqnumber = parser.GetArgument(name);   // the eq number argument
              MathJax.config.subequations=newsubequations ;   // a string with boolean meaning
              MathJax.config.section=neweqsection ;           // a string with numeric meaning
              parser.tags.counter = parser.tags.allCounter = neweqnumber ;
          }

       });

       // Create the Lwarp-macros package
       Configuration.create('Lwarp-macros', {
         handler: {macro: ['Lwarp-macros']}
       });

       MathJax.startup.defaultReady();

       // For forward references:
       MathJax.startup.input[0].preFilters.add(({math}) => {
         if (math.inputData.recompile){
             MathJax.config.subequations = math.inputData.recompile.subequations;
             MathJax.config.section = math.inputData.recompile.section;
         }
       });
       MathJax.startup.input[0].postFilters.add(({math}) => {
         if (math.inputData.recompile){
             math.inputData.recompile.subequations = MathJax.config.subequations;
             math.inputData.recompile.section = MathJax.config.section;
         }
       });

         // For \left, \right with unicode-math:
         const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
         const {Symbol} = MathJax._.input.tex.Symbol;
         const {MapHandler} = MathJax._.input.tex.MapHandler;
         const delimiter = MapHandler.getMap('delimiter');
         delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
         delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
         delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
         delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
         delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
         delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
         delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
         delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
         delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
         delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
         delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
         delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
         delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
         delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
         delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
         delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
         delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
         delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
         delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
         delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
         delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
         delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
         delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
         delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
         delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
         delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
         delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
         delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
         delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
         delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
         delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
         delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
         delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
         delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
         delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
         delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
         delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
         delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
         delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
   }     // ready
 },      // startup

 tex: {
   packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
   tags: "ams",
        tagformat: {
            number: function (n) {
                if(MathJax.config.subequations==0)
                    return(MathJax.config.section + n);
                else
                    return(MathJax.config.section + String.fromCharCode(96+n));
            },
        },
 }
}
</script>

<script
    id="MathJax-script"
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="index-autopage-5"></a>
<nav class="topnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Notes on Everything</span>
</p>

<p>
Subjects
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="Sums.html#autosec-6" class="tocchapter" >
Sums</a>
</p>


<p>
<a href="Sums.html#autosec-7" class="tocsection" >
Manipulating Sums</a>
</p>


<p>
<a href="Sums.html#autosec-8" class="tocsubsection" >
Basic Rules</a>
</p>


<p>
<a href="Sums.html#autosec-10" class="tocsubsection" >
Iverson Notation</a>
</p>


<p>
<a href="Sums.html#autosec-13" class="tocsubsection" >
Perturbing the Sum</a>
</p>


<p>
<a href="Sums.html#autosec-16" class="tocsubsection" >
Multiple Sums</a>
</p>


<p>
<a href="Finite-Calculus.html#autosec-24" class="tocsection" >
Finite Calculus</a>
</p>


<p>
<a href="Finite-Calculus.html#autosec-25" class="tocsubsection" >
The Difference Operator</a>
</p>


<p>
<a href="Finite-Calculus.html#autosec-26" class="tocsubsection" >
Rising and Falling Factorials</a>
</p>


<p>
<a href="Algorithms.html#autosec-30" class="tocchapter" >
Algorithms</a>
</p>


<p>
<a href="Algorithms.html#autosec-31" class="tocsection" >
Graphs</a>
</p>


<p>
<a href="Algorithms.html#autosec-32" class="tocsubsection" >
Cuts</a>
</p>


<p>
<a href="Algorithms.html#autosec-42" class="tocsubsection" >
Depth-First Search</a>
</p>


<p>
<a href="Algorithms.html#autosec-44" class="tocsubsection" >
Breadth-First Search</a>
</p>


<p>
<a href="Algorithms.html#autosec-46" class="tocsubsection" >
Topological Ordering</a>
</p>


<p>
<a href="Algorithms.html#autosec-47" class="tocsubsection" >
Strongly Connected Components</a>
</p>


<p>
<a href="Greedy.html#autosec-49" class="tocsection" >
Greedy</a>
</p>


<p>
<a href="Greedy.html#autosec-50" class="tocsubsection" >
Dijkstra’s Shortest Path Algorithm</a>
</p>


<p>
<a href="Greedy.html#autosec-61" class="tocsubsection" >
Prim’s MST Algorithm</a>
</p>


<p>
<a href="Greedy.html#autosec-67" class="tocsubsection" >
Kruskal’s MST Algorithm</a>
</p>


<p>
<a href="Greedy.html#autosec-74" class="tocsubsection" >
Huffman Codes</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-81" class="tocsection" >
Divide and Conquer</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-82" class="tocsubsection" >
Master Theorem</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-84" class="tocsubsection" >
MergeSort</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-86" class="tocsubsection" >
Counting Array Inversions</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-89" class="tocsubsection" >
Karatsuba Multiplication</a>
</p>


<p>
<a href="Combinatorics.html#autosec-91" class="tocchapter" >
Combinatorics</a>
</p>


<p>
<a href="Combinatorics.html#autosec-92" class="tocsection" >
Basics of Counting</a>
</p>


<p>
<a href="Combinatorics.html#autosec-93" class="tocsubsection" >
Product Rule</a>
</p>


<p>
<a href="Combinatorics.html#autosec-96" class="tocsubsection" >
Complement Rule</a>
</p>


<p>
<a href="Combinatorics.html#autosec-100" class="tocsubsection" >
Inclusion/Exclusion</a>
</p>


<p>
<a href="Combinatorics.html#autosec-103" class="tocsubsection" >
Permutations</a>
</p>


<p>
<a href="Probability.html#autosec-106" class="tocchapter" >
Probability</a>
</p>


<p>
<a href="Probability.html#autosec-107" class="tocsection" >
Basics</a>
</p>


<p>
<a href="Probability.html#autosec-108" class="tocsubsection" >
Terminology</a>
</p>


<p>
<a href="Probability.html#autosec-110" class="tocsubsection" >
Naive Definition of Probability</a>
</p>


<p>
<a href="Probability.html#autosec-112" class="tocsubsection" >
Non-Naive Definition of Probability</a>
</p>


<p>
<a href="Foundations.html#autosec-117" class="tocchapter" >
Foundations</a>
</p>


<p>
<a href="Foundations.html#autosec-118" class="tocsection" >
Set Theory</a>
</p>


<p>
<a href="Foundations.html#autosec-122" class="tocsubsection" >
Basic Definitions</a>
</p>


<p>
<a href="Foundations.html#autosec-123" class="tocsubsection" >
Laws</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-149" class="tocsection" >
Factoring Tricks</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-150" class="tocsubsection" >
Basic Identities</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-151" class="tocsubsection" >
Splitting Apart a Monomial</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-152" class="tocsubsection" >
Adding Zero</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-153" class="tocsubsection" >
\((a^n - b^n) \)</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-155" class="tocsubsection" >
\((a^n + b^n) \)</a>
</p>


<p>
<a href="Quadratics.html#autosec-159" class="tocsection" >
Quadratics</a>
</p>


<p>
<a href="Quadratics.html#autosec-160" class="tocsubsection" >
Finding Roots of a Quadratic Function</a>
</p>


<p>
<a href="Quadratics.html#autosec-166" class="tocsubsection" >
Vieta’s Theorem</a>
</p>


<p>
<a href="Quadratics.html#autosec-169" class="tocsubsection" >
The Quadratic Formula</a>
</p>


</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<h1>Notes on Everything</h1>

<!--MathJax customizations:-->
<div data-nosnippet
    style="display:none"
>

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

</div>

<!--
...... chapter Sums ......
-->
<h3 id="autosec-6">Sums</h3>
<a id="index-autopage-6"></a>
<a id="index-autofile-1"></a>
<!--
...... section Manipulating Sums ......
-->
<h4 id="autosec-7">Manipulating Sums</h4>
<a id="index-autopage-7"></a>


<p>
Techniques for manipulating summations can often lead to a closed form solution or simpler summation. This is especially helpful when dealing with multiple summations and loops in which the inner index depends on the outer.
</p>
<!--
...... subsection Basic Rules ......
-->
<h5 id="autosec-8">Basic Rules</h5>
<a id="index-autopage-8"></a>


<p>
Often times a complex summation can be simplified using a few simple rules:
</p>

<span class="hidden"> \(\seteqnumber{0}{}{0}\)</span>


<!--


                                                                                                                                                                               Distribution
                                                                         X              X
                                                                              cak = c         ak
                                                                        k∈K             k∈K

                                                                                                                                                                               Association
                                                                         X                    X           X
                                                                              (ak + bk ) =         ak +         bk
                                                                        k∈K                  k∈K          k∈K

                                                                                                                                                                            Commutativity
                                                                         X                     X
                                                                              (ak + bk ) =              ap(k)
                                                                        k∈K                  p(k)∈K 0



-->


<p>

\begin{align*}
&amp;\sum _{k \in K} c a_k = c \sum _{k \in K} a_k &amp;\text {Distribution} \\ &amp;\sum _{k \in K} (a_k + b_k) = \sum _{k \in K} a_k + \sum _{k \in K} b_k &amp;\text {Association} \\ &amp;\sum _{k \in K} (a_k + b_k) = \sum _{p(k) \in
K&apos;} a_{p(k)} &amp;\text {Commutativity}
\end{align*}

</p>

<p>
where \(p(k)\) is a <em>permutation</em> of the elements of \(k\) to some set with image \(p(k)\)
</p>

<p>
For example, suppose \(K = \{-1, 0, 1\}\) and \(p(k) = -k\), then \(p : K \mapsto K&apos;\) where \(K&apos; = \{1, 0, -1\}\). The end result is the terms of \(K\) are rearranged, and by <b>commutativity</b>, the summation is equal to the original ordering.
</p>
<!--
...... subsubsection Example ......
-->
<h6 id="autosec-9">Example</h6>
<a id="index-autopage-9"></a>


<p>
Using the rules above, we can simplify the following summation:
</p>

<span class="hidden"> \(\seteqnumber{0}{}{0}\)</span>


<!--


                                                                                  X
                                                                            S=           (a + bk)
                                                                                 0⩽k⩽n

                                                                                                                                                              \(a\) is constant
                                                                                               X
                                                                               = a(n + 1) +            bk
                                                                                              0⩽k⩽n

                                                                                                                                                                \(k \to n-k\)
                                                                                                   X
                                                                               = a(n + 1) +                 bn − bk
                                                                                              0⩽n−k⩽n

                                                                                                                                                                \(n-k \to k\)
                                                                                               X
                                                                               = a(n + 1) +            bn − bk
                                                                                              0⩽k⩽n




-->


<p>

\begin{align*}
\label {eq:sum_manip_example} S &amp;= \sum _{0 \leqslant k \leqslant n} (a + bk) \\ &amp;= a(n+1) + \sum _{0 \leqslant k \leqslant n} bk &amp;\text {$a$ is constant} \\ &amp;= a(n+1) + \sum _{0 \leqslant n-k \leqslant n} bn - bk
&amp;\text {$k \to n-k$} \\ &amp;= a(n+1) + \sum _{0 \leqslant k \leqslant n} bn - bk &amp;\text {$n-k \to k$} \\
\end{align*}

</p>

<p>
We employ another technique of adding \(S\) to itself and solving a simplified expression
</p>

<span class="hidden"> \(\seteqnumber{0}{}{0}\)</span>


<!--


                                                                     X                                 X
                                                             2S =         (a + bk) + a(n + 1) +               bn − bk
                                                                    0⩽k⩽n                           0⩽k⩽n

                                                                                                                                                     combining summations and simplifying
                                                                                X
                                                                  = a(n + 1)           (an + bn)
                                                                               0⩽k⩽n

                                                                  = (n + 1)(2a + bn)                                                                                \(an\), \(bn\) constant


-->


<p>

\begin{align*}
2S &amp;= \sum _{0 \leqslant k \leqslant n} (a + bk) + a(n+1) + \sum _{0 \leqslant k \leqslant n} bn - bk \\ &amp;= a(n+1) \sum _{0 \leqslant k \leqslant n} (an + bn) &amp;\text {combining summations and simplifying} \\ &amp;= (n+1)(2a +
bn) &amp;\text {$an$, $bn$ constant}
\end{align*}

</p>

<p>
Finally, dividing by 2 we get \(S = (a + \frac 1 2 bn)(n+1)\)
</p>
<!--
...... subsection Iverson Notation ......
-->
<h5 id="autosec-10">Iverson Notation</h5>
<a id="index-autopage-10"></a>


<p>
In order to make manipulation of indexes easier, we can use notation invented by Kenneth E. Iverson as an indicator function:
</p>

<span class="hidden"> \(\seteqnumber{0}{}{0}\)</span>

<!--


                                                                        1 if \(P\) is true
                                                                    (
                                                           [P ] =                                                               --><a id="eqn:iverson"></a><!--
                                                                        0 otherwise

-->

<p>

\begin{equation*}
\label {eqn:iverson} [P] = \begin{cases} 1 &amp; \text {if $P$ is true} \\ 0 &amp; \text {otherwise} \end {cases}
\end{equation*}

</p>
<!--
...... subsubsection Properties ......
-->
<h6 id="autosec-11">Properties</h6>
<a id="index-autopage-11"></a>


<p>
Iverson brackets can be manipulated in the same way as set operations:
</p>

<span class="hidden"> \(\seteqnumber{0}{}{0}\)</span>


<!--


                                                                                                                 [P ∧ Q] = [P ][Q]


                                                                                                           [P ∨ Q] = [P ] + [Q] − [P ][Q]


                                                                                                                  [¬P ] = 1 − [P ]


                                                                                                   [k ∈ A] + [k ∈ B] = [k ∈ A ∪ B] + [k ∈ A ∩ B]


                                                                                                           [k ∈ A ∩ B] = [k ∈ A][k ∈ B]


-->


<p>

\begin{gather*}
[P \land Q] = [P][Q] \\\\ [P \lor Q] = [P] + [Q] - [P][Q] \\\\ [\lnot P] = 1 - [P] \\\\ [k \in A] + [k \in B] = [k \in A \cup B] + [k \in A \cap B] \\\\ [k \in A \cap B] = [k \in A][k \in B]
\end{gather*}

</p>
<!--
...... subsubsection Example ......
-->
<h6 id="autosec-12">Example</h6>
<a id="index-autopage-12"></a>


<p>
Using Iverson brackets, the ”double-counting” summation identity can be derived directly from the above properties.
</p>

<span class="hidden"> \(\seteqnumber{0}{}{0}\)</span>

<!--


                                                                                                             [k ∈ K] + [k ∈ K 0 ] = [k ∈ K ∩ K 0 ] + [k ∈ K ∪ K 0 ]

-->

<p>

\begin{equation*}
[k \in K] + [k \in K&apos;] = [k \in K \cap K&apos;] + [k \in K \cup K&apos;]
\end{equation*}

</p>

<p>
which translates to summations with indices:
</p>

<span class="hidden"> \(\seteqnumber{0}{}{0}\)</span>

<!--

                                                                                                                X            X               X                X
                                                                                                                      ak +           ak =             ak +             ak
                                                                                                                k∈K          k∈K 0          k∈k∩K 0          k∈k∪K 0

-->

<p>

\begin{equation*}
\sum _{k \in K} a_k + \sum _{k \in K&apos;} a_k = \sum _{k \in k \cap K&apos;} a_k + \sum _{k \in k \cup K&apos;} a_k
\end{equation*}

</p>
<!--
...... subsection Perturbing the Sum ......
-->
<h5 id="autosec-13">Perturbing the Sum</h5>
<a id="index-autopage-13"></a>


<p>
Another technique is to manipulate the first and last terms. This reveal a way to solve the summation via the above manipulations.
</p>
<!--
...... subsubsection Example ......
-->
<h6 id="autosec-14">Example</h6>
<a id="index-autopage-14"></a>


<p>
For example, take the following summation representing a geometric series. A good approach is to write \(S_{n+1}\) in terms of \(S_n\) and simplify the right side of the equation.
</p>

<p>
Consider the following summation:
</p>

<p>
\[ S_n = \sum _{0 \leqslant k \leqslant n} ax^k \]
</p>

<p>
Adding the \(n+1\)st term and solving for \(S_n\):
</p>

<span class="hidden"> \(\seteqnumber{0}{}{0}\)</span>


<!--


                                                                                                                                X
                                                                                                           Sn + axn+1 = a +             axk
                                                                                                                              1⩽k⩽n+1
                                                                                                                                                    X
                                                                                                                        ⇐⇒ Sn + axn+1 = a +                 axk+1
                                                                                                                                                1⩽k+1⩽n+1
                                                                                                                                                  X
                                                                                                                        ⇐⇒ Sn + axn+1 = a +             axk+1
                                                                                                                                                0⩽k⩽n

                                                                                                                        ⇐⇒ Sn + axn+1 = a + xSn
                                                                                                                                   a − axn+1
                                                                                                                        ⇐⇒ Sn =
                                                                                                                                     1−x


-->


<p>

\begin{align*}
S_n + ax^{n+1} &amp;= a + \sum _{1 \leqslant k \leqslant n+1} ax^k \\ &amp;\iff S_n + ax^{n+1} = a + \sum _{1 \leqslant k+1 \leqslant n+1} ax^{k+1} \\ &amp;\iff S_n + ax^{n+1} = a + \sum _{0 \leqslant k \leqslant n} ax^{k+1} \\ &amp;\iff
S_n + ax^{n+1} = a + xS_n \\ &amp;\iff S_n = \frac {a - ax^{n+1}} {1 - x}
\end{align*}

</p>
<!--
...... subsubsection Example ......
-->
<h6 id="autosec-15">Example</h6>
<a id="index-autopage-15"></a>


<p>
Taking another example and using the results from the previous derivation, the following sum is solved almost in the exact same way:
</p>

<p>
\[ S_n = \sum _{0 \leqslant k \leqslant n} k2^k \]
</p>

<p>
Once again perturbing the sum:
</p>

<span class="hidden"> \(\seteqnumber{0}{}{0}\)</span>


<!--


                                                                                                                                       X
                                                                                                         Sn + (n + 1)2n+1 = 0 +                k2k+1
                                                                                                                                  1⩽k⩽n+1


                                                                                                                                  X                       X
                                                                                                                           =                k2k+1 +                2k+1
                                                                                                                               1⩽k+1⩽n+1               1⩽k+1⩽n+1


                                                                                                                                        X
                                                                                                                           = 2Sn +             2k+1
                                                                                                                                       0⩽k⩽n



-->


<p>

\begin{align*}
S_n + (n+1)2^{n+1} &amp;= 0 + \sum _{1 \leqslant k \leqslant n+1} k2^{k+1} \\\\ &amp;= \sum _{1 \leqslant k+1 \leqslant n+1} k2^{k+1} + \sum _{1 \leqslant k+1 \leqslant n+1} 2^{k+1} \\\\ &amp;= 2S_n + \sum _{0 \leqslant k \leqslant n}
2^{k+1}
\end{align*}

</p>

<p>
The second sum is a geometric series, and so after evaluating and simplifying:
</p>

<p>
\[ S_n = \frac {2 - 2^{n+2}} {1 - 2} - (n+1)2^{n+1} = (n-1)2^{n+1} + 2 \]
</p>
<!--
...... subsection Multiple Sums ......
-->
<h5 id="autosec-16">Multiple Sums</h5>
<a id="index-autopage-16"></a>


<p>
When a summation is indexed by two or more indices, it can be written with more than one sigma:
</p>

<p>
\[ \sum _{1 \leqslant j, k \leqslant n} a_j b_k = \sum _{1 \leqslant j \leqslant n} \sum _{1 \leqslant k \leqslant n} b_k \]
</p>

<p>
Summations of this form are evaulated ”right-to-left” or by taking the ”inner” summtation first. In the above example, the summation over \(k\) happens first.
</p>
<!--
...... subsubsection Interchanging Indices ......
-->
<h6 id="autosec-17">Interchanging Indices</h6>
<a id="index-autopage-17"></a>


<p>
When indices are independent, this is simply a matter of rearranging the sums. Complications arise when the inner index depends on the outer. The abstract way of denoting an exchange of indicies:
</p>

<p>
\[ \sum _j \sum _k a_{j,k} [P(j, k)] = \sum _{P(j,k)} a_{j,k} [P(j,k)] = \sum _k \sum _j a_{j,k} [P(j,k)] \]
</p>

<p>
is a generalization of the associativity rule.
</p>
<!--
...... subsubsection Example ......
-->
<h6 id="autosec-18">Example</h6>
<a id="index-autopage-18"></a>


<p>
This example shows how multiple summations can be split apart by applying the associative rule and using Iverson notation.
</p>

<p>
Since the indices are independent, the summations can occur in either order.
</p>

<span class="hidden"> \(\seteqnumber{0}{}{0}\)</span>


<!--


                                                                                                              X                 X
                                                                                                                      aj bk =         aj bk [1 ⩽ j ⩽ 3][1 ⩽ k ⩽ 3]
                                                                                                            1⩽j,k⩽3             j,k
                                                                                                                                X                      X
                                                                                                                           =          aj [1 ⩽ j ⩽ 3]       bk [1 ⩽ k ⩽ 3]
                                                                                                                                 j                     k
                                                                                                                                3
                                                                                                                                X          3
                                                                                                                                           X
                                                                                                                           =          aj         bk
                                                                                                                                j=1        k=1



-->


<p>

\begin{align*}
\sum _{1 \leqslant j,k \leqslant 3} a_j b_k &amp;= \sum _{j,k} a_j b_k [1 \leqslant j \leqslant 3][1 \leqslant k \leqslant 3] \\ &amp;= \sum _j a_j [1 \leqslant j \leqslant 3] \sum _k b_k [1 \leqslant k \leqslant 3] \\ &amp;= \sum
_{j=1}^3 a_j \sum _{k=1}^3 b_k
\end{align*}

</p>
<!--
...... subsubsection Harder Example ......
-->
<h6 id="autosec-19">Harder Example</h6>
<a id="index-autopage-19"></a>


<p>
In this example, \(j\) is related to the value of \(k\). Again, the problem can be reduced into manipulating the inequalities using Iverson notation. Using the following identity written in Iverson brackets:
</p>

<p>
\[ [1 \leqslant j \leqslant n][j \leqslant k \leqslant n] = [1 \leqslant j,k \leqslant n] = [1 \leqslant k \leqslant n][1 \leqslant j \leqslant k] \]
</p>
<div class="center">

<p>
<span
    id="lateximage-index-1"
    class="lateximagesource"
><!--
1   j   k   n
--><img
    src="index-images/image-1.svg"
    alt="(-tikz-&nbsp;diagram)"
    style=""
    class="lateximage"
></span>
</p>
</div>

<p>
This holds by combining the first two brackets by writing their intersection as one inequality and by splitting it apart again.
</p>

<p>
An equivalent double summation can be manipulated using the above identity:
</p>

<span class="hidden"> \(\seteqnumber{0}{}{0}\)</span>


<!--


                                                                                                                         X        X              X
                                                                                                                                      aj,k =             aj,k
                                                                                                                        1⩽j⩽n j⩽k⩽n            1⩽j,k⩽n


                                                                                                                                                X        X
                                                                                                                                          =                     aj,k
                                                                                                                                               1⩽k⩽n 1⩽j⩽k



                                                                                                                                               n X
                                                                                                                                               X k
                                                                                                                                          =              aj,k
                                                                                                                                               k=1 j=1



-->


<p>

\begin{align*}
\sum _{1 \leqslant j \leqslant n} \sum _{j \leqslant k \leqslant n} a_{j,k} &amp;= \sum _{1 \leqslant j,k \leqslant n} a_{j,k} \\\\ &amp;= \sum _{1 \leqslant k \leqslant n} \sum _{1 \leqslant j \leqslant k} a_{j,k} \\\\ &amp;= \sum
_{k=1}^n \sum _{j=1}^k a_{j,k}
\end{align*}

</p>

<p>
Hopefully, the second summation turns out to be easier to evaluate.
</p>

</section>

</main>

</div>

<footer>

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

</footer>


<nav class="botnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>

</body>
</html>
