
<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Anthony" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="Personal notes on Mathematics and Computer Science" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Notes on Everything — Combinatorics</title>
<link rel="stylesheet" type="text/css" href="lwarp.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
  subequations: "0",
  section: "",
  loader: {
    load: ['[tex]/tagformat', '[tex]/textmacros'],
  },
  startup: {
    ready() {
      // These would be replaced by import commands if you wanted to make
      // a proper extension.
      const Configuration = MathJax._.input.tex.Configuration.Configuration;
      const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
      const Macro = MathJax._.input.tex.Symbol.Macro;
      const TexError = MathJax._.input.tex.TexError.default;
      const ParseUtil = MathJax._.input.tex.ParseUtil.default;
      const expandable = MathJax._.util.Options.expandable;

       // Insert the replacement string into the TeX string, and check
       // that there haven't been too many maxro substitutions (prevents
       // infinite loops).
       const useArgument = (parser, text) => {
         parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
         parser.i = 0;
         if (++parser.macroCount > parser.configuration.options.maxMacros) {
           throw new TexError('MaxMacroSub1',
           'MathJax maximum macro substitution count exceeded; ' +
           'is there a recursive macro call?');
         }
       }

       // Create the command map for:
       //     \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
       new CommandMap('Lwarp-macros', {
         ifstar: 'IfstarFunction',
         ifnextchar: 'IfnextcharFunction',
         ifblank: 'IfblankFunction',
         ifstrequal: 'IfstrequalFunction',
         gsubstitute: 'GsubstituteFunction',
         seteqnumber: 'SeteqnumberFunction'
       }, {
         // This function implements an ifstar macro.
         IfstarFunction(parser, name) {
            const resultstar = parser.GetArgument(name);
            const resultnostar = parser.GetArgument(name);
            const star = parser.GetStar();                 // true if there is a *
            useArgument(parser, star ? resultstar : resultnostar);
         },

          // This function implements an ifnextchar macro.
          IfnextcharFunction(parser, name) {
            let whichchar = parser.GetArgument(name);
            if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
              // $ syntax highlighting
              whichchar = String.fromCodePoint(parseInt(whichchar));
            }
            const resultnextchar = parser.GetArgument(name);
            const resultnotnextchar = parser.GetArgument(name);
            const gotchar = (parser.GetNext() === whichchar);
            useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
          },

          // This function implements an ifblank macro.
          IfblankFunction(parser, name) {
            const blankarg = parser.GetArgument(name);
            const resultblank = parser.GetArgument(name);
            const resultnotblank = parser.GetArgument(name);
            const isblank = (blankarg.trim() == "");
            useArgument(parser, isblank ? resultblank : resultnotblank);
          },

          // This function implements an ifstrequal macro.
          IfstrequalFunction(parser, name) {
            const strequalfirst = parser.GetArgument(name);
            const strequalsecond = parser.GetArgument(name);
            const resultequal = parser.GetArgument(name);
            const resultnotequal = parser.GetArgument(name);
            const isequal = (strequalfirst == strequalsecond);
            useArgument(parser, isequal ? resultequal : resultnotequal);
          },

          // This function implements a gsub macro.
          GsubstituteFunction(parser, name) {
            const gsubfirst = parser.GetArgument(name);
            const gsubsecond = parser.GetArgument(name);
            const gsubthird = parser.GetArgument(name);
            let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
            useArgument(parser, gsubresult);
          },

          // This function modifies the equation numbers.
          SeteqnumberFunction(parser, name) {
              // Get the macro parameters
              const star = parser.GetStar();                  // true if there is a *
              const optBrackets = parser.GetBrackets(name);   // contents of optional brackets
              const newsubequations = parser.GetArgument(name); // the subequations argument
              const neweqsection = parser.GetArgument(name); // the eq section argument
              const neweqnumber = parser.GetArgument(name);   // the eq number argument
              MathJax.config.subequations=newsubequations ;   // a string with boolean meaning
              MathJax.config.section=neweqsection ;           // a string with numeric meaning
              parser.tags.counter = parser.tags.allCounter = neweqnumber ;
          }

       });

       // Create the Lwarp-macros package
       Configuration.create('Lwarp-macros', {
         handler: {macro: ['Lwarp-macros']}
       });

       MathJax.startup.defaultReady();

       // For forward references:
       MathJax.startup.input[0].preFilters.add(({math}) => {
         if (math.inputData.recompile){
             MathJax.config.subequations = math.inputData.recompile.subequations;
             MathJax.config.section = math.inputData.recompile.section;
         }
       });
       MathJax.startup.input[0].postFilters.add(({math}) => {
         if (math.inputData.recompile){
             math.inputData.recompile.subequations = MathJax.config.subequations;
             math.inputData.recompile.section = MathJax.config.section;
         }
       });

         // For \left, \right with unicode-math:
         const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
         const {Symbol} = MathJax._.input.tex.Symbol;
         const {MapHandler} = MathJax._.input.tex.MapHandler;
         const delimiter = MapHandler.getMap('delimiter');
         delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
         delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
         delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
         delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
         delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
         delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
         delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
         delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
         delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
         delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
         delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
         delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
         delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
         delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
         delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
         delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
         delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
         delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
         delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
         delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
         delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
         delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
         delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
         delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
         delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
         delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
         delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
         delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
         delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
         delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
         delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
         delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
         delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
         delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
         delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
         delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
         delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
         delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
         delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
   }     // ready
 },      // startup

 tex: {
   packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
   tags: "ams",
        tagformat: {
            number: function (n) {
                if(MathJax.config.subequations==0)
                    return(MathJax.config.section + n);
                else
                    return(MathJax.config.section + String.fromCharCode(96+n));
            },
        },
 }
}
</script>

<script
    id="MathJax-script"
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="index-autopage-90"></a>
<nav class="topnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Notes on Everything</span>
</p>

<p>
Subjects
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="Sums.html#autosec-6" class="tocchapter" >
Sums</a>
</p>


<p>
<a href="Sums.html#autosec-7" class="tocsection" >
Manipulating Sums</a>
</p>


<p>
<a href="Sums.html#autosec-8" class="tocsubsection" >
Basic Rules</a>
</p>


<p>
<a href="Sums.html#autosec-10" class="tocsubsection" >
Iverson Notation</a>
</p>


<p>
<a href="Sums.html#autosec-13" class="tocsubsection" >
Perturbing the Sum</a>
</p>


<p>
<a href="Sums.html#autosec-16" class="tocsubsection" >
Multiple Sums</a>
</p>


<p>
<a href="Finite-Calculus.html#autosec-24" class="tocsection" >
Finite Calculus</a>
</p>


<p>
<a href="Finite-Calculus.html#autosec-25" class="tocsubsection" >
The Difference Operator</a>
</p>


<p>
<a href="Finite-Calculus.html#autosec-26" class="tocsubsection" >
Rising and Falling Factorials</a>
</p>


<p>
<a href="Algorithms.html#autosec-30" class="tocchapter" >
Algorithms</a>
</p>


<p>
<a href="Algorithms.html#autosec-31" class="tocsection" >
Graphs</a>
</p>


<p>
<a href="Algorithms.html#autosec-32" class="tocsubsection" >
Cuts</a>
</p>


<p>
<a href="Algorithms.html#autosec-42" class="tocsubsection" >
Depth-First Search</a>
</p>


<p>
<a href="Algorithms.html#autosec-44" class="tocsubsection" >
Breadth-First Search</a>
</p>


<p>
<a href="Algorithms.html#autosec-46" class="tocsubsection" >
Topological Ordering</a>
</p>


<p>
<a href="Algorithms.html#autosec-47" class="tocsubsection" >
Strongly Connected Components</a>
</p>


<p>
<a href="Greedy.html#autosec-49" class="tocsection" >
Greedy</a>
</p>


<p>
<a href="Greedy.html#autosec-50" class="tocsubsection" >
Dijkstra’s Shortest Path Algorithm</a>
</p>


<p>
<a href="Greedy.html#autosec-61" class="tocsubsection" >
Prim’s MST Algorithm</a>
</p>


<p>
<a href="Greedy.html#autosec-67" class="tocsubsection" >
Kruskal’s MST Algorithm</a>
</p>


<p>
<a href="Greedy.html#autosec-74" class="tocsubsection" >
Huffman Codes</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-81" class="tocsection" >
Divide and Conquer</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-82" class="tocsubsection" >
Master Theorem</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-84" class="tocsubsection" >
MergeSort</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-86" class="tocsubsection" >
Counting Array Inversions</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-89" class="tocsubsection" >
Karatsuba Multiplication</a>
</p>


<p>
<a href="Combinatorics.html#autosec-91" class="tocchapter" >
Combinatorics</a>
</p>


<p>
<a href="Combinatorics.html#autosec-92" class="tocsection" >
Basics of Counting</a>
</p>


<p>
<a href="Combinatorics.html#autosec-93" class="tocsubsection" >
Product Rule</a>
</p>


<p>
<a href="Combinatorics.html#autosec-96" class="tocsubsection" >
Complement Rule</a>
</p>


<p>
<a href="Combinatorics.html#autosec-100" class="tocsubsection" >
Inclusion/Exclusion</a>
</p>


<p>
<a href="Combinatorics.html#autosec-103" class="tocsubsection" >
Permutations</a>
</p>


<p>
<a href="Probability.html#autosec-106" class="tocchapter" >
Probability</a>
</p>


<p>
<a href="Probability.html#autosec-107" class="tocsection" >
Basics</a>
</p>


<p>
<a href="Probability.html#autosec-108" class="tocsubsection" >
Terminology</a>
</p>


<p>
<a href="Probability.html#autosec-110" class="tocsubsection" >
Naive Definition of Probability</a>
</p>


<p>
<a href="Probability.html#autosec-112" class="tocsubsection" >
Non-Naive Definition of Probability</a>
</p>


<p>
<a href="Foundations.html#autosec-117" class="tocchapter" >
Foundations</a>
</p>


<p>
<a href="Foundations.html#autosec-118" class="tocsection" >
Set Theory</a>
</p>


<p>
<a href="Foundations.html#autosec-122" class="tocsubsection" >
Basic Definitions</a>
</p>


<p>
<a href="Foundations.html#autosec-123" class="tocsubsection" >
Laws</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-149" class="tocsection" >
Factoring Tricks</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-150" class="tocsubsection" >
Basic Identities</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-151" class="tocsubsection" >
Splitting Apart a Monomial</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-152" class="tocsubsection" >
Adding Zero</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-153" class="tocsubsection" >
\((a^n - b^n) \)</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-155" class="tocsubsection" >
\((a^n + b^n) \)</a>
</p>


<p>
<a href="Quadratics.html#autosec-159" class="tocsection" >
Quadratics</a>
</p>


<p>
<a href="Quadratics.html#autosec-160" class="tocsubsection" >
Finding Roots of a Quadratic Function</a>
</p>


<p>
<a href="Quadratics.html#autosec-166" class="tocsubsection" >
Vieta’s Theorem</a>
</p>


<p>
<a href="Quadratics.html#autosec-169" class="tocsubsection" >
The Quadratic Formula</a>
</p>


</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<h1>Notes on Everything</h1>

<!--MathJax customizations:-->
<div data-nosnippet
    style="display:none"
>

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

</div>

<!--
...... chapter Combinatorics ......
-->
<h3 id="autosec-91">Combinatorics</h3>
<a id="index-autopage-91"></a>
<a id="index-autofile-6"></a>
<!--
...... section Basics of Counting ......
-->
<h4 id="autosec-92">Basics of Counting</h4>
<a id="index-autopage-92"></a>


<p>
These are the basic ”rules” of counting. In general, counting using these rules involves modeling the problem as a correct sequence of choices and applying the appropriate strategy to the sequence.
</p>

<p>
Proofs of the basic counting principles are usually extremely heavy on notation and formalism. As such, they tend to be cryptic and not offer very much in the way of an intuitive understanding of combinatorics. Actually, as it turns out, not much can serve as a silver
bullet for imbuing the contrived way of thinking involved in solving difficult combinatorics problems.
</p>

<p>
Solving an absurd number of problems is just about the only way to approach the subject unfortunately.
</p>
<!--
...... subsection Product Rule ......
-->
<h5 id="autosec-93">Product Rule</h5>
<a id="index-autopage-93"></a>


<p>
The Product rule is used when a counting problem is modeled after a sequence of choices. A heuristic for understanding when to use the product rule comes from comparing a situation to a logical and \(\land \) operator. In other words, if we need to pick among some
choices <em>and</em> some other choices, the total number of outcomes is given by multiplying them together.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><a id="index-autopage-94"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">3</span></span>. </span> Let \(A\) be a set of \(n\) outcomes and \(B\) be a set of \(m\) outcomes. The number of ways to choose an outcome of \(A\) and
an outcome of \(B\) is given by:
</p>

<span class="hidden"> \(\seteqnumber{0}{}{0}\)</span>

<!--


                                                                                                                  number of ways = n · m                                                                                                               (1)

-->

<p>


\begin{equation}
\text {number of ways} = n \cdot m
\end{equation}


</p>

<p>
generalizing over sets \(A_1, A_2, \dots , A_n\), the total number of outcomes is given by<sup>2</sup>:
</p>

<span class="hidden"> \(\seteqnumber{0}{}{1}\)</span>

<!--


                                                                                                                   |A1 | · |A2 | · · · · · |An |                                                                                                       (2)

-->

<p>


\begin{equation}
|A_1| \cdot |A_2| \cdot \dots \cdot |A_n|
\end{equation}


</p>

<p>


</p>

</li>

</ul>
<div role="note" class="footnotes">

<a id="index-autopage-95"></a>

<p>
<sup>2</sup>&nbsp;Unlike most of the other rules, the proof of the product rule is actually insightful, but sadly just as convoluted
</p>


</div>

</div>

<p>
This rule along with the Sum rule are the basis for virtually every counting problem. A good way to visualize the product rule is by considering the number of branches of a decision tree:
</p>
<!--
...... subsection Complement Rule ......
-->
<h5 id="autosec-96">Complement Rule</h5>
<a id="index-autopage-96"></a>


<p>
The Complement rule is helpful when expressing the size of a subset. The main idea here is to express the elements of \(A\) as a disjoint combination of \(U\) and \(A\). This comes in handy every once in a while in proofs.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><a id="index-autopage-97"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">4</span></span>. </span> Suppose \(A \subseteq B\), then
</p>

<p>
\[ |A| = |U| - |U - A| \]
</p>

<p>


</p>

</li>

</ul>

</div>
<div class="amsthmproof">

<a id="index-autopage-98"></a>

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"> <span class="amsthmproofname">Proof.</span></span> Since this just involves some straightforward thinking about sets, we might as well go ahead and prove it. Thinking through the notation slowly, all we do in the righthand expression is
remove any element not in \(A\) from \(U\). This is because the elements we take away from \(U\) are those leftover from deleting the ones in \(A\).
</p>

<p>
Admittedly, this still takes a moment to sink in. Another way of expressing this identity is to realize that we’re just talking about integers, since the equation is in terms of the <em>sizes</em> of sets. We can use a little algebra to help out:
</p>

<span class="hidden"> \(\seteqnumber{0}{}{2}\)</span>


<!--



                                                                                                                                   a = u − (u − a)
                                                                                                                                     =u−u+a
                                                                                                                                     =a



-->


<p>


\begin{align*}
a &amp;= u - (u - a) \\ &amp;= u - u + a \\ &amp;= a
\end{align*}


</p>

<p>
Since \(A \subseteq U\), all of \(A\) is already inside of \(U\). Taking away any elements not in \(A\) leaves us with exactly \(A\). Here’s a formal way of saying that<sup>3</sup>:
</p>

<p>
Suppose \(A \subseteq U\). We will show both sides of the provided equation are subsets of one another, and therefore equal by set equality. Let \(x \in A\). Then \(x \in U\) by definition of subset, and likewise \(x \not in U - A\) by set subtraction. But then \(x
\in U - (U - A)\) since it will not be removed from \(U\) during the subtraction, and so \(A \subseteq U - (U - A)\).
</p>

<p>
Now suppose \(x \in U - (U - A)\). Then \(x \in U\) and not \(U - A\) by definition of set subtraction. But if \(x \not \in U - A\), then \(x \in A\). Therefore the righthand side is also a subset of \(A\), and the proof is complete. <span
class="theoremendmark">&#x25A1;</span>
</p>

</li>

</ul>
<div role="note" class="footnotes">

<a id="index-autopage-99"></a>

<p>
<sup>3</sup>&nbsp;Actually, a subtle fact that’s glossed over here is that the theorem claims the sets are the same size. This demands that we establish a bijection between the sets, however, proving that they’re exactly the same set is (probably) good enough here
</p>


</div>

</div>
<!--
...... subsection Inclusion/Exclusion ......
-->
<h5 id="autosec-100">Inclusion/Exclusion</h5>
<a id="index-autopage-100"></a>


<p>
The Inclusion/Exclusion rule adjusts for overcounting the union of sets whose intersection is non-empty. The intuition is fairly straightforward; when taking the union of two non-disjoint sets, any element found in <em>both</em> sets will be double counted. To correct for
this misake, the inclusion/exclusion rule subtracts the intersection of the two elements, ensuring a given element is only ever counted once.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><a id="index-autopage-101"></a>
<span class="amsthmnameplain">Theorem</span><span class="amsthmnumberplain"> <span class="textup">5</span></span>. </span> Suppose \(A\) and \(B\) are sets, not necessarily disjoint. The total number of elements in the union of \(A\) and \(B\) is given
by:
</p>

<p>
\[ |A \cup B| = |A| + |B| - |A \cap B| \]
</p>

<p>


</p>

</li>

</ul>

</div>

<p>
A special case arises when \(A\) and \(B\) are disjoint. This reduces the equation to \(|A \cup B| = |A| + |B|\) since \(|A \cap B|\) is empty, which clearly has no elements. This identity is called the <b>Sum Rule</b>. Most of the time, it’s a good idea to think in
terms of the inclusion/exclusion rule until confirming whether \(A\) and \(B\) have any shared elements.
</p>
<div class="amsthmbodyplain">

<ul class="list" style="list-style-type:none">


<li>
<p>
<span class="listmarker"><a id="index-autopage-102"></a>
<span class="amsthmnameplain">Example</span><span class="amsthmnumberplain"> <span class="textup">1</span></span>. </span> For example, let \(A = \{1, 2, 3\}, \; B = \{2, 3\}\). Since \(A\) and \(B\) are not disjoint, we only want to count the
elements in their union once:
</p>

<span class="hidden"> \(\seteqnumber{0}{}{2}\)</span>


<!--



                                                                                                                             A = {1, 2, 3}
                                                                                                                             B = {2, 3}
                                                                                                                         A ∪ B = {1, 2, 3, 2, 3}
                                                                                                                         A ∩ B = {2, 3}
                                                                                                             (A ∪ B) − (A ∩ B) = {1, 2, 3}



-->


<p>


\begin{align*}
A &amp;= \{1, 2, 3\} \\ B &amp;= \{2, 3\} \\ A \cup B &amp;= \{1, 2, 3, 2, 3\} \\ A \cap B &amp;= \{2, 3\} \\ (A \cup B) - (A \cap B) &amp;= \{1, 2, 3\}
\end{align*}


</p>

</li>

</ul>

</div>
<!--
...... subsection Permutations ......
-->
<h5 id="autosec-103">Permutations</h5>
<a id="index-autopage-103"></a>


<p>
We can think of a permutation of a sequence \(n\) as a particular ordering of its elements. We consider each ordering to be a unique object. Another way to think of a permutation is a function that sends an item located at index \(i\) to index \(j\) in the output.
</p>

<p>
for example, consider the string \(S = \text {abc}\). Then the permutations of \(S\) are:
</p>

<p>
\[ \{ abc, acb, bac, bca, cab, cba \} \]
</p>

<p>
The process of arranging the elements of \(S\) is called <b>permuting</b>.
</p>

<p>
The number of permutations a given string has can be modeled as a sequence of choices for the positions of each of its characters. For a string of length \(n\) there are initially \(n\) choices. After the first character is chosen, there are \(n-1\) choices, and so on. Using the
Product Rule:
</p>

<p>
\[ n(n-1)(n-2) \dots 1 = n! \]
</p>
<!--
...... subsubsection K-Permutations ......
-->
<h6 id="autosec-104">K-Permutations</h6>
<a id="index-autopage-104"></a>


<p>
A \(K\)-Permutation follows the same basic idea of a permutation. The goal here is to count the number of subsets of size \(K\) a given set.
</p>

<p>
(Permutations can be thought of as \(k\)-permutations where \(k=n\))
</p>

<p>
Let \(S = \text {abc}, \; k = 2\). Then the \(2\)-permutations of \(S\) are:
</p>

<p>
\[ \{ ab, ba, ac, ca, bc, cb \} \]
</p>

<p>
The formula for a \(k\)-permutation uses the product rule again, this time making choices on a sequence of length \(n-k+1\):
</p>

<p>
\[ (n)(n-1)(n-2)\dots (n-k+1) = \frac {n!} {(n-k)!} \]
</p>

</section>

</main>

</div>

<footer>

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

</footer>


<nav class="botnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>

</body>
</html>
