
<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="UTF-8" />
<meta name="author" content="Anthony" />
<meta name="generator" content="LaTeX Lwarp package" />
<meta name="description" content="Personal notes on Mathematics and Computer Science" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Notes on Everything — Combinatorics</title>
<link rel="stylesheet" type="text/css" href="lwarp.css" />

<script>
// Lwarp MathJax emulation code
//
// Based on code by Davide P. Cervone.
// Equation numbering: https://github.com/mathjax/MathJax/issues/2427
// Starred and ifnextchar macros: https://github.com/mathjax/MathJax/issues/2428
// \left, \right delimiters: https://github.com/mathjax/MathJax/issues/2535
//
// Modified by Brian Dunn to adjust equation numbering and add subequations.
//
// LaTeX can use \seteqnumber{subequations?}{section}{number} before each equation.
// subequations? is 0 usually, 1 if inside subequations.
// section is a string printed as-is, or empty.
// number is auto-incremented by MathJax between equations.
//
MathJax = {
  subequations: "0",
  section: "",
  loader: {
    load: ['[tex]/tagformat', '[tex]/textmacros'],
  },
  startup: {
    ready() {
      // These would be replaced by import commands if you wanted to make
      // a proper extension.
      const Configuration = MathJax._.input.tex.Configuration.Configuration;
      const CommandMap = MathJax._.input.tex.SymbolMap.CommandMap;
      const Macro = MathJax._.input.tex.Symbol.Macro;
      const TexError = MathJax._.input.tex.TexError.default;
      const ParseUtil = MathJax._.input.tex.ParseUtil.default;
      const expandable = MathJax._.util.Options.expandable;

       // Insert the replacement string into the TeX string, and check
       // that there haven't been too many maxro substitutions (prevents
       // infinite loops).
       const useArgument = (parser, text) => {
         parser.string = ParseUtil.addArgs(parser, text, parser.string.slice(parser.i));
         parser.i = 0;
         if (++parser.macroCount > parser.configuration.options.maxMacros) {
           throw new TexError('MaxMacroSub1',
           'MathJax maximum macro substitution count exceeded; ' +
           'is there a recursive macro call?');
         }
       }

       // Create the command map for:
       //     \ifstar, \ifnextchar, \ifblank, \ifstrequal, \gsub, \seteqnumber
       new CommandMap('Lwarp-macros', {
         ifstar: 'IfstarFunction',
         ifnextchar: 'IfnextcharFunction',
         ifblank: 'IfblankFunction',
         ifstrequal: 'IfstrequalFunction',
         gsubstitute: 'GsubstituteFunction',
         seteqnumber: 'SeteqnumberFunction'
       }, {
         // This function implements an ifstar macro.
         IfstarFunction(parser, name) {
            const resultstar = parser.GetArgument(name);
            const resultnostar = parser.GetArgument(name);
            const star = parser.GetStar();                 // true if there is a *
            useArgument(parser, star ? resultstar : resultnostar);
         },

          // This function implements an ifnextchar macro.
          IfnextcharFunction(parser, name) {
            let whichchar = parser.GetArgument(name);
            if (whichchar.match(/^(?:0x[0-9A-F]+|[0-9]+)$/i)) {
              // $ syntax highlighting
              whichchar = String.fromCodePoint(parseInt(whichchar));
            }
            const resultnextchar = parser.GetArgument(name);
            const resultnotnextchar = parser.GetArgument(name);
            const gotchar = (parser.GetNext() === whichchar);
            useArgument(parser, gotchar ? resultnextchar : resultnotnextchar);
          },

          // This function implements an ifblank macro.
          IfblankFunction(parser, name) {
            const blankarg = parser.GetArgument(name);
            const resultblank = parser.GetArgument(name);
            const resultnotblank = parser.GetArgument(name);
            const isblank = (blankarg.trim() == "");
            useArgument(parser, isblank ? resultblank : resultnotblank);
          },

          // This function implements an ifstrequal macro.
          IfstrequalFunction(parser, name) {
            const strequalfirst = parser.GetArgument(name);
            const strequalsecond = parser.GetArgument(name);
            const resultequal = parser.GetArgument(name);
            const resultnotequal = parser.GetArgument(name);
            const isequal = (strequalfirst == strequalsecond);
            useArgument(parser, isequal ? resultequal : resultnotequal);
          },

          // This function implements a gsub macro.
          GsubstituteFunction(parser, name) {
            const gsubfirst = parser.GetArgument(name);
            const gsubsecond = parser.GetArgument(name);
            const gsubthird = parser.GetArgument(name);
            let gsubresult=gsubfirst.replace(gsubsecond, gsubthird);
            useArgument(parser, gsubresult);
          },

          // This function modifies the equation numbers.
          SeteqnumberFunction(parser, name) {
              // Get the macro parameters
              const star = parser.GetStar();                  // true if there is a *
              const optBrackets = parser.GetBrackets(name);   // contents of optional brackets
              const newsubequations = parser.GetArgument(name); // the subequations argument
              const neweqsection = parser.GetArgument(name); // the eq section argument
              const neweqnumber = parser.GetArgument(name);   // the eq number argument
              MathJax.config.subequations=newsubequations ;   // a string with boolean meaning
              MathJax.config.section=neweqsection ;           // a string with numeric meaning
              parser.tags.counter = parser.tags.allCounter = neweqnumber ;
          }

       });

       // Create the Lwarp-macros package
       Configuration.create('Lwarp-macros', {
         handler: {macro: ['Lwarp-macros']}
       });

       MathJax.startup.defaultReady();

       // For forward references:
       MathJax.startup.input[0].preFilters.add(({math}) => {
         if (math.inputData.recompile){
             MathJax.config.subequations = math.inputData.recompile.subequations;
             MathJax.config.section = math.inputData.recompile.section;
         }
       });
       MathJax.startup.input[0].postFilters.add(({math}) => {
         if (math.inputData.recompile){
             math.inputData.recompile.subequations = MathJax.config.subequations;
             math.inputData.recompile.section = MathJax.config.section;
         }
       });

         // For \left, \right with unicode-math:
         const {DelimiterMap} = MathJax._.input.tex.SymbolMap;
         const {Symbol} = MathJax._.input.tex.Symbol;
         const {MapHandler} = MathJax._.input.tex.MapHandler;
         const delimiter = MapHandler.getMap('delimiter');
         delimiter.add('\\lBrack', new Symbol('\\lBrack', '\u27E6'));
         delimiter.add('\\rBrack', new Symbol('\\rBrack', '\u27E7'));
         delimiter.add('\\lAngle', new Symbol('\\lAngle', '\u27EA'));
         delimiter.add('\\rAngle', new Symbol('\\rAngle', '\u27EB'));
         delimiter.add('\\lbrbrak', new Symbol('\\lbrbrak', '\u2772'));
         delimiter.add('\\rbrbrak', new Symbol('\\rbrbrak', '\u2773'));
         delimiter.add('\\lbag', new Symbol('\\lbag', '\u27C5'));
         delimiter.add('\\rbag', new Symbol('\\rbag', '\u27C6'));
         delimiter.add('\\llparenthesis', new Symbol('\\llparenthesis', '\u2987'));
         delimiter.add('\\rrparenthesis', new Symbol('\\rrparenthesis', '\u2988'));
         delimiter.add('\\llangle', new Symbol('\\llangle', '\u2989'));
         delimiter.add('\\rrangle', new Symbol('\\rrangle', '\u298A'));
         delimiter.add('\\Lbrbrak', new Symbol('\\Lbrbrak', '\u27EC'));
         delimiter.add('\\Rbrbrak', new Symbol('\\Rbrbrak', '\u27ED'));
         delimiter.add('\\lBrace', new Symbol('\\lBrace', '\u2983'));
         delimiter.add('\\rBrace', new Symbol('\\rBrace', '\u2984'));
         delimiter.add('\\lParen', new Symbol('\\lParen', '\u2985'));
         delimiter.add('\\rParen', new Symbol('\\rParen', '\u2986'));
         delimiter.add('\\lbrackubar', new Symbol('\\lbrackubar', '\u298B'));
         delimiter.add('\\rbrackubar', new Symbol('\\rbrackubar', '\u298C'));
         delimiter.add('\\lbrackultick', new Symbol('\\lbrackultick', '\u298D'));
         delimiter.add('\\rbracklrtick', new Symbol('\\rbracklrtick', '\u298E'));
         delimiter.add('\\lbracklltick', new Symbol('\\lbracklltick', '\u298F'));
         delimiter.add('\\rbrackurtick', new Symbol('\\rbrackurtick', '\u2990'));
         delimiter.add('\\langledot', new Symbol('\\langledot', '\u2991'));
         delimiter.add('\\rangledot', new Symbol('\\rangledot', '\u2992'));
         delimiter.add('\\lparenless', new Symbol('\\lparenless', '\u2993'));
         delimiter.add('\\rparengtr', new Symbol('\\rparengtr', '\u2994'));
         delimiter.add('\\Lparengtr', new Symbol('\\Lparengtr', '\u2995'));
         delimiter.add('\\Rparenless', new Symbol('\\Rparenless', '\u2996'));
         delimiter.add('\\lblkbrbrak', new Symbol('\\lblkbrbrak', '\u2997'));
         delimiter.add('\\rblkbrbrak', new Symbol('\\rblkbrbrak', '\u2998'));
         delimiter.add('\\lvzigzag', new Symbol('\\lvzigzag', '\u29D8'));
         delimiter.add('\\rvzigzag', new Symbol('\\rvzigzag', '\u29D9'));
         delimiter.add('\\Lvzigzag', new Symbol('\\Lvzigzag', '\u29DA'));
         delimiter.add('\\Rvzigzag', new Symbol('\\Rvzigzag', '\u29DB'));
         delimiter.add('\\lcurvyangle', new Symbol('\\lcurvyangle', '\u29FC'));
         delimiter.add('\\rcurvyangle', new Symbol('\\rcurvyangle', '\u29FD'));
         delimiter.add('\\Vvert', new Symbol('\\Vvert', '\u2980'));
   }     // ready
 },      // startup

 tex: {
   packages: {'[+]': ['tagformat', 'Lwarp-macros', 'textmacros']},
   tags: "ams",
        tagformat: {
            number: function (n) {
                if(MathJax.config.subequations==0)
                    return(MathJax.config.section + n);
                else
                    return(MathJax.config.section + String.fromCharCode(96+n));
            },
        },
 }
}
</script>

<script
    id="MathJax-script"
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
></script>

</head>
<body>


<a id="index-autopage-65"></a>
<nav class="topnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>


<div class="bodyandsidetoc">
<div class="sidetoccontainer">


<nav class="sidetoc">


<div class="sidetoctitle">

<p>
<span class="sidetocthetitle">Notes on Everything</span>
</p>

<p>
Subjects
</p>
</div>


<div class="sidetoccontents">

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

<p>
<a href="Sums.html#autosec-6" class="tocchapter" >
Sums</a>
</p>


<p>
<a href="Sums.html#autosec-7" class="tocsection" >
Manipulating Sums</a>
</p>


<p>
<a href="Sums.html#autosec-8" class="tocsubsection" >
Basic Rules</a>
</p>


<p>
<a href="Sums.html#autosec-10" class="tocsubsection" >
Iverson Notation</a>
</p>


<p>
<a href="Sums.html#autosec-13" class="tocsubsection" >
Perturbing the Sum</a>
</p>


<p>
<a href="Sums.html#autosec-16" class="tocsubsection" >
Multiple Sums</a>
</p>


<p>
<a href="Algorithms.html#autosec-24" class="tocchapter" >
Algorithms</a>
</p>


<p>
<a href="Algorithms.html#autosec-25" class="tocsection" >
Greedy</a>
</p>


<p>
<a href="Algorithms.html#autosec-26" class="tocsubsection" >
Dijkstra’s Shortest Path Algorithm</a>
</p>


<p>
<a href="Algorithms.html#autosec-37" class="tocsubsection" >
Prim’s MST Algorithm</a>
</p>


<p>
<a href="Algorithms.html#autosec-42" class="tocsubsection" >
Kruskal’s MST Algorithm</a>
</p>


<p>
<a href="Algorithms.html#autosec-49" class="tocsubsection" >
Huffman Codes</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-56" class="tocsection" >
Divide and Conquer</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-57" class="tocsubsection" >
Master Theorem</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-59" class="tocsubsection" >
MergeSort</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-61" class="tocsubsection" >
Counting Array Inversions</a>
</p>


<p>
<a href="Divide-Conquer.html#autosec-64" class="tocsubsection" >
Karatsuba Multiplication</a>
</p>


<p>
<a href="Combinatorics.html#autosec-66" class="tocchapter" >
Combinatorics</a>
</p>


<p>
<a href="Combinatorics.html#autosec-67" class="tocsection" >
Basics of Counting</a>
</p>


<p>
<a href="Combinatorics.html#autosec-68" class="tocsubsection" >
Product Rule</a>
</p>


<p>
<a href="Combinatorics.html#autosec-69" class="tocsubsection" >
Complement Rule</a>
</p>


<p>
<a href="Combinatorics.html#autosec-70" class="tocsubsection" >
Sum Rule</a>
</p>


<p>
<a href="Combinatorics.html#autosec-71" class="tocsubsection" >
Inclusion/Exclusion</a>
</p>


<p>
<a href="Combinatorics.html#autosec-72" class="tocsubsection" >
Permutations</a>
</p>


<p>
<a href="Foundations.html#autosec-75" class="tocchapter" >
Foundations</a>
</p>


<p>
<a href="Foundations.html#autosec-76" class="tocsection" >
Set Theory</a>
</p>


<p>
<a href="Foundations.html#autosec-80" class="tocsubsection" >
Basic Definitions</a>
</p>


<p>
<a href="Foundations.html#autosec-81" class="tocsubsection" >
Laws</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-107" class="tocsection" >
Factoring Tricks</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-108" class="tocsubsection" >
Basic Identities</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-109" class="tocsubsection" >
Splitting Apart a Monomial</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-110" class="tocsubsection" >
Adding Zero</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-111" class="tocsubsection" >
\((a^n - b^n) \)</a>
</p>


<p>
<a href="Factoring-Tricks.html#autosec-113" class="tocsubsection" >
\((a^n + b^n) \)</a>
</p>


<p>
<a href="Quadratics.html#autosec-117" class="tocsection" >
Quadratics</a>
</p>


<p>
<a href="Quadratics.html#autosec-118" class="tocsubsection" >
Finding Roots of a Quadratic Function</a>
</p>


<p>
<a href="Quadratics.html#autosec-124" class="tocsubsection" >
Vieta’s Theorem</a>
</p>


<p>
<a href="Quadratics.html#autosec-127" class="tocsubsection" >
The Quadratic Formula</a>
</p>


</div>

</nav>

</div>


<main class="bodycontainer">


<section class="textbody">

<h1>Notes on Everything</h1>

<!--MathJax customizations:-->
<div data-nosnippet
    style="display:none"
>

\(\newcommand{\footnotename}{footnote}\)

\(\def \LWRfootnote {1}\)

\(\newcommand {\footnote }[2][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\newcommand {\footnotemark }[1][\LWRfootnote ]{{}^{\mathrm {#1}}}\)

\(\let \LWRorighspace \hspace \)

\(\renewcommand {\hspace }{\ifstar \LWRorighspace \LWRorighspace }\)

\(\newcommand {\mathnormal }[1]{{#1}}\)

\(\newcommand \ensuremath [1]{#1}\)

\(\newcommand {\LWRframebox }[2][]{\fbox {#2}} \newcommand {\framebox }[1][]{\LWRframebox } \)

\(\newcommand {\setlength }[2]{}\)

\(\newcommand {\addtolength }[2]{}\)

\(\newcommand {\setcounter }[2]{}\)

\(\newcommand {\addtocounter }[2]{}\)

\(\newcommand {\arabic }[1]{}\)

\(\newcommand {\number }[1]{}\)

\(\newcommand {\noalign }[1]{\text {#1}\notag \\}\)

\(\newcommand {\cline }[1]{}\)

\(\newcommand {\directlua }[1]{\text {(directlua)}}\)

\(\newcommand {\luatexdirectlua }[1]{\text {(directlua)}}\)

\(\newcommand {\protect }{}\)

\(\def \LWRabsorbnumber #1 {}\)

\(\def \LWRabsorbquotenumber &quot;#1 {}\)

\(\newcommand {\LWRabsorboption }[1][]{}\)

\(\newcommand {\LWRabsorbtwooptions }[1][]{\LWRabsorboption }\)

\(\def \mathchar {\ifnextchar &quot;\LWRabsorbquotenumber \LWRabsorbnumber }\)

\(\def \mathcode #1={\mathchar }\)

\(\let \delcode \mathcode \)

\(\let \delimiter \mathchar \)

\(\def \oe {\unicode {x0153}}\)

\(\def \OE {\unicode {x0152}}\)

\(\def \ae {\unicode {x00E6}}\)

\(\def \AE {\unicode {x00C6}}\)

\(\def \aa {\unicode {x00E5}}\)

\(\def \AA {\unicode {x00C5}}\)

\(\def \o {\unicode {x00F8}}\)

\(\def \O {\unicode {x00D8}}\)

\(\def \l {\unicode {x0142}}\)

\(\def \L {\unicode {x0141}}\)

\(\def \ss {\unicode {x00DF}}\)

\(\def \SS {\unicode {x1E9E}}\)

\(\def \dag {\unicode {x2020}}\)

\(\def \ddag {\unicode {x2021}}\)

\(\def \P {\unicode {x00B6}}\)

\(\def \copyright {\unicode {x00A9}}\)

\(\def \pounds {\unicode {x00A3}}\)

\(\let \LWRref \ref \)

\(\renewcommand {\ref }{\ifstar \LWRref \LWRref }\)

\( \newcommand {\multicolumn }[3]{#3}\)

\(\require {textcomp}\)

\(\newcommand {\intertext }[1]{\text {#1}\notag \\}\)

\(\let \Hat \hat \)

\(\let \Check \check \)

\(\let \Tilde \tilde \)

\(\let \Acute \acute \)

\(\let \Grave \grave \)

\(\let \Dot \dot \)

\(\let \Ddot \ddot \)

\(\let \Breve \breve \)

\(\let \Bar \bar \)

\(\let \Vec \vec \)

</div>

<!--
...... chapter Combinatorics ......
-->
<h3 id="autosec-66">Combinatorics</h3>
<a id="index-autopage-66"></a>
<a id="index-autofile-4"></a>
<!--
...... section Basics of Counting ......
-->
<h4 id="autosec-67">Basics of Counting</h4>
<a id="index-autopage-67"></a>


<p>
These are the basic ”rules” of counting. In general, counting using these rules involves modeling the problem as a correct sequence of choices and applying the appropriate strategy to the sequence.
</p>
<!--
...... subsection Product Rule ......
-->
<h5 id="autosec-68">Product Rule</h5>
<a id="index-autopage-68"></a>


<p>
The Product rule is applied to combinatorial problems that can be modeled as a ”process” of making mutually exclusive choices. For such problems the total number of ways to perform the process is given by multiplying the number of options at each step.
</p>

<span class="hidden"> \(\seteqnumber{0}{}{0}\)</span>

<!--


                                                                                                                   number of ways = N1 · N2 · · · · · Nk                                                                                                       (1)

-->

<p>

\begin{equation}
\text {number of ways} = N_1 \cdot N_2 \cdot \dots \cdot N_k
\end{equation}

</p>

<p>
where \(N_i\) is the number of ways of performing the \(i\)th step of the process.
</p>
<!--
...... subsection Complement Rule ......
-->
<h5 id="autosec-69">Complement Rule</h5>
<a id="index-autopage-69"></a>


<p>
The Complement rule is helpful when expressing the size of a subset. Suppose \(A \subseteq U\), then
</p>

<p>
\[ |A| = |U| - |U - A| \]
</p>

<p>
In other words, the size of \(A\) is the same as the size of \(U\) when taking away the elements of \(U\) which are also in \(A\) (leaving behind only those elements which belong to \(A\)).
</p>

<p>
(I remember this ”algebraically”: \(U - (U - A) = U - U + A = A\))
</p>
<!--
...... subsection Sum Rule ......
-->
<h5 id="autosec-70">Sum Rule</h5>
<a id="index-autopage-70"></a>


<p>
This is a specicial form of the Inclusion/Exclusion rule applicable for sets of elements who are mutually disjoint.
</p>
<!--
...... subsection Inclusion/Exclusion ......
-->
<h5 id="autosec-71">Inclusion/Exclusion</h5>
<a id="index-autopage-71"></a>


<p>
The Inclusion/Exclusion rule is a generalization of the Sum rule, and can be used when sets are not-disjoint. The intuition here is to subtract the ”double- counted” elements from the union of two sets.
</p>

<p>
\[ |A \cup B| = |A| + |B| - |A \cap B| \]
</p>

<p>
For example, let \(A = \{1, 2, 3\}, \; B = \{2, 3\}\). Since \(A\) and \(B\) are not disjoint, we only want to count the elements in their union once:
</p>

<span class="hidden"> \(\seteqnumber{0}{}{1}\)</span>


<!--


                                                                                                                         A = {1, 2, 3}
                                                                                                                         B = {2, 3}
                                                                                                                         A ∪ B = {1, 2, 3, 2, 3}
                                                                                                                         A ∩ B = {2, 3}
                                                                                                                         (A ∪ B) − (A ∩ B) = {1, 2, 3}


-->


<p>

\begin{align*}
&amp;A = \{1, 2, 3\} \\ &amp;B = \{2, 3\} \\ &amp;A \cup B = \{1, 2, 3, 2, 3\} \\ &amp;A \cap B = \{2, 3\} \\ &amp;(A \cup B) - (A \cap B) = \{1, 2, 3\}
\end{align*}

</p>

<p>
When \(A\) and \(B\) are disjoint, their intersection is \(0\), and so the formula holds.
</p>
<!--
...... subsection Permutations ......
-->
<h5 id="autosec-72">Permutations</h5>
<a id="index-autopage-72"></a>


<p>
We can think of a permutation of a sequence \(n\) as a particular ordering of its elements. We consider each ordering to be a unique object. Another way to think of a permutation is a function that sends an item located at index \(i\) to index \(j\) in the output.
</p>

<p>
for example, consider the string \(S = \text {abc}\). Then the permutations of \(S\) are:
</p>

<p>
\[ \{ abc, acb, bac, bca, cab, cba \} \]
</p>

<p>
The process of arranging the elements of \(S\) is called <b>permuting</b>.
</p>

<p>
The number of permutations a given string has can be modeled as a sequence of choices for the positions of each of its characters. For a string of length \(n\) there are initially \(n\) choices. After the first character is chosen, there are \(n-1\) choices, and so on. Using the
Product Rule:
</p>

<p>
\[ n(n-1)(n-2) \dots 1 = n! \]
</p>
<!--
...... subsubsection K-Permutations ......
-->
<h6 id="autosec-73">K-Permutations</h6>
<a id="index-autopage-73"></a>


<p>
A \(K\)-Permutation follows the same basic idea of a permutation. The goal here is to count the number of subsets of size \(K\) a given set.
</p>

<p>
(Permutations can be thought of as \(k\)-permutations where \(k=n\))
</p>

<p>
Let \(S = \text {abc}, \; k = 2\). Then the \(2\)-permutations of \(S\) are:
</p>

<p>
\[ \{ ab, ba, ac, ca, bc, cb \} \]
</p>

<p>
The formula for a \(k\)-permutation uses the product rule again, this time making choices on a sequence of length \(n-k+1\):
</p>

<p>
\[ (n)(n-1)(n-2)\dots (n-k+1) = \frac {n!} {(n-k)!} \]
</p>

</section>

</main>

</div>

<footer>

<p>
<a href="index.html" class="linkhome" >
Home</a>
</p>

</footer>


<nav class="botnavigation"><a href="index.html" class="linkhome" >
Home</a></nav>

</body>
</html>
